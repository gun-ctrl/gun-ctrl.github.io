<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/07/12/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="对象与垃圾回收机制"><a href="#对象与垃圾回收机制" class="headerlink" title="对象与垃圾回收机制"></a>对象与垃圾回收机制</h2><h3 id="虚拟机中对象的创建过程（一般的对象）"><a href="#虚拟机中对象的创建过程（一般的对象）" class="headerlink" title="虚拟机中对象的创建过程（一般的对象）"></a>虚拟机中对象的创建过程（一般的对象）</h3><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654604728175.png" alt="1654604728175"></p>
<p>####分配内存</p>
<p>内存划分引发的并发编程问题（指针碰撞） 解决方案：</p>
<ul>
<li><p>CAS加锁</p>
</li>
<li><p>本地线程分配缓冲TLAB（Thread Local Allocation Buffer）：</p>
<p>给每个线程分配一块区域（一般在Eden区）</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654605674590.png" alt="1654605674590"></p>
</li>
</ul>
<h4 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h4><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654606215316.png" alt="1654606215316"></p>
<p>先初始化默认值（不需要赋值就可以使用，当然程序可以越早使用对象那么效率越高）</p>
<h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>对象属于哪个class，设置对象头信息</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654606417813.png" alt="1654606417813"></p>
<ul>
<li>对象头<ul>
<li>Mark Word（前面并发编程中提及过）</li>
<li>类型指针：对应哪个类型class</li>
<li>若是对象数组，还应该有记录数组的长度</li>
</ul>
</li>
</ul>
<p>####对象的初始化</p>
<ul>
<li>执行构造方法</li>
</ul>
<h3 id="对象访问定位"><a href="#对象访问定位" class="headerlink" title="对象访问定位"></a>对象访问定位</h3><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654655214373.png" alt="1654655214373"></p>
<ul>
<li>使用句柄<ul>
<li>引用reference不再存对象地址，而是存对象所对应的指针（句柄），句柄池再映射一次。</li>
<li>句柄池具有指针定位的开销，开销比较小。</li>
</ul>
</li>
<li>直接指针<ul>
<li>直接指向真实的地址（Hotspot以及一些主流的虚拟机就使用这种）</li>
</ul>
</li>
</ul>
<h3 id="判断对象的存活"><a href="#判断对象的存活" class="headerlink" title="判断对象的存活"></a>判断对象的存活</h3><h4 id="引用计数法与可达性分析算法"><a href="#引用计数法与可达性分析算法" class="headerlink" title="引用计数法与可达性分析算法"></a>引用计数法与可达性分析算法</h4><p>对象被引用-&gt;引用计数+1  引用失效-&gt;引用计数-1  当引用计数0-&gt;GC</p>
<p>对象的相互引用的问题</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654656705723.png" alt="1654656705723"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654656962280.png" alt="1654656962280"></p>
<h4 id="finalize（使用可达性分析算法，对象一定被GC吗？）"><a href="#finalize（使用可达性分析算法，对象一定被GC吗？）" class="headerlink" title="finalize（使用可达性分析算法，对象一定被GC吗？）"></a>finalize（使用可达性分析算法，对象一定被GC吗？）</h4><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654657208631.png" alt="1654657208631"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654657323253.png" alt="1654657323253"><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654657423870.png" alt="1654657423870"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654657449330.png" alt="1654657449330"></p>
<p>可以看到第一次GC的时候对象依然存在</p>
<p>第二次GC的时候对象被GC了</p>
<ul>
<li><p>finalize()只能执行一次</p>
<p>且优先级低</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654657549347.png" alt="优先级低"></p>
</li>
<li><p>finalize()不一定能救活对象</p>
</li>
<li><p>所以<strong>使用try finally</strong>救活对象更好。</p>
</li>
</ul>
<h4 id="关于try-catch-finally"><a href="#关于try-catch-finally" class="headerlink" title="关于try catch finally"></a>关于try catch finally</h4><ul>
<li>不管有没有出现异常，finally块中的代码一定会执行</li>
<li>当try和catch中有return时，finally仍然会执行</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值只在finally执行之前确定的</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中包含的返回值。</li>
</ul>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654658053455.png" alt="1654658053455"></p>
<ul>
<li><p>强引用：就像我们平时使用的“&#x3D;”</p>
</li>
<li><p>软引用（SoftReference）：</p>
<p>当OOM时被回收</p>
<ul>
<li>软引用测试：</li>
</ul>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654658511709.png" alt="1654658511709"></p>
<p>第一次测试结果：</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654658638965.png" alt="1654658638965"></p>
<p>第二次测试结果：</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654658686941.png" alt="1654658686941"></p>
<ul>
<li><strong>软引用的实际使用：图片加载</strong></li>
</ul>
</li>
<li><p>弱引用（WeakReference）：</p>
<p>只要GC就被回收</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654659017602.png" alt="1654659017602"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654659061704.png" alt="1654659061704"></p>
<ul>
<li>实际应用：一些不是很重要的东西，比如缓存。可以用来防止内存泄漏</li>
<li>实际过程中弱引用使用的更多，因为发生GC的频次肯定比OOM的频次高</li>
<li>（Activity作为弱引用也常用，防止页面退出被引用。）最好别回答这一条</li>
</ul>
</li>
<li><p>虚引用（PhantomReference）：</p>
<ul>
<li><p>最弱的：随时会被回收，GC时会收到一个通知</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654659537857.png" alt="1654659537857"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654659543594.png" alt="1654659543594"></p>
</li>
<li><p>作用：监控垃圾回收器是否正常工作</p>
</li>
</ul>
</li>
</ul>
<h4 id="什么时候触发GC"><a href="#什么时候触发GC" class="headerlink" title="什么时候触发GC"></a>什么时候触发GC</h4><ul>
<li>内存不足时</li>
<li>不会主动触发</li>
</ul>
<h3 id="对象分配的策略"><a href="#对象分配的策略" class="headerlink" title="对象分配的策略"></a>对象分配的策略</h3><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654660542854.png" alt="1654660542854"></p>
<ul>
<li><p><strong>几乎</strong>所有的对象都在堆中分配</p>
<ul>
<li>所以不是所有的对象都是在堆  中分配</li>
</ul>
</li>
<li><p>栈上分配 -&gt; 虚拟机栈</p>
<ul>
<li>栈中运行完了，不需要垃圾回收，栈是跟随线程存在。</li>
</ul>
</li>
<li><p>逃逸分析</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654660876349.png" alt="1654660876349"></p>
</li>
<li><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654661120026.png" alt="1654661120026">jdk1.8中这个参数默认是开启的，满足逃逸分析则放入栈中。</p>
</li>
<li><p>堆中的优化技术</p>
<ul>
<li>本地线程缓冲（TLAB）</li>
</ul>
</li>
<li><p>如果是大对象（很长的字符串、数组）</p>
<ul>
<li><p>放入到老年代（Tenured）中</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654664596550.png" alt="1654664596550"></p>
</li>
</ul>
</li>
<li><p>长期存活的对象进入老年代</p>
<ul>
<li><p>首先进入From区，然后接下来的GC中在From和To区移动（复制回收算法，只要把复制的对象传递过去，就可以对内存区域直接处理，效率高）</p>
</li>
<li><p>age最大15，超过15将进入老年代，age也可以自定义</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654665122167.png" alt="1654665122167"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654665445063.png" alt="1654665445063"></p>
</li>
<li><p>From区与To区等大</p>
</li>
<li><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654665363057.png" alt="1654665363057"></p>
</li>
<li><p>根据大数据：大部分的新生对象中90%以上会在第一次GC被回收，剩下的才进入From区，所以可以让我们的空间利用率达到90%以上。</p>
</li>
</ul>
</li>
<li><p><strong>空间分配担保</strong></p>
<ul>
<li><p>From区与To区空间不够用，进入老年代（Tenured区）</p>
</li>
<li><p>由JVM做担保，不用fullGC（GC在堆中分为minorGC和fullGC），空间够用</p>
</li>
<li><p>如果担保失败（空间不够用），那么首先需要fullGC，然后再存储对象到老年代</p>
</li>
<li><p>如此处理，就不用再每次向老年代存储对象时都fullGC</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654666593800.png" alt="1654666593800"></p>
</li>
</ul>
</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><p>1、绝大部分对象都是朝生夕死。 –区域:新生代</p>
<p>2、对象熬过了很多次垃圾回收，越难回收。 –区域：老年代</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654828321082.png" alt="1654828321082"></p>
<p>fullGC也会回收包括方法区在内的空间，即使方法区中的内容很难回收（静态变量、常量…）</p>
<p>####复制算法（即前面的复制回收算法）</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654829048496.png" alt="1654829048496"></p>
<ul>
<li><p>实现简单、运行高效</p>
</li>
<li><p>内存复制、没有内存碎片</p>
</li>
<li><p>利用率只有一半（预留一半进行复制）</p>
</li>
<li><p>Appel式回收</p>
<p>即前面提到的，Eden区与From、To区分配比例大致为8:1:1（理由上面提及过，第一次回收时90%以上的都会被回收，只有不到10%才能进入From区）</p>
<p>这样使空间利用率提高了，提升至90%。</p>
</li>
</ul>
<p>####标记清除算法</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654829642217.png" alt="1654829642217"></p>
<ul>
<li>执行效率不稳定（可能有90%需要回收、可能10%需要回收）</li>
<li>内存碎片导致提前GC</li>
</ul>
<h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654829870268.png" alt="1654829870268"></p>
<ul>
<li>对象移动</li>
<li>引用更新</li>
<li>用户线程暂停</li>
<li>没有内存碎片</li>
</ul>
<h4 id="JVM中常见的垃圾回收器"><a href="#JVM中常见的垃圾回收器" class="headerlink" title="JVM中常见的垃圾回收器"></a>JVM中常见的垃圾回收器</h4><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654830535603.png" alt="1654830535603"></p>
<p><strong>简单的垃圾回收器工作示意图</strong></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654830417909.png" alt="1654830417909"></p>
<p><strong>多线程并发垃圾收集器</strong>：支持垃圾回收线程与用户线程 同时工作。</p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>Concurrent Mark Seep并发标记清除</p>
<p>减少了STW（Stop The World）的时间</p>
<p>只针对老年代</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654830900789.png" alt="1654830900789"></p>
<p><strong>标记阶段</strong></p>
<ul>
<li>初始标记（暂停所有用户线程）：标记GCRoots直接相连的对象，所以速度很快—</li>
<li>并发标记：标记GCRoots所有关联的对象。</li>
<li>重新标记（暂停所有用户线程）：将中间有变动的重新标记（并发收集是GC不干净的，所以需要重新标记），时间短</li>
</ul>
<p><strong>清理阶段</strong></p>
<ul>
<li>并发清理（用户和GC同时进行）：时间长</li>
<li>重置线程</li>
</ul>
<p>缺点：</p>
<ul>
<li>CPU敏感：用户线程、GC线程都要跑，如果CPU核心数不足，那么对用户影响会很大</li>
<li>浮动垃圾：并发清理时，用户线程还是会产生垃圾</li>
<li>内存碎片</li>
</ul>
<p><strong>G1作为了解</strong>（Android中一般不采用）</p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654862737983.png" alt="1654862737983"></p>
<h4 id="Stop-The-World（STW）"><a href="#Stop-The-World（STW）" class="headerlink" title="Stop The World（STW）"></a>Stop The World（STW）</h4><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654862879179.png" alt="1654862879179"></p>
<h3 id="常量池和String"><a href="#常量池和String" class="headerlink" title="常量池和String"></a>常量池和String</h3><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654863606269.png" alt="1654863606269"></p>
<h4 id="静态常量池"><a href="#静态常量池" class="headerlink" title="静态常量池"></a>静态常量池</h4><p>所谓<strong>静态常量池</strong>，即*.class文件中的常量池，class文件中的常量池不只仅包含字符串(数字)<strong>字面量</strong>，还包含类、方法的信息，占用class文件绝大部分空间。 </p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654863676748.png" alt="1654863676748"></p>
<p>字面量：int i&#x3D;13</p>
<p>符号引用：String这个类-&gt;java.lang.String</p>
<p>类的、方法的信息</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>而<strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，<strong>咱们常说的常量池，就是指方法区中的运行时常量池。</strong> </p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654863930934.png" alt="1654863930934"></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote>
<p>特别注意：String str &#x3D; new String(“abc”);</p>
</blockquote>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654865649956.png" alt="1654865649956"></p>
<p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654865177371.png" alt="1654865177371"></p>
<p><strong>intern()</strong><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654865473328.png" alt="1654865473328"></p>
<h2 id="面试哪些事儿"><a href="#面试哪些事儿" class="headerlink" title="面试哪些事儿"></a>面试哪些事儿</h2><p><img src="/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.assets/1654865718718.png" alt="1654865718718"></p>
<h4 id="什么情况下内存栈溢出"><a href="#什么情况下内存栈溢出" class="headerlink" title="什么情况下内存栈溢出"></a>什么情况下内存栈溢出</h4><ul>
<li>1.无限递归 -&gt;Stack Overflow</li>
<li>2.不断地创建线程</li>
</ul>
<h4 id="GC收集算法有哪些？它们的特点是什么？"><a href="#GC收集算法有哪些？它们的特点是什么？" class="headerlink" title="GC收集算法有哪些？它们的特点是什么？"></a>GC收集算法有哪些？它们的特点是什么？</h4><ul>
<li>复制算法</li>
<li>标记清除算法</li>
<li>标记整理算法</li>
</ul>
<h4 id="final、finally、finalize的区别是什么？"><a href="#final、finally、finalize的区别是什么？" class="headerlink" title="final、finally、finalize的区别是什么？"></a>final、finally、finalize的区别是什么？</h4><p><strong>final</strong>：修饰类（断子绝孙类）、变量、方法</p>
<p><strong>finally</strong>：不管有没有发生异常都会执行finally代码块的内容。</p>
<p>关于try catch finally</p>
<ul>
<li>不管有没有出现异常，finally块中的代码一定会执行</li>
<li>当try和catch中有return时，finally仍然会执行</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值只在finally执行之前确定的</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中包含的返回值。</li>
</ul>
<p><strong>finalize</strong>：只能执行一次，且不一定会执行，优先级比较低。</p>
]]></content>
  </entry>
</search>
