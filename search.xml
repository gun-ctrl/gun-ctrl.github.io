<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CoordinatorLayout原理解析与Behavior</title>
    <url>/2022/08/06/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8EBehavior/</url>
    <content><![CDATA[<h2 id="CoordinatorLayout的功能"><a href="#CoordinatorLayout的功能" class="headerlink" title="CoordinatorLayout的功能"></a>CoordinatorLayout的功能</h2><p><strong>事先警示：</strong>CoordinatorLayout只继承了NestedScrollParent，也就是说它只能做顶层父View，别踩坑！！！</p>
<p>1.处理子控件之间依赖下的交互<br>2.处理子控件之间的嵌套滑动<br>3.处理子控件的测量与布局<br>4.处理子控件的事件拦截与响应<br>以上四个功能，都建立与CoordinatorLayout中提供的一个叫做Behavior的“插件”之上。Behavior内部也提供了相应方法来对应这四个不同的功能。<br>Behavior内部集成了上述四种功能对应的方法，实现解耦。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806114929932.png" alt="image-20220806114929932"></p>
<p><strong>什么是Behavior？</strong><br>可以把Behavior理解成插件，当我们的组件想实现什么样的功能的时候就使用对应的Behavior，也就是说很多种不同功能的Behavior，当然也可以自定义Behavior。</p>
<h2 id="CoordinatorLayout下依赖交互原理"><a href="#CoordinatorLayout下依赖交互原理" class="headerlink" title="CoordinatorLayout下依赖交互原理"></a>CoordinatorLayout下依赖交互原理</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115038051.png" alt="image-20220806115038051"></p>
<blockquote>
<p>当CoordinatorLayout中子控件dependency的位置、大小发生变化的时候，那么在CoordinatorLayout内部会通知所有依赖depandency的控件，并调用对应声明的Behavior，告知其依赖的dependency发生变化。<br>那么如何判断依赖-&gt;layoutDependsOn<br>接收到通知后如何处理-&gt;onDependentViewChanged&#x2F;onDependentViewRemoved<br>这些都是由Behavior来处理。</p>
</blockquote>
<h3 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h3><ul>
<li><p><strong>layoutDependsOn(CoordinatorLayout parent, View child, View dependency)</strong>  表示是否给应用了Behavior 的View 指定一个依赖的布局</p>
<ul>
<li>参数1：coordinatorlayout对象</li>
<li>参数2：child 被观察的View</li>
<li>参数3：依赖变化的View（被观察的View）</li>
</ul>
</li>
<li><p><strong>onDependentViewChanged(CoordinatorLayout parent, View child, View dependency)</strong> 当依赖的View发生变化的时候hi掉的方法</p>
</li>
<li><p><strong>onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type)</strong> 当用户手指按下的时候，你是否要处理这次操作。当你确定要处理这次操作的时候，返回true；如果返回false的时候，就不会去响应后面的回调事件了。你想怎么滑就怎么话，我都不做处理。这里的(axes)滚动方向很重要，可以通过此参数判断滚动方向！</p>
<ul>
<li>参数3：直接目标，相当于能滑动的控件</li>
<li>参数4：观察的View</li>
<li>参数5：这个可以简单理解为滚动方向<ul>
<li>ViewCompat#SCROLL_AXIS_HORIZONTAL 水平方向</li>
<li>ViewCompat#SCROLL_AXIS_VERTICAL 竖直方向</li>
</ul>
</li>
<li>参数6：这个参数是之后有的，如果你输入的类型不是TYPE_TOUCH那么就不会相应这个滚动</li>
</ul>
</li>
<li><p><strong>onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</strong> 当onStartNestedScroll准备处理这次滑动的时候(返回true的时候)，回调这个方法。可以在这个方法中做一些响应的准备工作！</p>
</li>
<li><p><strong>onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</strong> 当滚动开始执行的时候回调这个方法。</p>
<ul>
<li>参数4&#x2F;参数5：用户x&#x2F;y轴滚动的距离(注意这里是每一次都回调的啊！！！)</li>
<li>参数6：处理滚动的距离的参数，内部维护着输出距离，假设用户滑动了100px,child 做了90px的位移，你需要把consumed［1］的值改成90，这样coordinatorLayout就能知道只处理剩下的10px的滚动。其中consumed[0]代表x轴、consumed[1]代表y轴。可能你不理解这个问题，换个形象点的比喻，比如你开发某一个功能，但是你只会其中的90%那么怎么办呢？不能就不管了。好你找到了你的同事或者老大，让他去完成剩下的10%。这样问题就完美的解决了，是一个概念的！</li>
</ul>
</li>
<li><p><strong>onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type)</strong> 上面这个方法结束的时候，coordinatorLayout处理剩下的距离，比如还剩10px。但是coordinatorLayout发现滚动2px的时候就已经到头了。那么结束其滚动，调用该方法，并将coordinatorLayout处理剩下的像素数作为参<code>(dxUnconsumed、dyUnconsumed)</code>传过来，这里传过来的就是 8px。参数中还会有coordinatorLayout处理过的像素数（dxConsumed、dyConsumed）。老大开始处理剩下的距离了！这个方法主要处理一些越界后的滚动。还是不懂对吧！还拿你们老大做比喻：比如上面还剩 10%的工作，这时老大处理了2%后发现已经可以上线了，于是老大结束了工作，并将处理剩下的内容（dxUnconsumed、dyUnconsumed）纪录下来，告诉你。老大处理了的内容（dxConsumed、dyConsumed）也告诉了你。</p>
<ul>
<li>参数4&#x2F;参数5：当没有滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
<li>参数6&#x2F;参数7：当滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
</ul>
</li>
<li><p>onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, float velocityX, float velocityY) 当手指松开发生惯性动作之前调用，这里提供了响应的速度，你可以根据速度判断是否需要进行折叠等一系列的操作，你要确定响应这个方法的话，返回true。</p>
<ul>
<li>参数4&#x2F;参数5：代表相应的速度</li>
</ul>
</li>
<li><p>onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int type) 停止滚动的时候回调的方法。当你不去响应Fling的时候会直接回调这个方法。在这里可以做一些清理工作。或者其他的内容。。。</p>
</li>
<li><p>onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) 确定子View位置的方法，这个方法可以重新定义子View的位置(这里明确是设置behavior的那个View哦),例如下面这样</p>
<ul>
<li>ViewCompat#LAYOUT_DIRECTION_LTR 视图方向从左到右</li>
<li>ViewCompat#LAYOUT_DIRECTION_RTL 视图方向从优到左</li>
</ul>
</li>
</ul>
<h2 id="CoordinatorLayout下嵌套滑动原理"><a href="#CoordinatorLayout下嵌套滑动原理" class="headerlink" title="CoordinatorLayout下嵌套滑动原理"></a>CoordinatorLayout下嵌套滑动原理</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115051276.png" alt="image-20220806115051276"></p>
<blockquote>
<p>CoordinatorLayout实现了NestedScrollingParent2接口。那么当事件(scroll或fling)产生后，内部实现了NestedScrollingChild接口的子控件会将事件分发给CoordinatorLayout，CoordinatorLayout又会将事件传递给所有的Behavior中实现子控件的嵌套滑动。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806142237581.png" alt="image-20220806142237581"></p>
<blockquote>
<p>相对于NestedScrollView机制（参数角色只有子控件和父控件），CoordinatorLayout中的交互角色玩出了新高度，在CoordinatorLayout下的子控件可以与多个兄弟控件进行交互。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115109848.png" alt="image-20220806115109848"></p>
</blockquote>
<p>大家可以看一下整个事件的流程图</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806144653508.png" alt="image-20220806144653508"></p>
<p><strong>浅谈View的生命周期</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115156782.png" alt="image-20220806115156782"></p>
<blockquote>
<p>层级关系：activity-&gt;window-&gt;view<br>LayoutInflater.inflate将view解析出来<br>在onFinishInflate阶段add到content中，content属于DecorView<br>在Activity中通过attach方法new一个PhoneWindow<br>在resume阶段通过makevisible方法PhoneWindow.addView(DecorView)<br>再回调onAttachToWindow，然后已经一系列方法（包括setView-&gt;WMS…开始绘制)才呈现出View</p>
</blockquote>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>下面是截取的重要源码截图</p>
<p><strong>ViewTreeObserver介绍</strong></p>
<blockquote>
<p>ViewTreeObserver注册一个观察者来监听视图树，当是图书的布局、视图树的焦点、视图将要绘制、视图滚动等发生改变时，ViewTreeObserver都会收到通知，ViewTreeObsrver不能被实例化，可以调用，View.getViewTreeObserver()来获得</p>
</blockquote>
<blockquote>
<p>dispatchOnOreDraw():通知观察者绘制即将开始，如果其中的某个观察者返回true，那么绘制会取消，并且重新安排绘制，如果想在View Layout或View hierarchy还未依附到Window时，或者在View处于CONE状态时强制绘制，可以手动调用这个方法。<br>通过ViewTreeObserver添加绘制监听</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115229067.png" alt="image-20220806115229067"></p>
<p>注意，这里不是<code>getChildAt()</code>而是<code>mDependencySortedChildren.get()</code>，因为mDependencySortedChildren在这里是一个特殊的集合，因为CoordinatorLayout管理着多个子View，并且子View之间还存在依赖关系，所以还利用了有向无环图来记录View的依赖关系。只需理解原因即可，这里不用深究，否则会陷到坑里面去。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115313761.png" alt="image-20220806115313761"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115333029.png" alt="image-20220806115333029"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115712870.png" alt="image-20220806115712870"></p>
<p>Behavior在哪里被实例化？<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115344751.png" alt="image-20220806115344751"></p>
<p>如果自定义ViewGroup并且需要提供一些特殊的属性给子View，那么就需要重写LayoutParams</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115427736.png" alt="image-20220806115427736"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115502591.png" alt="image-20220806115444264"></p>
<p><code>HierarchyChangeListener</code>回调监听，当childView添加与删除时调用</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115502591.png" alt="image-20220806115502591"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115532076.png" alt="image-20220806115532076"></p>
<p>前面提到了mDependencySortedChildren，那么mDependencySortedChildren在哪初始化呢？</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115554255.png" alt="image-20220806115554255"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115611892.png" alt="image-20220806115611892"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115633713.png" alt="image-20220806115633713"></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><strong>效果展示</strong></p>
<p>这是利用Behavior实现的嵌套滑动效果，上滑时顶部会隐藏，往下滑时顶部又会回显出来</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_15_07_40_12.gif" alt="录制_2022_08_06_15_07_40_12"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SampleHeaderBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mOffsetTopAndBottom;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mLayoutTop;</span><br><span class="line">    public <span class="constructor">SampleHeaderBehavior()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="constructor">SampleHeaderBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span>&#123;</span><br><span class="line">        super(context,attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">LayoutChild(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull TextView <span class="params">child</span>, <span class="params">int</span> <span class="params">layoutDirection</span>)</span> &#123;</span><br><span class="line">        parent.on<span class="constructor">LayoutChild(<span class="params">child</span>,<span class="params">layoutDirection</span>)</span>;</span><br><span class="line">        mLayoutTop = child.get<span class="constructor">Top()</span>;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">StartNestedScroll(@NonNull CoordinatorLayout <span class="params">coordinatorLayout</span>, @NonNull TextView <span class="params">child</span>, @NonNull View <span class="params">directTargetChild</span>, @NonNull View <span class="params">target</span>, <span class="params">int</span> <span class="params">axes</span>, <span class="params">int</span> <span class="params">type</span>)</span> &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void on<span class="constructor">NestedPreScroll(@NonNull CoordinatorLayout <span class="params">coordinatorLayout</span>, @NonNull TextView <span class="params">child</span>, @NonNull View <span class="params">target</span>, <span class="params">int</span> <span class="params">dx</span>, <span class="params">int</span> <span class="params">dy</span>, @NonNull <span class="params">int</span>[] <span class="params">consumed</span>, <span class="params">int</span> <span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> consumedy = <span class="number">0</span>;<span class="comment">//记录消费的距离</span></span><br><span class="line">        <span class="built_in">int</span> offset = mOffsetTopAndBottom - dy;</span><br><span class="line">        <span class="comment">//因为offset是带方向的，这里获取到最大可滑动距离需要在前面添加负号</span></span><br><span class="line">        <span class="built_in">int</span> minOffset = -get<span class="constructor">ChildScrollRange(<span class="params">child</span>)</span>;</span><br><span class="line">        <span class="built_in">int</span> maxOffset = <span class="number">0</span>;</span><br><span class="line">        offset = offset&lt;minOffset? minOffset:(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(offset, maxOffset));</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">child</span>,<span class="params">offset</span>-(<span class="params">child</span>.<span class="params">getTop</span>()</span>-mLayoutTop));</span><br><span class="line">        consumedy = mOffsetTopAndBottom - offset;</span><br><span class="line">        <span class="comment">//将本次滑动到的位置记录下来</span></span><br><span class="line">        mOffsetTopAndBottom = offset;</span><br><span class="line">        consumed<span class="literal">[<span class="number">1</span>]</span> = consumedy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取childView最大可滑动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> get<span class="constructor">ChildScrollRange(View <span class="params">childView</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (childView==null)&#123;</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return childView.get<span class="constructor">Height()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> ScrollerBehavior extends CoordinatorLayout.Behavior&lt;RecyclerView&gt; &#123;</span><br><span class="line">    public <span class="constructor">ScrollerBehavior()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">ScrollerBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull RecyclerView <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof TextView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull RecyclerView <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">child</span>,<span class="params">dependency</span>.<span class="params">getBottom</span>()</span>-child.get<span class="constructor">Top()</span>);</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面demo其实是对前面提到的嵌套滑动方法的实践。而这个例子才是对依赖与被依赖组件关系的效果展示，红色方块是被依赖方，而“跟随兄弟”和变色兄弟都是依赖方，会根据红色方块的位置变化而变化。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_15_09_45_364.gif" alt="录制_2022_08_06_15_09_45_364"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DependedView extends View &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mLastX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mLastY;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mDragSlop;</span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, <span class="params">int</span> <span class="params">mDragSlop</span>)</span> &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.mDragSlop = mDragSlop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, @Nullable AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, @Nullable AttributeSet <span class="params">attrs</span>, <span class="params">int</span> <span class="params">defStyleAttr</span>)</span> &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        mDragSlop = <span class="module-access"><span class="module"><span class="identifier">ViewConfiguration</span>.</span></span>get(context).get<span class="constructor">ScaledTouchSlop()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> action = event.get<span class="constructor">Action()</span>;</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mLastX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                mLastY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="built_in">int</span> dx = (<span class="built_in">int</span>) (event.get<span class="constructor">X()</span> - mLastX);</span><br><span class="line">                <span class="built_in">int</span> dy = (<span class="built_in">int</span>) (event.get<span class="constructor">Y()</span> - mLastY);</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs(dx) &gt; mDragSlop<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs(dy) &gt; mDragSlop) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">this</span>, <span class="params">dy</span>)</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">LeftAndRight(<span class="params">this</span>, <span class="params">dx</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                mLastY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> BrotherChameleonBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ArgbEvaluator mArgbEvaluator = <span class="keyword">new</span> <span class="constructor">ArgbEvaluator()</span>;</span><br><span class="line">    public <span class="constructor">BrotherChameleonBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull View <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof DependedView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull View <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> color = (<span class="built_in">int</span>)mArgbEvaluator.evaluate(dependency.get<span class="constructor">Y()</span>/parent.get<span class="constructor">Height()</span>, Color.WHITE,Color.BLACK);</span><br><span class="line">        child.set<span class="constructor">BackgroundColor(<span class="params">color</span>)</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> BrotherFollowBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line">    public <span class="constructor">BrotherFollowBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(CoordinatorLayout <span class="params">parent</span>, View <span class="params">child</span>, View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof DependedView;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(CoordinatorLayout <span class="params">parent</span>, View <span class="params">child</span>, View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        child.set<span class="constructor">Y(<span class="params">dependency</span>.<span class="params">getBottom</span>()</span> + <span class="number">50</span>);</span><br><span class="line">        child.set<span class="constructor">X(<span class="params">dependency</span>.<span class="params">getX</span>()</span>);</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用好Behavior对我们做好看的UI效果有很大的帮助，毕竟NestedScrollParent和NestedScrollChild也只能实现两个组件之间的嵌套关系，而Behavior能够实现一对多的嵌套关系。这节内容主要是对CoordinatorLayout的介绍以及只是对自定义Behavior的浅尝试，后面小编将写一篇真正意义的自定义Behavior的Demo介绍与实现。</p>
<p><a href="https://github.com/gun-ctrl/CoordanatorLayout">代码链接</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
  </entry>
  <entry>
    <title>NestedScrollView嵌套滑动原理</title>
    <url>/2022/08/06/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="事件分发机制简介"><a href="#事件分发机制简介" class="headerlink" title="事件分发机制简介"></a>事件分发机制简介</h2><p>其实小编应该在前面准备一章关于Android的事件分发和处理机制的专题，因为时间原因和内容源码比较多吧(小编有强迫症，不想不贴源码)，不过还是因为小编懒，哈哈。这里就对事件分发机制做一个简单的回忆，大家感兴趣的可以去看看相关资料和源码，小编后面有空也会出一期。</p>
<p>这里介绍一位优秀博主的博客，大家可以看这篇文章对事件分发机制与滑动冲突、以及解决方案有个全面的了解：</p>
<p><a href="https://wiwiyiyi.com/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html">事件分发机制以及滑动冲突的处理</a></p>
<p>下面对事件分发与处理做一个简单总结</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806150250279.png" alt="image-20220806150250279"></p>
<p>关键的一点大家需要记住：事件的分发是由上层到底层，而事件的处理是由底层到上层。</p>
<ul>
<li>也就是说父View可以拦截触摸事件直接消费，而不传递给子View。</li>
<li>子View可以处理事件，也可以选择给父类消费。</li>
<li>ViewGroup既可以消费事件，也可以分发事件</li>
<li>View只能处理事件，也就是消费。</li>
</ul>
<h4 id="View滑动冲突"><a href="#View滑动冲突" class="headerlink" title="View滑动冲突"></a>View滑动冲突</h4><p>   1.外部滑动方向与内部滑动方向不一致</p>
<blockquote>
<p>解决方案：外部拦截法，当事件传递到父View时，父View需要处理此事件，就拦截，不处理此事件就不拦截</p>
</blockquote>
<ol start="2">
<li><p>外部滑动方向与内部滑动方向一致；</p>
<blockquote>
<p>内部拦截法，当事件传递到父View时，父View都传递给子View，如果子View需要处理此事件就消耗掉，否则就交给父View处理。但是这种方法和Android事件分发不一致，需要配合 requestDisallowInterceptTouchEvent 方法才能正常工作</p>
</blockquote>
</li>
<li><p>上面两种情况的嵌套。</p>
<blockquote>
<p>某个View一旦决定拦截，那么这一个事件序列都只能由它来处理，并且它的onInterceptTouchEvent不会再被调用<br>解决方案： 解决这种滑动冲突，可以用NestedScrollingParent 和 NestedScrollingChild 来解决</p>
</blockquote>
</li>
</ol>
<h2 id="分析NestedScrollView机制"><a href="#分析NestedScrollView机制" class="headerlink" title="分析NestedScrollView机制"></a>分析NestedScrollView机制</h2><blockquote>
<p>NestedScrollView和ScrollView类似，是一个支持滚动的控件。此外，它还同时支持作NestedScrollingParent或者NestedScrollingChild进行嵌套滚动操作。默认是启用嵌套滚动的</p>
</blockquote>
<p>首先介绍两个重要接口</p>
<p>1.NestedScrollingParent</p>
<p>当可滑动的ViewGroup充当父View时实现该接口</p>
<p>2.NestedScrollingChild</p>
<p>当可滑动的ViewGroup充当子View时实现该接口</p>
<blockquote>
<p>我们所熟知的RecyclerView就对上面两个接口都进行了实现，所以它才能完美的处理滑动与点击item之间的关系，同时RecyclerView还支持惯性滑动（快速滑-&gt;手指松开-&gt;滑动一段距离停下），这都是上面两个接口中封装的方法的功劳。小编后面展示的demo就比较拉了，没有实现惯性滑动效果，别问！问就是因为懒。</p>
</blockquote>
<h4 id="整个事件流程"><a href="#整个事件流程" class="headerlink" title="整个事件流程"></a>整个事件流程</h4><p>这张图还是很清晰的展示了从点击-&gt;滑动-&gt;松开的方法调用过程</p>
<p>NestedScrollingChildHelper、NestedScrollingParentHelper是Google提供的帮助类，其内部是去调用ViewCompat中的方法调用（xxxCompat都是兼容处理），也就是说很多操作都可以由helper帮我们完成，对于小编这种懒人还是很友好的。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806160049703.png" alt="image-20220806160049703"></p>
<p>下面对方法进行介绍：</p>
<ul>
<li><p><strong>onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type)</strong> 当用户手指按下的时候，你是否要处理这次操作。当你确定要处理这次操作的时候，返回true；如果返回false的时候，就不会去响应后面的回调事件了。你想怎么滑就怎么话，我都不做处理。这里的(axes)滚动方向很重要，可以通过此参数判断滚动方向！</p>
<ul>
<li><p>参数3：直接目标，相当于能滑动的控件</p>
</li>
<li><p>参数4：观察的View</p>
</li>
<li><p>参数5：这个可以简单理解为滚动方向</p>
<ul>
<li>ViewCompat#SCROLL_AXIS_HORIZONTAL 水平方向</li>
<li>ViewCompat#SCROLL_AXIS_VERTICAL 竖直方向</li>
</ul>
</li>
<li><p>参数6：这个参数是之后有的，如果你输入的类型不是TYPE_TOUCH那么就不会相应这个滚动</p>
</li>
</ul>
</li>
<li><p><strong>onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</strong> 当onStartNestedScroll准备处理这次滑动的时候(返回true的时候)，回调这个方法。可以在这个方法中做一些响应的准备工作！</p>
</li>
<li><p><strong>onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</strong> 当滚动开始执行的时候回调这个方法。</p>
<ul>
<li>参数4&#x2F;参数5：用户x&#x2F;y轴滚动的距离(注意这里是每一次都回调的啊！！！)</li>
<li>参数6：处理滚动的距离的参数，内部维护着输出距离，假设用户滑动了100px,child 做了90px的位移，你需要把consumed［1］的值改成90，这样coordinatorLayout就能知道只处理剩下的10px的滚动。其中consumed[0]代表x轴、consumed[1]代表y轴。可能你不理解这个问题，换个形象点的比喻，比如你开发某一个功能，但是你只会其中的90%那么怎么办呢？不能就不管了。好你找到了你的同事或者老大，让他去完成剩下的10%。这样问题就完美的解决了，是一个概念的！</li>
</ul>
</li>
<li><p><strong>onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type)</strong> 上面这个方法结束的时候，coordinatorLayout处理剩下的距离，比如还剩10px。但是coordinatorLayout发现滚动2px的时候就已经到头了。那么结束其滚动，调用该方法，并将coordinatorLayout处理剩下的像素数作为参<code>(dxUnconsumed、dyUnconsumed)</code>传过来，这里传过来的就是 8px。参数中还会有coordinatorLayout处理过的像素数（dxConsumed、dyConsumed）。老大开始处理剩下的距离了！这个方法主要处理一些越界后的滚动。还是不懂对吧！还拿你们老大做比喻：比如上面还剩 10%的工作，这时老大处理了2%后发现已经可以上线了，于是老大结束了工作，并将处理剩下的内容（dxUnconsumed、dyUnconsumed）纪录下来，告诉你。老大处理了的内容（dxConsumed、dyConsumed）也告诉了你。</p>
<ul>
<li>参数4&#x2F;参数5：当没有滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
<li>参数6&#x2F;参数7：当滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
</ul>
</li>
<li><p>onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, float velocityX, float velocityY) 当手指松开发生惯性动作之前调用，这里提供了响应的速度，你可以根据速度判断是否需要进行折叠等一系列的操作，你要确定响应这个方法的话，返回true。</p>
<ul>
<li>参数4&#x2F;参数5：代表相应的速度</li>
</ul>
</li>
<li><p>onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int type) 停止滚动的时候回调的方法。当你不去响应Fling的时候会直接回调这个方法。在这里可以做一些清理工作。或者其他的内容。</p>
</li>
</ul>
<p><strong>再来看看两个接口的源码</strong></p>
<p>1.NestedScrollingChild</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启用或禁用嵌套滚动的方法，设置为true，并且当前界面的View的层次结构是支持嵌套滚动的</span></span><br><span class="line"><span class="comment">    * (也就是需要NestedScrollingParent嵌套NestedScrollingChild)，才会触发嵌套滚动。</span></span><br><span class="line"><span class="comment">    * 一般这个方法内部都是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNestedScrollingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前View是否支持嵌套滑动。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNestedScrollingEnabled</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 表示view开始滚动了,一般是在ACTION_DOWN中调用，如果返回true则表示父布局支持嵌套滚动。</span></span><br><span class="line"><span class="comment">    * 一般也是直接代理给NestedScrollingChildHelper的同名方法即可。这个时候正常情况会触发Parent的onStartNestedScroll()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="type">int</span> axes)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一般是在事件结束比如ACTION_UP或者ACTION_CANCLE中调用,告诉父布局滚动结束。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前View是否有嵌套滑动的Parent。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View消费滚动距离之后。通过调用该方法，把剩下的滚动距离传给父布局。如果当前没有发生嵌套滚动，或者不支持嵌套滚动，调用该方法也没啥用。</span></span><br><span class="line"><span class="comment">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    * dxConsumed：被当前View消费了的水平方向滑动距离</span></span><br><span class="line"><span class="comment">    * dyConsumed：被当前View消费了的垂直方向滑动距离</span></span><br><span class="line"><span class="comment">    * dxUnconsumed：未被消费的水平滑动距离</span></span><br><span class="line"><span class="comment">    * dyUnconsumed：未被消费的垂直滑动距离</span></span><br><span class="line"><span class="comment">    * offsetInWindow：输出可选参数。如果不是null，该方法完成返回时，</span></span><br><span class="line"><span class="comment">    * 会将该视图从该操作之前到该操作完成之后的本地视图坐标中的偏移量封装进该参数中，offsetInWindow[0]水平方向，offsetInWindow[1]垂直方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true：表示滚动事件分发成功,fasle: 分发失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View消费滚动距离之前把滑动距离传给父布局。相当于把优先处理权交给Parent</span></span><br><span class="line"><span class="comment">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可。</span></span><br><span class="line"><span class="comment">	* dx：当前水平方向滑动的距离</span></span><br><span class="line"><span class="comment">	* dy：当前垂直方向滑动的距离</span></span><br><span class="line"><span class="comment">	* consumed：输出参数，会将Parent消费掉的距离封装进该参数consumed[0]代表水平方向，consumed[1]代表垂直方向</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> true：代表Parent消费了滚动距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@Nullable</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *将惯性滑动的速度分发给Parent。内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">	* velocityX：表示水平滑动速度</span></span><br><span class="line"><span class="comment">	* velocityY：垂直滑动速度</span></span><br><span class="line"><span class="comment">	* consumed：true：表示当前View消费了滑动事件，否则传入false</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> true：表示Parent处理了滑动事件</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View自己处理惯性滑动前，先将滑动事件分发给Parent,一般来说如果想自己处理惯性的滑动事件，</span></span><br><span class="line"><span class="comment">    * 就不应该调用该方法给Parent处理。如果给了Parent并且返回true，那表示Parent已经处理了，自己就不应该再做处理。</span></span><br><span class="line"><span class="comment">    * 返回false，代表Parent没有处理，但是不代表Parent后面就不用处理了</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true：表示Parent处理了滑动事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="type">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow,</span></span><br><span class="line"><span class="params">            <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@Nullable</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild3</span> <span class="keyword">extends</span> <span class="title class_">NestedScrollingChild2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow, <span class="meta">@ViewCompat</span>.NestedScrollType <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="type">int</span>[] consumed)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.NestedScrollingParent</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当NestedScrollingChild调用方法startNestedScroll()时,会调用该方法。主要就是通过返回值告诉系统是否需要对后续的滚动进行处理</span></span><br><span class="line"><span class="comment">    * child：该ViewParen的包含NestedScrollingChild的直接子View，如果只有一层嵌套，和target是同一个View</span></span><br><span class="line"><span class="comment">    * target：本次嵌套滚动的NestedScrollingChild</span></span><br><span class="line"><span class="comment">    * nestedScrollAxes：滚动方向</span></span><br><span class="line"><span class="comment">    * @return </span></span><br><span class="line"><span class="comment">    * true:表示我需要进行处理，后续的滚动会触发相应的回到</span></span><br><span class="line"><span class="comment">    * false: 我不需要处理，后面也就不会进行相应的回调了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//child和target的区别，如果是嵌套两层如:Parent包含一个LinearLayout，LinearLayout里面才是NestedScrollingChild类型的View。这个时候，</span></span><br><span class="line">    <span class="comment">//child指向LinearLayout，target指向NestedScrollingChild；如果Parent直接就包含了NestedScrollingChild，</span></span><br><span class="line">    <span class="comment">//这个时候target和child都指向NestedScrollingChild</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onStartNestedScroll</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果onStartNestedScroll()方法返回的是true的话,那么紧接着就会调用该方法.它是让嵌套滚动在开始滚动之前,</span></span><br><span class="line"><span class="comment">    * 让布局容器(viewGroup)或者它的父类执行一些配置的初始化的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScrollAccepted</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 停止滚动了,当子view调用stopNestedScroll()时会调用该方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onStopNestedScroll</span>(<span class="variable">@NonNull</span> View target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当子view调用dispatchNestedScroll()方法时,会调用该方法。也就是开始分发处理嵌套滑动了</span></span><br><span class="line"><span class="comment">    * dxConsumed：已经被target消费掉的水平方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dyConsumed：已经被target消费掉的垂直方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dxUnconsumed：未被tagert消费掉的水平方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dyUnconsumed：未被tagert消费掉的垂直方向的滑动距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当子view调用dispatchNestedPreScroll()方法是,会调用该方法。也就是在NestedScrollingChild在处理滑动之前，</span></span><br><span class="line"><span class="comment">    * 会先将机会给Parent处理。如果Parent想先消费部分滚动距离，将消费的距离放入consumed</span></span><br><span class="line"><span class="comment">    * dx：水平滑动距离</span></span><br><span class="line"><span class="comment">    * dy：处置滑动距离</span></span><br><span class="line"><span class="comment">    * consumed：表示Parent要消费的滚动距离,consumed[0]和consumed[1]分别表示父布局在x和y方向上消费的距离.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedPreScroll</span>(<span class="variable">@NonNull</span> View target, int dx, int dy, <span class="variable">@NonNull</span> int[] consumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 你可以捕获对内部NestedScrollingChild的fling事件</span></span><br><span class="line"><span class="comment">    * velocityX：水平方向的滑动速度</span></span><br><span class="line"><span class="comment">    * velocityY：垂直方向的滑动速度</span></span><br><span class="line"><span class="comment">    * consumed：是否被child消费了</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * true:则表示消费了滑动事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onNestedFling</span>(<span class="variable">@NonNull</span> View target, float velocityX, float velocityY, boolean consumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在惯性滑动距离处理之前，会调用该方法，同onNestedPreScroll()一样，也是给Parent优先处理的权利</span></span><br><span class="line"><span class="comment">    * target：本次嵌套滚动的NestedScrollingChild</span></span><br><span class="line"><span class="comment">    * velocityX：水平方向的滑动速度</span></span><br><span class="line"><span class="comment">    * velocityY：垂直方向的滑动速度</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * true：表示Parent要处理本次滑动事件，Child就不要处理了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onNestedPreFling</span>(<span class="variable">@NonNull</span> View target, float velocityX, float velocityY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回当前滑动的方向，一般直接通过NestedScrollingParentHelper.getNestedScrollAxes()返回即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @<span class="selector-tag">ScrollAxis</span></span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">getNestedScrollAxes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent2</span> <span class="selector-tag">extends</span> <span class="selector-tag">NestedScrollingParent</span> &#123;</span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onStartNestedScroll</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScrollAccepted</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onStopNestedScroll</span>(<span class="variable">@NonNull</span> View target, <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed, <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedPreScroll</span>(<span class="variable">@NonNull</span> View target, int dx, int dy, <span class="variable">@NonNull</span> int[] consumed,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent3</span> <span class="selector-tag">extends</span> <span class="selector-tag">NestedScrollingParent2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed, int dxUnconsumed,</span><br><span class="line">            int dyUnconsumed, <span class="variable">@ViewCompat</span>.NestedScrollType int type, <span class="variable">@NonNull</span> int[] consumed);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>在那之前再补一张较全的事件流程图，还包括传值的过程欧，结合demo代码看也不错。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806164857678.png" alt="image-20220806164857678"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806164945258.png" alt="image-20220806164945258"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806165039684.png" alt="image-20220806165039684"></p>
<p>效果演示</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_16_21_53_330.gif" alt="录制_2022_08_06_16_21_53_330"></p>
<p>这里就不贴大量代码了，展示一些主要代码，详情可见文章下方的全部代码</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806163510871.png" alt="image-20220806163510871"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806163541253.png" alt="image-20220806163541253"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要对NestedScrollView的嵌套滑动机制过程掌握，利用NestedScrollingParent、NestedScrollingChild这两个接口可以很轻松的实现自定义嵌套滑动机制，当然也可以直接通过继承自定义NestedScrollView实现一些炫酷的滑动、吸顶效果，这种效果在现在的电商平台还是很常见的。当然仅仅利用NestedScrollingParent、NestedScrollingChild实现嵌套还是有局限，只能一对一，要想实现一对多的嵌套滑动那就需要Behavior，下一章将会初步接触。</p>
<p><a href="https://github.com/gun-ctrl/NestedScrollViewTry">全部代码</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
  </entry>
  <entry>
    <title>RecyclerView的回收复用机制</title>
    <url>/2022/07/24/RecyclerView%E7%9A%84%E5%9B%9E%E6%94%B6%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章，小编介绍了RecyclerView的高级用法——自定义LayoutManager。今天，我们来从源码的角度深度剖析RecyclerView，主要是对RecyclerView的回收复用机制熟悉掌握。</p>
<h2 id="RecyclerView介绍"><a href="#RecyclerView介绍" class="headerlink" title="RecyclerView介绍"></a>RecyclerView介绍</h2><blockquote>
<p>RecyclerView可以说是项目必备的系统高级控件，相比于传统的ListVIew，RecyclerView最大的优势就是四级缓存机制，ListView是两级缓存机制（屏幕内可见、屏幕外）。</p>
</blockquote>
<h3 id="四级缓存机制"><a href="#四级缓存机制" class="headerlink" title="四级缓存机制"></a>四级缓存机制</h3><ul>
<li><p>mChangeScrap（主要与动画相关）与mAttachedScrap（一般这两算一级）</p>
<p>用来缓存还在屏幕内的ViewHolder</p>
</li>
<li><p>mCachedViews</p>
<p>用来缓存移除屏幕之外的ViewHolder</p>
</li>
<li><p>mViewCacheExtension</p>
<p>用户的自定义扩展缓存，需要用户自己管理View的创建和缓存</p>
</li>
<li><p>RecyclerViewPool</p>
<p>ViewHolder缓存池</p>
</li>
</ul>
<h3 id="回收复用的入口"><a href="#回收复用的入口" class="headerlink" title="回收复用的入口"></a>回收复用的入口</h3><p>上一章中自定义LayoutManager中有<code> detachAndScrapAttachedViews(recycler!!)</code>这样一个方法，用于回收ViewHolder。下面就来介绍一下RecyclerView的回收。</p>
<p>回收有两个入口，一是布局onLayout时，二是在fill填充itemVIew时</p>
<ul>
<li>onLayout</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220724172908391.png" alt="image-20220724172908391"></p>
<p>1.因为RecyclerView的具体onLayout是交给具体的LayoutManager来实现的，所以回收复用的具体操作是由LayoutManager来完成，在自定义LayoutManager时需考虑这一点，参考系统提供的LinearLayoutManager</p>
<p>2.上图的两个重心是LinearLayoutManager中回收入口的分叉和Recycler中的实际回收情况，而我们在自定义LayoutManager时，回收Holder只需要通过detachAndScrapAttachedViews这一个方法即可，具体是如何进行回收的我们不关心，但需要知道有哪几种，因为这对应了几种缓存，上面已经介绍了四级缓存。</p>
<p>3.缓存池与mCacheViews的关系：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144808720.png" alt="image-20220717144808720"></p>
<blockquote>
<p> <strong>注意：</strong>缓存池中保存的只是ViewHolder，没有数据，所以缓存池中的ViewHolder复用还需要绑定</p>
</blockquote>
<ul>
<li><p>fill</p>
<p>在fill中只考虑了recycleViewHolderInternal这种情况，滑动过程中会触发</p>
</li>
</ul>
<p><strong>回收重要源码截图</strong></p>
<blockquote>
<p>如果觉得上述回收流程图理解起来抽象的，可见结合部分源码截图理解。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717115957690.png" alt="image-20220717115957690"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717121349370.png" alt="image-20220717121349370"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717141954608.png" alt="image-20220717141954608"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717142707778.png"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717142831116.png" alt="image-20220717142831116"></p>
<blockquote>
<p>如果超过mCacheView最大值（2），就加入到缓存池</p>
<p>缓存到缓存池之后，就从mCacheView中移除</p>
<p>从“0”拿出，说明是先进先出的</p>
</blockquote>
<ul>
<li>否则，直接进缓存池  和上面一样都是调用<code>addViewHolderToRecycledViewPool</code></li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717143953794.png" alt="image-20220717143953794"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144255403.png" alt="image-20220717144255403"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144354585.png" alt="image-20220717144354585"></p>
<blockquote>
<p>ScrapData -&gt; ArrayList<ViewHolder></p>
<p>mScrap-&gt;SpareArray<ScrapData></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144443187.png" alt="image-20220717144443187"></p>
</blockquote>
<p><strong>recycler.scrapView()</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717153414420.png" alt="image-20220717153414420"></p>
<p><strong>ViewHolder的包装源码</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120045307.png" alt="image-20220717120045307"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120201306.png" alt="image-20220717120201306"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120910841.png" alt="image-20220717120910841"></p>
<h3 id="复用入口"><a href="#复用入口" class="headerlink" title="复用入口"></a>复用入口</h3><blockquote>
<p>复用的入口点同样也是两个，分别是布局时与滑动时。</p>
</blockquote>
<ul>
<li><p>onLayout</p>
<p>上一章中我们在自定义LayoutManager中就是重写的下面的<code>4.onLayoutChildren</code></p>
</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717165422042.png" alt="image-20220717165422042"></p>
<ul>
<li>onTouch</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220724174858215.png" alt="image-20220724174858215"></p>
<p>其实二者雷同，从fill入口开始，onLayout与onTouch几乎一样，只是第一张图用的时序图，绘制的比较详细。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们阅读源码了解原理机制，不用记住每个方法的入口、流程细节等，只需要记住大致过程，并理解重要部分。比如RecyclerView的四级缓存，以及回收复用的大致过程。</p>
<p>这章的几个重点：</p>
<p>1.从mAttachedScrap、mChangedScrap、mCachedViews中取出的holder不需要再绑定数据</p>
<p>2.从RecyclerPool取出的holder需要重新绑定数据</p>
<p>3.mAttachedScrap、mChangedScrap缓存的是屏幕看到的holder</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wiwiyiyi.com/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#%E5%9B%9B-%E6%80%BB%E7%BB%93">https://wiwiyiyi.com/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#%E5%9B%9B-%E6%80%BB%E7%BB%93</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView高级用法——吸顶效果</title>
    <url>/2022/07/19/RecycleView%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们对RecyclerView的使用不能仅仅停留在表面，可以探索一些高级的用法——自定义，不过要实现这些的前提是必须对RecycleView的源码流程有所了解。今天小编就略讲一下，主要是和今天的主体有关的内容。我们今天就来实现如下的吸顶效果。</p>
<h3 id="通过绘制实现RecyclerView的吸顶效果"><a href="#通过绘制实现RecyclerView的吸顶效果" class="headerlink" title="通过绘制实现RecyclerView的吸顶效果"></a>通过绘制实现RecyclerView的吸顶效果</h3><p>ItemDecoration</p>
<p>ItemDecoration允许应用给具体的View添加具体的图画或者layout的偏移，对于绘制View之间的分割线，视觉分组边界等等是非常有用的。</p>
<p>当我们调用addItemDecoration()方法添加decoration的时候，RecyclerView就会调用该类的onDraw方法区绘制分割线，也就是说：分割线是绘制出来的。</p>
<blockquote>
<p>RecyclerView.ItemDecoration，该类为抽象类，官方目前只提供了一个实现类DividerItemDecoration。</p>
<p>并且只有LinearLayoutManager能够使用</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220719205304144.png" alt="image-20220719205304144"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C.gif" alt="吸顶效果"></p>
<p>要实现这样的吸顶效果，首先，就需要了解一下RecyclerView.ItemDecoration的绘制流程。</p>
<p>1.onDraw</p>
<p>在绘制每个itemView之前绘制，上图中的每个跟着滑动的头部就是在此处绘制</p>
<p>2.onDrawOver</p>
<p>在绘制了每个ItemView之后绘制，上图中固定的顶部在此处绘制</p>
<p>3.getItemOffsets</p>
<p>设置偏移值，可以在绘制itemView时设置偏移值，其实上demo中的每个头部（红色区域）就是在绘制itemView预留了部分空间用于绘制头部。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220719210625576.png" alt="image-20220719210625576"></p>
<blockquote>
<p>也就是说绘制流程是：onDraw()-&gt;ItemView-&gt;onDrawOver</p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li>在Adapter中创建两个方法<ul>
<li>1.获取组名</li>
<li>2.判断是否是组的头部<ul>
<li>首先，position&#x3D;0一定是组的头部</li>
<li>其次，可以通过前后两次组名判断当前item是不是组的头部</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否是 组的第一个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isGroupHeader</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">String</span> currentName = <span class="built_in">getGroupName</span>(position);</span><br><span class="line">            <span class="type">String</span> preGroupName = <span class="built_in">getGroupName</span>(position<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (preGroupName.<span class="built_in">equals</span>(currentName))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getGroupName</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelList.<span class="built_in">get</span>(position).<span class="built_in">getGroupName</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义分割线</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void on<span class="constructor">Draw(@NonNull Canvas <span class="params">c</span>, @NonNull RecyclerView <span class="params">parent</span>, @NonNull RecyclerView.State <span class="params">state</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Draw(<span class="params">c</span>, <span class="params">parent</span>, <span class="params">state</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent.get<span class="constructor">Adapter()</span> instanceof ModelAdapter)&#123;</span><br><span class="line">            ModelAdapter adapter = (ModelAdapter) parent.get<span class="constructor">Adapter()</span>;</span><br><span class="line">            <span class="built_in">int</span> count  = parent.get<span class="constructor">ChildCount()</span>;</span><br><span class="line">            <span class="built_in">int</span> left = parent.get<span class="constructor">PaddingLeft()</span>;</span><br><span class="line">            <span class="built_in">int</span> right  = parent.get<span class="constructor">Width()</span> - parent.get<span class="constructor">PaddingRight()</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">//获取对应的View</span></span><br><span class="line">                View view = parent.get<span class="constructor">ChildAt(<span class="params">i</span>)</span>;</span><br><span class="line">                <span class="comment">//获取View的布局位置</span></span><br><span class="line">                <span class="built_in">int</span> position = parent.get<span class="constructor">ChildLayoutPosition(<span class="params">view</span>)</span>;</span><br><span class="line">                <span class="comment">//判断是不是头部</span></span><br><span class="line">                boolean isGroupHeader = adapter.is<span class="constructor">GroupHeader(<span class="params">position</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (isGroupHeader<span class="operator"> &amp;&amp; </span>view.get<span class="constructor">Top()</span> - groupHeaderHeight - parent.get<span class="constructor">PaddingTop()</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">view</span>.<span class="params">getTop</span>()</span>-groupHeaderHeight,right,view.get<span class="constructor">Top()</span>,headPaint);</span><br><span class="line">                    String groupName = adapter.get<span class="constructor">GroupName(<span class="params">position</span>)</span>;</span><br><span class="line">                    textPaint.get<span class="constructor">TextBounds(<span class="params">groupName</span>, 0, <span class="params">groupName</span>.<span class="params">length</span>()</span>, textRect);</span><br><span class="line">                    c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">view</span>.<span class="params">getTop</span>()</span>-groupHeaderHeight/<span class="number">2</span>+textRect.height<span class="literal">()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (view.get<span class="constructor">Top()</span> - groupHeaderHeight - parent.get<span class="constructor">PaddingTop()</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//分割线</span></span><br><span class="line">                    c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">view</span>.<span class="params">getTop</span>()</span>-<span class="number">4</span>,right,view.get<span class="constructor">Top()</span>,headPaint);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void on<span class="constructor">DrawOver(@NonNull Canvas <span class="params">c</span>, @NonNull RecyclerView <span class="params">parent</span>, @NonNull RecyclerView.State <span class="params">state</span>)</span> &#123;</span><br><span class="line">       super.on<span class="constructor">DrawOver(<span class="params">c</span>, <span class="params">parent</span>, <span class="params">state</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span> (parent.get<span class="constructor">Adapter()</span> instanceof ModelAdapter)&#123;</span><br><span class="line">           ModelAdapter adapter = (ModelAdapter) parent.get<span class="constructor">Adapter()</span>;</span><br><span class="line">           <span class="comment">//返回可见区域的第一个item的position</span></span><br><span class="line">           <span class="built_in">int</span> position = ((LinearLayoutManager)parent.get<span class="constructor">LayoutManager()</span>).find<span class="constructor">FirstVisibleItemPosition()</span>;</span><br><span class="line">           <span class="comment">//获取对应的position的View</span></span><br><span class="line">           View itemView = parent.find<span class="constructor">ViewHolderForAdapterPosition(<span class="params">position</span>)</span>.itemView;</span><br><span class="line">           <span class="built_in">int</span> left = parent.get<span class="constructor">PaddingLeft()</span>;</span><br><span class="line">           <span class="built_in">int</span> right = parent.get<span class="constructor">Width()</span> - parent.get<span class="constructor">PaddingRight()</span>;</span><br><span class="line">           <span class="built_in">int</span> top = parent.get<span class="constructor">PaddingTop()</span>;</span><br><span class="line">           <span class="comment">//当下一个是组的头部时</span></span><br><span class="line">           boolean isGroupHeader = adapter.is<span class="constructor">GroupHeader(<span class="params">position</span>+1)</span>;</span><br><span class="line">           String groupName = adapter.get<span class="constructor">GroupName(<span class="params">position</span>)</span>;</span><br><span class="line">           textPaint.get<span class="constructor">TextBounds(<span class="params">groupName</span>,0,<span class="params">groupName</span>.<span class="params">length</span>()</span>,textRect);</span><br><span class="line">           <span class="keyword">if</span> (isGroupHeader)&#123;</span><br><span class="line">               <span class="comment">//对顶部进行缩小效果，在视觉上是被下一个组的顶部推进去的</span></span><br><span class="line">               <span class="built_in">int</span> bottom = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(groupHeaderHeight,itemView.get<span class="constructor">Bottom()</span>-parent.get<span class="constructor">PaddingTop()</span>);</span><br><span class="line">               c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">bottom</span>,<span class="params">headPaint</span>)</span>;</span><br><span class="line">               c.clip<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">bottom</span>)</span>;</span><br><span class="line">               c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">top</span>+<span class="params">bottom</span>-<span class="params">groupHeaderHeight</span><span class="operator">/</span>2+<span class="params">textRect</span>.<span class="params">height</span>()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">groupHeaderHeight</span>,<span class="params">headPaint</span>)</span>;</span><br><span class="line">               c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">top</span>+<span class="params">groupHeaderHeight</span><span class="operator">/</span>2+<span class="params">textRect</span>.<span class="params">height</span>()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void getItemOffsets(@N<span class="keyword">on</span>Null Rect <span class="keyword">out</span>Rect, @N<span class="keyword">on</span>Null View view, @N<span class="keyword">on</span>Null RecyclerView <span class="keyword">parent</span>, @N<span class="keyword">on</span>Null RecyclerView.State <span class="keyword">state</span>) &#123;</span><br><span class="line">        super.getItemOffsets(<span class="keyword">out</span>Rect, view, <span class="keyword">parent</span>, <span class="keyword">state</span>);</span><br><span class="line">        if (<span class="keyword">parent</span>.getAdapter() instanceof ModelAdapter)&#123;</span><br><span class="line">            ModelAdapter adapter = (ModelAdapter) <span class="keyword">parent</span>.getAdapter();</span><br><span class="line">            int position = <span class="keyword">parent</span>.getChildAdapterPosition(view);</span><br><span class="line">            boolean isGroupHeader = adapter.isGroupHeader(position);</span><br><span class="line">            //判断itemView是不是头部</span><br><span class="line">            if (isGroupHeader)&#123;</span><br><span class="line">                //如果是头部，预留更大的地方</span><br><span class="line">                <span class="keyword">out</span>Rect.<span class="built_in">set</span>(<span class="number">0</span>,<span class="keyword">group</span>HeaderHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                <span class="keyword">out</span>Rect.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这部分的重点就是自定义分割线（ItemDecoration），弄清绘制顺序以及设置偏移值的作用就简单多了。当然，难点（也不是难点）就是弄清除尺寸参数,特别是尺寸变化引起的换组顶部推动效果。</p>
<p>其次就是特别注意有padding的情况，相信大家看出小编在这设置了顶部padding，有padding的时候需要注意尺寸。（不过有设置padding的情况很少）</p>
<p><a href="https://github.com/gun-ctrl/RecyclerViewPro">全部代码</a></p>
]]></content>
      <categories>
        <category>Android高级UI</category>
      </categories>
      <tags>
        <tag>高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>adb shell input text不能输入中文的解决方案</title>
    <url>/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>adb默认是不支持Unicode编码的，无法通过adb shell input text 命令输入中文到手机或者模拟器。</p>
<h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ul>
<li>1、安装ADBKeyBoard.apk文件(直接搜索就能找到)<br>打开手机或模拟器，adb install ADBKeyBoard.apk安装该输入法<br>在手机上直接安装也可</li>
<li>2、设置默认输入法<br>打开手机设置 -&gt; 点击语法与输入法 -&gt; 点击输入法管理 -&gt; 启用ADBKeyboard<br>重启手机后即可使用该输入法</li>
<li>3、输入adb命令测试中文输入<br>adb shell am broadcast -a ADB_INPUT_TEXT –es msg ‘这是一段adb中文测试’</li>
</ul>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>adb命令</title>
    <url>/2022/07/19/adb%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文为小编学习总结的一些adb的常用命令，可能一些命令有待验证，更多内容可以参考<a href="https://github.com/mzlogin/awesome-adb#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">adb用法大全</a></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="语法命令"><a href="#语法命令" class="headerlink" title="语法命令"></a>语法命令</h4><p>adb 命令的基本语法如下：<br>adb [ -d| -e| -s <sericalNumber>] <command><br>如果只有一个设备&#x2F;模拟器连接时，可以省略掉[ -d| -e| -s] <sericalNumber>] 这一部分，直接使用adb <command>。</p>
<h4 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h4><p>如果有多个设备&#x2F;模拟器,则需要为命令指定目标设备</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td align="left">指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td align="left">指定当前唯一运行的模拟器为目标命令</td>
</tr>
<tr>
<td>-s<serialNumber></td>
<td align="left">指定相应 serialNumber 号的设备&#x2F;模拟器为命令目标</td>
</tr>
<tr>
<td>###查看adb版本号</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="常用adb命令"><a href="#常用adb命令" class="headerlink" title="常用adb命令"></a>常用adb命令</h2><h3 id="查看adb版本号"><a href="#查看adb版本号" class="headerlink" title="查看adb版本号"></a>查看adb版本号</h3><p>adb version</p>
<h3 id="查看已连接设备"><a href="#查看已连接设备" class="headerlink" title="查看已连接设备"></a>查看已连接设备</h3><p>adb devices</p>
<h3 id="查看手机序列号"><a href="#查看手机序列号" class="headerlink" title="查看手机序列号"></a>查看手机序列号</h3><p>adb get-serialno<br>如返回127.0.0.1:7555</p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>adb logcat</p>
<blockquote>
<p>adb logcat -c 清除日志<br>adb logcat | grep “tag” 过滤日志 这里的tag就是你打印日志的时候需要设置的第一个参数TAG，通过TAG我们可以很轻松的过滤出我们想要的日志，轻松高效。</p>
</blockquote>
<h3 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h3><p>adb install [apk文件的路径]</p>
<blockquote>
<p>adb install douyin.apk</p>
</blockquote>
<ul>
<li>多个设备安装apk<br>adb -s [设备号] install [apk文件的路径]<blockquote>
<p>adb -s 127.0.0.1:7555 install douyin.apk</p>
</blockquote>
</li>
<li>如果apk已经存在，需要覆盖安装</li>
<li>adb install -r [apk文件的路径]<blockquote>
<p>adb install -r douyin.apk</p>
</blockquote>
</li>
</ul>
<p>adb install后面可以跟一些可选参数来控制安装APK的行为，可选参数及含义如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td align="left">将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td>
</tr>
<tr>
<td>-r</td>
<td align="left">允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td align="left">允许安装AndroidMainfest.xml里application指定<code>android:testOnly=&quot;true&quot;</code>的应用</td>
</tr>
<tr>
<td>-s</td>
<td align="left">应用安装到sdcard</td>
</tr>
<tr>
<td>-d</td>
<td align="left">允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td align="left">授予所有运行时权限</td>
</tr>
<tr>
<td>–abi abi-identifier</td>
<td align="left">为特定ABI强制安装apk，abi-identifier可以是armeabi-v7a、arm64-v8a、v86、x86_64 等</td>
</tr>
</tbody></table>
<h3 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h3><ul>
<li>普通卸载</li>
<li>adb uninstall [apk文件的路径]<blockquote>
<p>adb uninstall douyin.apk</p>
</blockquote>
</li>
<li>卸载但是保留数据</li>
<li>adb uninstall -k [apk文件的路径]<blockquote>
<p>adb uninstall -k douyin.apk</p>
</blockquote>
</li>
</ul>
<h3 id="获取手机root权限"><a href="#获取手机root权限" class="headerlink" title="获取手机root权限"></a>获取手机root权限</h3><p>adb root</p>
<h3 id="连接不稳定时需要挂载"><a href="#连接不稳定时需要挂载" class="headerlink" title="连接不稳定时需要挂载"></a>连接不稳定时需要挂载</h3><p>adb remount</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><ul>
<li>正常重启<br>adb reboot</li>
<li>重启手机到recovery<br>adb reboot recovery</li>
<li>重启到bootloader界面<br>adb reboot bootloader</li>
</ul>
<h3 id="关闭adb服务"><a href="#关闭adb服务" class="headerlink" title="关闭adb服务"></a>关闭adb服务</h3><p>adb kill -server</p>
<h3 id="启动adb服务"><a href="#启动adb服务" class="headerlink" title="启动adb服务"></a>启动adb服务</h3><p>adb start -server</p>
<h3 id="查看手机设备型号"><a href="#查看手机设备型号" class="headerlink" title="查看手机设备型号"></a>查看手机设备型号</h3><p>adb shell getprop ro.product.model<br>如返回MI 8</p>
<h3 id="查看设备的Android版本"><a href="#查看设备的Android版本" class="headerlink" title="查看设备的Android版本"></a>查看设备的Android版本</h3><p>adb shell getprop ro.build.version.release</p>
<h3 id="获取手机厂商名称"><a href="#获取手机厂商名称" class="headerlink" title="获取手机厂商名称"></a>获取手机厂商名称</h3><p>adb shell getprop ro.product.brand<br>如返回Xiaomi</p>
<h3 id="获取手机SDK版本"><a href="#获取手机SDK版本" class="headerlink" title="获取手机SDK版本"></a>获取手机SDK版本</h3><p>adb shell getprop ro.build.version.sdk</p>
<h3 id="查看手机分辨率"><a href="#查看手机分辨率" class="headerlink" title="查看手机分辨率"></a>查看手机分辨率</h3><p>adb shell wm size</p>
<h3 id="查看屏幕密度"><a href="#查看屏幕密度" class="headerlink" title="查看屏幕密度"></a>查看屏幕密度</h3><p>adb shell wm density<br><strong>修改屏幕密度</strong><br>adb shell wm density 160<br><strong>恢复原屏幕密度</strong><br>adb shell wm density reset</p>
<h3 id="查看手机的mac地址"><a href="#查看手机的mac地址" class="headerlink" title="查看手机的mac地址"></a>查看手机的mac地址</h3><p>adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address</p>
<h3 id="查看电池信息"><a href="#查看电池信息" class="headerlink" title="查看电池信息"></a>查看电池信息</h3><p>adb shell dumpsys battery</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>adb shell ps</p>
<h3 id="查看CPU使用情况"><a href="#查看CPU使用情况" class="headerlink" title="查看CPU使用情况"></a>查看CPU使用情况</h3><p>adb shell top</p>
<h3 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h3><p>adb shell cat &#x2F;proc&#x2F;cpuinfo</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>adb shell cat &#x2F;proc&#x2F;meminfo</p>
<h3 id="查看手机上所有安装的app包名"><a href="#查看手机上所有安装的app包名" class="headerlink" title="查看手机上所有安装的app包名"></a>查看手机上所有安装的app包名</h3><p>adb shell pm list packages</p>
<blockquote>
<p>adb shell pm list packages -s 查看所有系统app的包名<br>adb shell pm list packages -3 查看所有第三方app的包名<br>adb shell pm list packages | grep [包名] 使用grep筛选所有满足要求的app包名</p>
</blockquote>
<h3 id="清除应用数据"><a href="#清除应用数据" class="headerlink" title="清除应用数据"></a>清除应用数据</h3><p>adb shell pm clear [<packagename>]</p>
<blockquote>
<p>当你只是想要清除一个apk的某些数据来复现某些操作的时候，这个命令就显得额外重要。它可以避免我们重装apk来完成这个操作。</p>
</blockquote>
<h3 id="获取某个应用包名的启动入口"><a href="#获取某个应用包名的启动入口" class="headerlink" title="获取某个应用包名的启动入口"></a>获取某个应用包名的启动入口</h3><ul>
<li>adb shell dumpsys package com.ss.android.ugc.aweme|findstr activity</li>
<li>com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity 这个就是抖音的入口<blockquote>
<p>adb shell dumpsys package com.ss.android29111 com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity</p>
</blockquote>
</li>
</ul>
<h3 id="屏幕截屏"><a href="#屏幕截屏" class="headerlink" title="屏幕截屏"></a>屏幕截屏</h3><p>adb shell screencap [保存路径]</p>
<blockquote>
<p>adb shell screencap &#x2F;sdcard&#x2F;screen.png</p>
</blockquote>
<h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><p>adb shell screenrecord [保存路径]</p>
<p>也可以使用（adb版本太老的话，需要更新adb）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">exec</span><span class="operator">-</span><span class="keyword">out</span> screencap  <span class="operator">&gt;</span> sc.png</span><br></pre></td></tr></table></figure>

<h3 id="上传文件到手机"><a href="#上传文件到手机" class="headerlink" title="上传文件到手机"></a>上传文件到手机</h3><p>adb push [电脑文件路径] [手机文件保存路径]</p>
<blockquote>
<p>adb push douyin.apk sdcard&#x2F;douyin.apk</p>
</blockquote>
<h3 id="从手机端下载文件"><a href="#从手机端下载文件" class="headerlink" title="从手机端下载文件"></a>从手机端下载文件</h3><p>adb pull [手机上文件路径]<br><strong>注意：</strong>此时没有指定上传到电脑的路径，会默认上传到adb程序所在的路径</p>
<blockquote>
<p>adb pull sdcard&#x2F;douyin.apk</p>
</blockquote>
<p>指定上传路径：adb pull [手机上文件的路径] [电脑文件的路径]</p>
<blockquote>
<p>adb pull &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;app&#x2F;txt.mp4 D:&#x2F;ADB&#x2F;tet.mp4</p>
</blockquote>
<h3 id="模拟屏幕点击事件"><a href="#模拟屏幕点击事件" class="headerlink" title="模拟屏幕点击事件"></a>模拟屏幕点击事件</h3><p>adb shell input tap x坐标轴 y坐标轴</p>
<blockquote>
<p>adb shell input tap 500 1450</p>
</blockquote>
<h3 id="模拟手势滑动事件"><a href="#模拟手势滑动事件" class="headerlink" title="模拟手势滑动事件"></a>模拟手势滑动事件</h3><p>adb shell input swipe 开始x轴 开始y轴 结束x轴 结束y轴 过程持续时间</p>
<blockquote>
<p>adb shell input swipe 100 500 100 1450 100</p>
</blockquote>
<h3 id="模拟点击键盘按钮"><a href="#模拟点击键盘按钮" class="headerlink" title="模拟点击键盘按钮"></a>模拟点击键盘按钮</h3><p>adb shell input keyevent [key值]</p>
<blockquote>
<p>adb shell input keyevent 25</p>
</blockquote>
<p>一些常用的keyevent键值信息</p>
<table>
<thead>
<tr>
<th>keyevent</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td align="left">Home键</td>
</tr>
<tr>
<td>5</td>
<td align="left">拨号键</td>
</tr>
<tr>
<td>6</td>
<td align="left">挂机键</td>
</tr>
<tr>
<td>19</td>
<td align="left">向上</td>
</tr>
<tr>
<td>20</td>
<td align="left">向下</td>
</tr>
<tr>
<td>21</td>
<td align="left">向左</td>
</tr>
<tr>
<td>22</td>
<td align="left">向右</td>
</tr>
<tr>
<td>24</td>
<td align="left">音量加</td>
</tr>
<tr>
<td>25</td>
<td align="left">音量减</td>
</tr>
<tr>
<td>26</td>
<td align="left">电源</td>
</tr>
<tr>
<td>27</td>
<td align="left">拍照键</td>
</tr>
<tr>
<td>66</td>
<td align="left">回车键</td>
</tr>
<tr>
<td>67</td>
<td align="left">退格键</td>
</tr>
<tr>
<td>82</td>
<td align="left">菜单键</td>
</tr>
<tr>
<td>83</td>
<td align="left">通知键</td>
</tr>
<tr>
<td>84</td>
<td align="left">搜索键</td>
</tr>
<tr>
<td>92</td>
<td align="left">向上翻页</td>
</tr>
<tr>
<td>93</td>
<td align="left">向下翻页</td>
</tr>
<tr>
<td>111</td>
<td align="left">esc键</td>
</tr>
<tr>
<td>112</td>
<td align="left">删除键</td>
</tr>
<tr>
<td>115</td>
<td align="left">大写锁定键</td>
</tr>
<tr>
<td>122</td>
<td align="left">光标移动到开始键</td>
</tr>
<tr>
<td>123</td>
<td align="left">光标移动到末尾键</td>
</tr>
<tr>
<td>143</td>
<td align="left">小键盘锁</td>
</tr>
<tr>
<td>168</td>
<td align="left">放大键</td>
</tr>
<tr>
<td>169</td>
<td align="left">缩小键</td>
</tr>
</tbody></table>
<h3 id="向屏幕输入一些信息"><a href="#向屏幕输入一些信息" class="headerlink" title="向屏幕输入一些信息"></a>向屏幕输入一些信息</h3><ul>
<li>db shell input text [字符串信息]</li>
<li>%s是空格<blockquote>
<p>db shell input text “insert%stext%shere”</p>
</blockquote>
</li>
</ul>
<h3 id="查看前台Activity"><a href="#查看前台Activity" class="headerlink" title="查看前台Activity"></a>查看前台Activity</h3><p>同时小编也是通过这种方式获取到应用包的入口<br>adb shell dumpsys activity activities | findstr mResumedActivity<br>获取到了QQ的启动入口<br><img src="https://upload-images.jianshu.io/upload_images/20123021-1584e1eac4dde441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="启动某个app"><a href="#启动某个app" class="headerlink" title="启动某个app"></a>启动某个app</h3><p>adb shell am start -n [包名]&#x2F;[启动入口]</p>
<blockquote>
<p>adb shel am start -n com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity<br>Strating:Intent{cmp&#x3D;com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity}</p>
</blockquote>
<p>启动qq</p>
<blockquote>
<p>adb shell am start -n com.tencent.mobileqq&#x2F;.activity.SplashActivity</p>
</blockquote>
<p>启动有道词典<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-307c3a0c81650606.png" alt="image.png"></p>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>adb shell am broadcast -a “broadcastactionfilter”</p>
<blockquote>
<p>adb shell am broadcast -a “broadcastactionfilter”</p>
</blockquote>
<h3 id="使用自带浏览器打开网页"><a href="#使用自带浏览器打开网页" class="headerlink" title="使用自带浏览器打开网页"></a>使用自带浏览器打开网页</h3><p>adb shell am start -a [浏览器包名] -d [网址]</p>
<blockquote>
<p>adb shell am start -a “android.intent.action.VIEW” -d <a href="https://www.google.com/">https://www.google.com</a></p>
</blockquote>
<h3 id="获取手机内部存储信息"><a href="#获取手机内部存储信息" class="headerlink" title="获取手机内部存储信息"></a>获取手机内部存储信息</h3><p>adb shell df &#x2F;data</p>
<h2 id="关于ADB-IDEA"><a href="#关于ADB-IDEA" class="headerlink" title="关于ADB IDEA"></a>关于ADB IDEA</h2><p>AS插件ADB IDEA，装了这款插件可以直接在AS中快速操作一些ADB命令</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>1、双击shift -&gt; 点击action -&gt;搜索adb<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-5f962d67d5267c67.png" alt="image.png"></p>
<p>2、Ctrl + Shift + A，快捷键直接调用<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-0cb20333cd5ab9ca.png" alt="image.png"></p>
<h2 id="一些琐碎小问题"><a href="#一些琐碎小问题" class="headerlink" title="一些琐碎小问题"></a>一些琐碎小问题</h2><h4 id="不知应用包的入口Activity如何启动应用包"><a href="#不知应用包的入口Activity如何启动应用包" class="headerlink" title="不知应用包的入口Activity如何启动应用包"></a>不知应用包的入口Activity如何启动应用包</h4><p>1.通过category</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell monkey -<span class="selector-tag">p</span> &lt;packagename&gt; -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><a href="https://www.jianshu.com/p/150139c8295a">adb获取应用包入口的方案</a></li>
</ol>
<h4 id="adb-shell-input-text无法响应中文输入的问题"><a href="#adb-shell-input-text无法响应中文输入的问题" class="headerlink" title="adb shell input text无法响应中文输入的问题"></a>adb shell input text无法响应中文输入的问题</h4><p><a href="http://banmaman.com/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">adb shell input text不能输入中文的解决方案</a></p>
<h2 id="adb部分总结"><a href="#adb部分总结" class="headerlink" title="adb部分总结"></a>adb部分总结</h2><p><a href="https://www.jianshu.com/p/f6fa6759e747">adb小结</a></p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>括号问题</title>
    <url>/2022/07/13/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n&#x3D;3，解集为：</p>
<p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p>
<p>数据范围：0&lt;&#x3D;n&lt;&#x3D;10</p>
<p>要求：空间复杂度O(n)，时间复杂度O(2^n)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote>
<p>输入：1</p>
<p>返回值：[“()”]</p>
</blockquote>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><blockquote>
<p>输入：2</p>
<p>返回值：[“(())”，”()()”]</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相当于一共n个左括号和n个右括号，可以给我们使用，我们需要依次组装这些括号。每当我们使用一个左括号之后，就剩下n-1个左括号和n个右括号给我们使用，结果拼在使用的左括号之后就行了，因此后者就是一个子问题，可以使用递归：</p>
<ul>
<li>终止条件：左右括号都使用了n个，将结果加入数组。</li>
<li>返回值：每一级向上一级返回后续组装后的字符串，即子问题中搭配出来的括号序列。</li>
<li>本级任务：每一级就是保证左括号还有剩余的情况下，使用一次左括号进入子问题，或者右括号还有剩余且右括号使用次数少于左括号的情况下使用一次右括号进入子问题。</li>
<li><strong>注意：</strong>我们需要保证左括号出现的次数比右括号多时我们再使用右括号就一定能保证括号合法了，因此每次需要检查左括号和右括号的使用次数。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @return string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span>(<span class="type">int</span> left,<span class="type">int</span> right,<span class="built_in">String</span> temp,<span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; res,<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="comment">//左右括号都用完了，就加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(left==n&amp;&amp;right==n)&#123;</span><br><span class="line">            res.<span class="property">add</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;n)&#123;</span><br><span class="line">            <span class="title function_">recursion</span>(left+<span class="number">1</span>,right,temp + <span class="string">&quot;（&quot;</span>,res,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次有括号</span></span><br><span class="line">        <span class="keyword">if</span>(right&lt;n&amp;&amp;right&lt;left)&#123;</span><br><span class="line">            <span class="title function_">recursion</span>(left,right+<span class="number">1</span>,temp + <span class="string">&quot;）&quot;</span>,res,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; <span class="title function_">generateParenthesis</span> (<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; res = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="title function_">recursion</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,res,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>adb小结</title>
    <url>/2022/07/26/adb%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><a href="http://banmaman.com/2022/07/19/adb%E5%91%BD%E4%BB%A4/">adb常用命令</a></p>
<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用am<command>命令，常用的<command>如下</p>
<table>
<thead>
<tr>
<th>command</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td>start [options] <INTENT></td>
<td align="left">启动 <INTENT> 指定的 Activity</td>
</tr>
<tr>
<td>startservice [options] <INTENT></td>
<td align="left">启动 <INTENT> 指定的 Service</td>
</tr>
<tr>
<td>broadcast [options] <INTENT></td>
<td align="left">发送 <INTENT> 指定的广播</td>
</tr>
<tr>
<td>force-stop <packagename></td>
<td align="left">停止 <packagename> 相关的进程</td>
</tr>
<tr>
<td><INTENT> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</td>
<td align="left"></td>
</tr>
<tr>
<td>用于决定intent对象的选项如下：</td>
<td align="left"></td>
</tr>
<tr>
<td>参数</td>
<td align="left">含义</td>
</tr>
<tr>
<td>—-</td>
<td align="left">:—-</td>
</tr>
<tr>
<td>-a <ACTION></td>
<td align="left">指定 action，比如 android.intent.action.VIEW</td>
</tr>
<tr>
<td>-c <CATEGORY></td>
<td align="left">指定 category，比如 android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>-n <COMPONENT></td>
<td align="left">指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app&#x2F;.ExampleActivity</td>
</tr>
</tbody></table>
<p><INTENT> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>–esn <EXTRA_KEY></td>
<td align="left">null 值（只有 key 名）</td>
</tr>
<tr>
<td>–es <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE></td>
<td align="left">string 值</td>
</tr>
<tr>
<td>–ez <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE></td>
<td align="left">boolean 值</td>
</tr>
<tr>
<td>–ei <EXTRA_KEY> <EXTRA_INT_VALUE></td>
<td align="left">integer 值</td>
</tr>
<tr>
<td>–el <EXTRA_KEY> <EXTRA_LONG_VALUE></td>
<td align="left">long 值</td>
</tr>
<tr>
<td>–ef <EXTRA_KEY> <EXTRA_FLOAT_VALUE></td>
<td align="left">float 值</td>
</tr>
<tr>
<td>–eu <EXTRA_KEY> <EXTRA_URI_VALUE></td>
<td align="left">URI</td>
</tr>
<tr>
<td>–ecn <EXTRA_KEY> <EXTRA_COMPONENT_NAME_VALUE></td>
<td align="left">component name</td>
</tr>
<tr>
<td>–eia <EXTRA_KEY> <EXTRA_INT_VALUE>[,&lt;EXTRA_INT_VALUE…]</td>
<td align="left">integer 数组</td>
</tr>
<tr>
<td>–ela <EXTRA_KEY> <EXTRA_LONG_VALUE>[,&lt;EXTRA_LONG_VALUE…]</td>
<td align="left">long 数组</td>
</tr>
</tbody></table>
<h3 id="启动应用-x2F-调起Activity"><a href="#启动应用-x2F-调起Activity" class="headerlink" title="启动应用&#x2F;调起Activity"></a>启动应用&#x2F;调起Activity</h3><h4 id="指定Activity名称启动"><a href="#指定Activity名称启动" class="headerlink" title="指定Activity名称启动"></a>指定Activity名称启动</h4><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> start [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<p>调起微信并传给它 string 数据键值对 <code>toast - hello, world</code>。<br><img src="https://upload-images.jianshu.io/upload_images/20123021-e42736fb5ede5c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="不指定Activity名称启动-启动主Activity"><a href="#不指定Activity名称启动-启动主Activity" class="headerlink" title="不指定Activity名称启动(启动主Activity)"></a>不指定Activity名称启动(启动主Activity)</h4><p>命令格式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell monkey -<span class="selector-tag">p</span> &lt;packagename&gt; -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>启动QQ<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-a315569b2b8ab380.png" alt="image.png"></p>
<h3 id="调起Service"><a href="#调起Service" class="headerlink" title="调起Service"></a>调起Service</h3><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> startservice [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如：<br>调起微信的某Service</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com<span class="selector-class">.tencent</span>.mm/<span class="selector-class">.plugin</span><span class="selector-class">.accountsync</span><span class="selector-class">.model</span>.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>
<p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> startservice -n <span class="keyword">com</span>.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure>
<h3 id="停止Service"><a href="#停止Service" class="headerlink" title="停止Service"></a>停止Service</h3><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> stopservice [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> broadcast [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以向所有组件广播，也可以向指定组件广播<br>例如，向所有组件广播：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -<span class="selector-tag">a</span> android<span class="selector-class">.intent</span><span class="selector-class">.action</span>.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>
<p>又例如，只向<code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code>广播</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -<span class="selector-tag">a</span> android<span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.BOOT_COMPLETED</span> -n org<span class="selector-class">.mazhuang</span>.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。<br>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：<br>（均可使用adb触发）</p>
<table>
<thead>
<tr>
<th>action</th>
<th align="left">触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td align="left">网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td align="left">屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td align="left">屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td align="left">电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td align="left">电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td align="left">设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td align="left">存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td align="left">存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td align="left">安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td align="left">WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td align="left">WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td align="left">电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td align="left">系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td align="left">外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td align="left">外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td align="left">系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td align="left">系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td align="left">插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td align="left">卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td align="left">挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td align="left">省电模式开启</td>
</tr>
</tbody></table>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> force-<span class="keyword">stop</span> <span class="symbol">&lt;packagename&gt;</span></span><br></pre></td></tr></table></figure>
<p>命令示例：<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f509618cec978dc1.png" alt="image.png"></p>
<h3 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span>  <span class="keyword">am</span> send-trim-memory <span class="symbol">&lt;pid&gt;</span> <span class="symbol">&lt;level&gt;</span></span><br></pre></td></tr></table></figure>
<p>pid: 进程 ID level: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE<br>命令示例：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> am send-<span class="keyword">trim</span>-<span class="keyword">memory</span> 12345 RUNNING_LOW</span><br></pre></td></tr></table></figure>
<p>表示向 pid&#x3D;12345 的进程，发出 level&#x3D;RUNNING_LOW 的收紧内存命令。 </p>
<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。<br>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm size <span class="number">480</span>x1024</span><br></pre></td></tr></table></figure>
<p>表示将分辨率修改为 480px * 1024px。<br>恢复：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm density <span class="number">160</span></span><br></pre></td></tr></table></figure>
<p>表示将屏幕密度修改为 160dpi。<br>恢复：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> wm density reset</span></span><br></pre></td></tr></table></figure>
<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm overscan <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。<br>恢复：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> wm overscan reset</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭USB调试"><a href="#关闭USB调试" class="headerlink" title="关闭USB调试"></a>关闭USB调试</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> adb_enabled <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>恢复：<br>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。<br>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="允许-x2F-禁止访问非-SDK-API："><a href="#允许-x2F-禁止访问非-SDK-API：" class="headerlink" title="允许&#x2F;禁止访问非 SDK API："></a>允许&#x2F;禁止访问非 SDK API：</h3><p>不需要设备获得Root权限。<br>允许访问非 SDK API：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> hidden_api_policy_pre_p_apps <span class="number">1</span></span><br><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> hidden_api_policy_p_apps <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>禁止访问非 SDK API</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">delete</span> <span class="built_in">global</span> hidden_api_policy_pre_p_apps</span><br><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">delete</span> <span class="built_in">global</span> hidden_api_policy_p_apps</span><br></pre></td></tr></table></figure>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="left">禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td align="left">仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td align="left">禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td align="left">禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p><strong>注：</strong>未指定路径则，默认为adb所在的文件夹<br>截图保存到电脑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">exec</span><span class="operator">-</span><span class="keyword">out</span> screencap <span class="operator">-</span>p <span class="operator">&gt;</span> sc.png</span><br></pre></td></tr></table></figure>
<p>如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：<br>先截图保存到设备里：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p <span class="regexp">/sdcard/</span>sc.png</span><br></pre></td></tr></table></figure>
<p>然后将 png 文件导出到电脑：<br>adb pull &#x2F;sdcard&#x2F;sc.png<br>可以使用<code>adb shell screencap -h</code> 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td align="left">指定保存文件为 png 格式（如果指定文件后缀png，则可省略）</td>
</tr>
<tr>
<td>-d display-id</td>
<td align="left">指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以mp4格式保存到 &#x2F;sdcard：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord <span class="regexp">/sdcard/</span>filename.mp4</span><br></pre></td></tr></table></figure>
<p>需要停止时按 <code>Ctrl-C</code>，默认录制时间和最长录制时间都是 180 秒。<br>如果需要导出到电脑：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb pull <span class="regexp">/sdcard/</span>filename.mp4</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td align="left">视频的尺寸，比如 1280x720，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td align="left">视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td align="left">录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td align="left">输出更多信息。</td>
</tr>
</tbody></table>
<h3 id="开启-x2F-关闭wifi"><a href="#开启-x2F-关闭wifi" class="headerlink" title="开启&#x2F;关闭wifi"></a>开启&#x2F;关闭wifi</h3><p>开启</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> svc wifi <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure>
<p>关闭</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> svc wifi <span class="built_in">disable</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用Monkey进行压力测试"><a href="#使用Monkey进行压力测试" class="headerlink" title="使用Monkey进行压力测试"></a>使用Monkey进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。<br>简单用法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> monkey -<span class="keyword">p</span> <span class="symbol">&lt;packagename&gt;</span> -v <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。<br>更多内容可见<a href="https://developer.android.google.cn/studio/test/monkey.html">monkey官网</a></p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>按Z字形顺序打印二叉树</title>
    <url>/2022/07/17/%E6%8C%89Z%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br>数据范围：0≤n≤1500,树上每个节点的val满足∣val∣≤1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717104011278.png" alt="image-20220717104011278"></p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote>
<p>输入：{1,2,3,#,#,4,5}<br>输出： [[1],[3,2],[4,5]]<br>说明：如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这其实就是一个升级版的层序遍历.<br>观察其特点,无非就是奇数层和偶数层的输出顺序不一样. 这样就有了初步的解题思路,设置标识符flag(可以为整数型,也可以为boolean类型,整数类型无非就是对奇偶数的判断).<br>其余的思路就是层序遍历的思路,在每遍历新的一层之前,改变flag的值!flag(这里以boolean类型为例),然后就是利用Collections.reverse(list)对链表进行翻转.<br>详情可看代码</p>
<blockquote>
<p>这里,小编再提一下我初次遇到这道题的思路,前面的几乎一样,就是在实现链表反转这里,小编不熟悉Java库,没想到还有Colection.reverse这个方法可以用.<br>所以,小编在想反转的时候首先就想到了咱们的栈,也就是根据flag的值判断,从队列出来的值是否需要进一次栈实现反转</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        temp.offer(head);</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> temp.size();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">                p = temp.poll();</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    temp.offer(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    temp.offer(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(p.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次是小编完善Hexo搭建后的第一篇博客，前面的都是在没完全搭建好的时候测试发送的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>京东淘宝首页二级联动</title>
    <url>/2022/07/18/%E4%BA%AC%E4%B8%9C%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>说明：</strong>这篇文章主要用于作者临时观看，因为涉及版权问题，所以短时间内会删除</p>
<h2 id="京东淘宝首页二级联动"><a href="#京东淘宝首页二级联动" class="headerlink" title="京东淘宝首页二级联动"></a>京东淘宝首页二级联动</h2><h3 id="单点触摸与多点触摸"><a href="#单点触摸与多点触摸" class="headerlink" title="单点触摸与多点触摸"></a>单点触摸与多点触摸</h3><p>####单点触摸</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212127652.png" alt="image-20220718212127652"></p>
<p>####多点触摸</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212142549.png" alt="image-20220718212142549"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212203113.png" alt="image-20220718212203113"></p>
<blockquote>
<p>面试题</p>
<p>一个move事件 中间有多少个手指的信息-&gt;有多少个手指就有多少个手指信息-&gt;最多32个</p>
</blockquote>
<h3 id="Touch事件源码"><a href="#Touch事件源码" class="headerlink" title="Touch事件源码"></a>Touch事件源码</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212217242.png" alt="image-20220718212217242"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212232559.png" alt="image-20220718212232559"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212254074.png" alt="image-20220718212254074"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212316235.png" alt="image-20220718212316235"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212335895.png" alt="image-20220718212335895"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212349700.png" alt="image-20220718212349700"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212414454.png" alt="image-20220718212414454"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212432841.png" alt="image-20220718212432841"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212452115.png" alt="image-20220718212452115"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212515213.png" alt="image-20220718212515213"></p>
<p>上述的disallowIntercept及相关内容就是所谓的“尚方宝剑”</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212536424.png" alt="image-20220718212536424"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212555410.png" alt="image-20220718212555410"></p>
<p> <img src="C:\Users\15786\AppData\Roaming\Typora\typora-user-images\image-20220718212609465.png" alt="image-20220718212609465"></p>
<h3 id="嵌套滑动"><a href="#嵌套滑动" class="headerlink" title="嵌套滑动"></a>嵌套滑动</h3><blockquote>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212649556.png" alt="image-20220718212649556"></p>
</blockquote>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212704210.png" alt="image-20220718212704210"></p>
<p>并且从上面可以看出NestedScrollView既可以做“父亲”，也可以做“孩子”</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212718655.png" alt="image-20220718212718655"></p>
<p>“孩子”有三个版本</p>
<p>三个版本之间是的关系  同样“父亲”也是一样</p>
<blockquote>
<p>版本2与版本1相比  增加了type 如惯性滑动效果</p>
</blockquote>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212737829.png" alt="image-20220718212737829"></p>
<h4 id="吸顶效果"><a href="#吸顶效果" class="headerlink" title="吸顶效果"></a>吸顶效果</h4><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212758009.png" alt="image-20220718212758009"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212818443.png" alt="image-20220718212818443"></p>
<p>onFinishInflate()中获取第一个孩子的第二个孩子，从下图可以看出也就是是第二个LinearLayout</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212839006.png" alt="image-20220718212839006"></p>
<h4 id="继续嵌套滑动"><a href="#继续嵌套滑动" class="headerlink" title="继续嵌套滑动"></a>继续嵌套滑动</h4><p>嵌套滑动-&gt;是由孩子主动的   触发的</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212906775.png" alt="image-20220718212906775"></p>
<p>google为了方便我们处理嵌套滑动，所以提供了这个帮助类 -&gt; getScrollingChildHelper()</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212928635.png" alt="image-20220718212928635"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212942972.png" alt="image-20220718212942972"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213001121.png" alt="image-20220718213001121"></p>
<p>while(p!&#x3D;null)一直找，直到找到支持嵌套滑动</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213017801.png" alt="image-20220718213017801"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213043191.png" alt="image-20220718213043191"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213058717.png" alt="image-20220718213058717"></p>
<p>所以它没有滑，“父亲”划不动的时候，它(NestedScrollView)才动</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213122243.png" alt="image-20220718213122243"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213138627.png" alt="image-20220718213138627"></p>
<p>问题描述：需求是整个页面滑动，当父View滑不动的时候，子View才动。问题出现的原因就是上面的文字描述，要想解决</p>
<p>问题的解决：重写onNestedPreScroll()方法，做一些设置，如果自己还能滑，那么就自己滑，并且需要记录一下（consumed[1]，0记录的x，1记录的y）</p>
<ul>
<li><p>注意：NetestScrollLayout是自定义继承NetestScrollView的</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213208543.png" alt="image-20220718213208543"></p>
</li>
</ul>
<h3 id="惯性滑动"><a href="#惯性滑动" class="headerlink" title="惯性滑动"></a>惯性滑动</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213227462.png" alt="image-20220718213227462"></p>
<p>记录下速度 velocityY</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213246067.png" alt="image-20220718213246067"></p>
<blockquote>
<ul>
<li>1、记下来速度 velocity</li>
<li>2、转化成 距离</li>
<li>3、自己滑了多少距离 根据速度转换后的距离 -&gt; 我自己的滑动距离 &#x3D; 孩子应该滑的距离</li>
<li>4、孩子应该滑的距离又要转化成速度</li>
</ul>
</blockquote>
<ul>
<li>google提供的速度转距离的工具</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213300370.png" alt="image-20220718213300370"></p>
<p>孩子 -&gt;如recyclerView又会将距离转换成速度(因为RecyclerView只支持fling，所以需要转化成速度再转成距离)</p>
<p>下面两个方法分别对应上述步骤中的第3步和第4步</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213317734.png" alt="image-20220718213317734"></p>
<p><strong>关于totalDy</strong></p>
<p>下面注解一处错误：第一个，其实是Viewpager2，不是RecyclerView，通过前面有一张布局截图可以看出最后下面那个是ViewPager2</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213340340.png" alt="image-20220718213340340"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213358954.png" alt="image-20220718213358954"></p>
<h3 id="关于内部拦截"><a href="#关于内部拦截" class="headerlink" title="关于内部拦截"></a>关于内部拦截</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213415057.png" alt="image-20220718213415057"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213428785.png" alt="image-20220718213428785"></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>测试</title>
    <url>/2022/07/12/%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="关于Hexo搭建遇到的小问题"><a href="#关于Hexo搭建遇到的小问题" class="headerlink" title="关于Hexo搭建遇到的小问题"></a>关于Hexo搭建遇到的小问题</h3><p><img src="/%E6%B5%8B%E8%AF%95.assets/1657615742531.png" alt="1657615742531"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解并发编程和归纳总结</title>
    <url>/2022/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AbstractQueueSynchronizer（抽象队列同步器）</p>
<blockquote>
<p>是用来构建ad锁和其他同步组件的基础架构，比如ReentrantLock、ReetrantReadWriteLock和CountDownLatch就是基于<strong>AQS</strong>实现的。它使用一个<strong>int成员变量state</strong>标识同步状态，通过<strong>内置的FIFO（队列）</strong>来完成获取资源线程的排队工作。它是<strong>CLH队列锁</strong>的一种变体实现。它可以实现两种同步方式：<strong>独占式、共享式</strong>。<br>AQS的主要使用方式是<strong>继承</strong>，子类通过继承AQS并实现它的抽象方式来管理同步状态，同步器的设计基于<strong>模板方法模式</strong>，所以如果要实现我们自己的同步工具类就需要其中几个可重写的方法，如tryAcquire、tryRelease、tryReleaseShared等等。<br>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者和同步组件交互的接口（比如可以允许两个线程并访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者锁需关注的领域。<br>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node节点组成，每个Node节点维护一个pre引用和next引用，分别指向自己的前序和后继，构成一个双端双向链表。同时与Condition相关的等待队列，节点类型也是Node，构成了一个单向链表。</p>
</blockquote>
<h3 id="AQS两种资源共享方式"><a href="#AQS两种资源共享方式" class="headerlink" title="AQS两种资源共享方式"></a>AQS两种资源共享方式</h3><blockquote>
<p>1.Exclusive-&gt;独占，只有一个线程能执行，如ReentrantLock<br>2.Share-&gt;共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch</p>
</blockquote>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取和释放方式即可。<br>同步器实现时主要实现以下几种方法：</p>
<ul>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源；负数表示失败；0表示成功，但没有剩余可用价值；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false。</li>
<li>isHeldExclusively：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
</ul>
<h3 id="AQS重要源码预览"><a href="#AQS重要源码预览" class="headerlink" title="AQS重要源码预览"></a>AQS重要源码预览</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-da79f4c3871c7ae2.png" alt="image.png"><br>重要的参数state<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-7190ae966401c75e.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-03623aff31014070.png"></p>
<h3 id="Lock源码"><a href="#Lock源码" class="headerlink" title="Lock源码"></a>Lock源码</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-3e3ff9955721d761.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-1be98e4491920a17.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-e9d62d55bb74cbb1.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f7e7517cfb30bedd.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-11784af71e5884ab.png" alt="image.png"><br>独占式的<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-640b8294babb722a.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-1b58a042fb32d5f4.png" alt="image.png"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-770b3ddbb30dadc6.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-18298cccb10b1a98.png" alt="image.png"></p>
<h3 id="AQS的基本思想CLH队列锁"><a href="#AQS的基本思想CLH队列锁" class="headerlink" title="AQS的基本思想CLH队列锁"></a>AQS的基本思想CLH队列锁</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f140f50743caa711.png" alt="image.png"><br>CLH队列锁<br>1.基于链表的自旋锁<br>2.想要获得锁，通过CAS操作将QNode挂在链表的尾部<br>3.每个QNode都在自选检查（有自旋次数限制，超过后当前线程将进入阻塞状态）myPred是否释放锁<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-7e4d05b64b6da0fc.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-8bd85142d512b8e4.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-132f27aec922be32.png" alt="image.png"></p>
<h3 id="公平锁和非公平锁的介绍"><a href="#公平锁和非公平锁的介绍" class="headerlink" title="公平锁和非公平锁的介绍"></a>公平锁和非公平锁的介绍</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-e2c897782e4989c2.png" alt="image.png"><br><strong>唯一的区别</strong><br>公平锁中会判断队列中是都有线程在等待<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c3a61725c039fbaf.png" alt="image.png"></p>
<h3 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h3><p>我们再回头看看Lock的实现<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-951a38ede7375e8c.png" alt="image.png"><br>什么时候需要锁的可重入？</p>
<blockquote>
<p>当我们需要再次进入该方法时</p>
</blockquote>
<p>实现锁的可重入，否则会自己锁住自己<br>获取锁的时候state+1，释放锁的时候state-1<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-4275dadf72404056.png" alt="image.png"></p>
<h2 id="浅谈JMM"><a href="#浅谈JMM" class="headerlink" title="浅谈JMM"></a>浅谈JMM</h2><p>计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-b6a863238dfba07d.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-8540ad83e80cd995.png" alt="image.png"><br>线程不允许直接访问主内存，工作内存之间相互独立（类似于ThreadLocal），工作内存中存主内存变量的副本。<br>但是如此构建会带来数据同步方面的问题。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c039220a121a78ba.png" alt="image.png"></p>
<p>其实，JMM具可见性、原子性、有序性，那么这是怎么实现的呢？</p>
<ul>
<li>volatile关键字 使变量保持可见性</li>
<li>synchronized关键字 为操作加锁（只是用synchronized同样能保证安全）</li>
<li>一个线程写，多个线程读，使用volatile是OK的。</li>
</ul>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><ul>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似count++这种复合操作不具有原子性。</li>
<li>volatile还能防止指令重排序 关于流水线和重排序 intel十级流水线 比如下例可以先算t&#x3D;b再执行if，提高性能。 但是在多线程中可能会引发多线程安全问题，所以volatile的抑制重排序就有了作用，<strong>如在DCL （双重检测锁定）中的作用？-&gt;防止指令重排序</strong><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-47b7059195083d75.png" alt="image.png"></li>
</ul>
<h4 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h4><p><strong>有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令</strong></p>
<ul>
<li>将当前处理器缓存行的数据写回系统内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><blockquote>
<p>相信大家都用过synchronized，特别是单例设计模式中很常见</p>
</blockquote>
<p>原理：使用monitorenter和monitorexit指令实现的</p>
<ul>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处</li>
<li>每个monitorenter必须有对应的monitorexit与之匹配</li>
<li>任何对象都有一个monitor与之关联<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-d1cb75d005ce1c3c.png" alt="image.png"></li>
</ul>
<h3 id="synchronized做了哪些优化"><a href="#synchronized做了哪些优化" class="headerlink" title="synchronized做了哪些优化"></a>synchronized做了哪些优化</h3><p><strong>锁消除：</strong>和逃逸分析比较紧密，如果在编译过程中发现某个代码块不会发生共享数据竞争，那么就会取消锁。<br><strong>锁粗化：</strong>如下图所示，未被加锁的代码块会被包裹进synchronized，减少线程上下文切换带来的开销。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-a7e0b1c2cdb2ed9a.png" alt="image.png"><br><strong>逃逸分析：</strong>发现加锁的对象只在某个方法内部，对变量做一些相关优化</p>
<p><strong>主要部分：</strong><br>我们来了解锁的四种状态</p>
<ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不存在多线程竞争，而且总是由同一线程多次获得，为了让锁的代价更低而引入了偏向锁。无锁竞争时不需要进行CAS操作来加锁和释放锁。<br>第一次还是需要CAS完成Mark Word的替换 替换如下信息<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-beb559b4194aa99a.png" alt="image.png"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-fea657efece4ab97.png" alt="image.png"><br>如果发生锁的竞争，线程2会先stop the world，然后更改线程1的信息（由偏向锁升级为轻量级锁），这就导致性能降低。这就需要禁止偏向锁。<br>轻量级锁会自旋，当自旋到一定次数后就会发生膨胀，膨胀为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><table>
<thead>
<tr>
<th>锁</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td align="left">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td align="left">如果线程间存在竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td align="left">竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td align="left">如果始终得不到锁竞争的线程使用自旋会消耗CPU 追求响应时间。</td>
<td>同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级</td>
<td align="left">线程竞争不使用自旋，不会消耗CPU。</td>
<td align="left">线程阻塞，响应时间满。</td>
<td>追求吞吐量。同步块执行速度较快。</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="synchronized修饰普通方法和静态方法的区别？什么是可见性？"><a href="#synchronized修饰普通方法和静态方法的区别？什么是可见性？" class="headerlink" title="synchronized修饰普通方法和静态方法的区别？什么是可见性？"></a>synchronized修饰普通方法和静态方法的区别？什么是可见性？</h3><ul>
<li>锁的对象实例<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-dcaa4928eb8e2b28.png" alt="image.png"></li>
<li>锁的当前类唯一的.class对象 -&gt;类锁<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-76ba9c28bb9f33ca.png" alt="image.png"></li>
<li>假如有两个线程分别执行上面各个方法，可以同时执行，拿的不是同一个对象锁。</li>
<li>注意：加锁加的是对象锁，只要不是同一个对象锁，并行执行就不会有问题。</li>
</ul>
<h3 id="单例模式中的懒汉式-延迟初始化占位类模式"><a href="#单例模式中的懒汉式-延迟初始化占位类模式" class="headerlink" title="单例模式中的懒汉式-延迟初始化占位类模式"></a>单例模式中的懒汉式-延迟初始化占位类模式</h3><p>为什么饿汉式与延迟占位类模式是线程安全的？</p>
<blockquote>
<p>这是由类加载机制所保证的，一个类加载只会在虚拟机中执行一次，所以虚拟机为了保证执行性一次在类加载过程中已经实现了线程安全。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-03623aff31014070.png" alt="image.png"></p>
</blockquote>
<h3 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h3><p>守护（Daemon）线程是一种支持性线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c9bb6c9482992aac.png" alt="image.png"><br>线程的停止：</p>
<ul>
<li>run方法执行完成</li>
<li>执行过程中出现异常，终止</li>
<li>不建议使用stop方法，不安全（不考虑线程当前的执行状态直接结束）</li>
<li>interrupt，协议机制 ，被中断的线程内部方法isInterrupted()或Thread.interrupted()判断线程是否进行中断。</li>
</ul>
<h3 id="sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）"><a href="#sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）" class="headerlink" title="sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）"></a>sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）</h3><ul>
<li>yield方法让出CPU的执行权，什么时候拿回来由操作系统决定。（让出CPU的执行权）</li>
<li>sleep让当前线程 进行休眠，（通常用于暂停线程的执行）</li>
<li>wait让当前线程等待，这三者只有wait方法会释放锁，唤醒后重新竞争锁。（主要用于线程之间的交互）</li>
</ul>
<h3 id="sleep是可中断的吗？"><a href="#sleep是可中断的吗？" class="headerlink" title="sleep是可中断的吗？"></a>sleep是可中断的吗？</h3><p>是，调用Thread.sleep()会抛出一个中断异常，说明是可以中断的。</p>
<h3 id="有三个线程T1、T2、T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1、T2、T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1、T2、T3，怎么确保它们按顺序执行？"></a>有三个线程T1、T2、T3，怎么确保它们按顺序执行？</h3><p>加入执行顺序：T1-&gt;T2-&gt;T3<br>T3方法中T2.join()<br>T2方法中T1.join()</p>
<h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><ul>
<li>sleep和wait都可设置时间</li>
<li>只有synchronized才会使线程进入阻塞态</li>
<li>Lock进入等待或超时等待态</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-77d154ac11d5e97c.png" alt="image.png"></p>
<h3 id="手写死锁"><a href="#手写死锁" class="headerlink" title="手写死锁"></a>手写死锁</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-836114f93d4bea42.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Java筑基</category>
      </categories>
  </entry>
  <entry>
    <title>自定义LayoutManager实现卡片滑动</title>
    <url>/2022/07/23/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%E5%AE%9E%E7%8E%B0%E5%8D%A1%E7%89%87%E6%BB%91%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前面介绍了利用自定义ItemDecoration实现RecyclerView吸顶效果，重点就在onDraw -&gt; ItemView -&gt; onDrawOver的绘制流程，同时注意预留空间的利用。</p>
<p>今天介绍一个新的知识点与demo，利用自定义LayoutManager的方式实现卡片滑动。有时候系统提供的LayoutManager已经不能够满足我们的需求，这个时候我们就需要自定义LayoutManager。</p>
</blockquote>
<h2 id="卡片滑动效果介绍"><a href="#卡片滑动效果介绍" class="headerlink" title="卡片滑动效果介绍"></a>卡片滑动效果介绍</h2><p>卡片滑动的效果如下图所示。</p>
<p>分析一下卡片效果，顶部的卡片是正常摆放，接着的后面两张会随着位置变化缩小、下移，产生视觉上的叠层效果，再然后的卡片就与第三张重叠摆放。可以滑动移除图片，下面的卡片会自动补全。</p>
<ul>
<li>实现这样的效果突破点在于两点：</li>
</ul>
<ol>
<li>要实现这样重叠式布局的效果，我们就需要自定义LayoutManager，就像系统自带的<code>LinearLayoutManager</code>、<code>GridLayoutManager</code>一样。</li>
<li>滑动移除效果的实现，没有重写<code>scrollVerticallyBy</code>以及<code>scrollHorizontallyBy</code>，这就需要一个重要的帮助类<code>ItemTouchHelper</code></li>
</ol>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/SlideCard.gif" alt="SlideCard"></p>
<h2 id="卡片滑动实现"><a href="#卡片滑动实现" class="headerlink" title="卡片滑动实现"></a>卡片滑动实现</h2><ul>
<li><p>实现思路</p>
<blockquote>
<ol>
<li>摆放策略交给LayoutManager-&gt;具体怎么摆，每一个卡片布局策略和数据绑定由Adapter负责</li>
<li>LayoutManager必须重写<code>onLayoutChildren</code>方法，当数据发生改变时，会重新布局，detachAndScrapAttachedViews处理回收，recycler.getViewForPosition(i)获取对应位置的View。</li>
<li>测量view，摆放时需要考虑通过ItemDecoration预留的间距<code>layoutDecoratedWithMargins</code></li>
<li>卡片采用的是倒序摆放，即从第8张到第一张的顺序摆放</li>
<li>利用<code>ItemTouchHelper</code>实现滑动移除，并且需要重写onChildDraw，实现滑动动画开始时，下方图片缩放效果。TouchHelper是ItemDecoration的子类，在onDraw时根据滑动距离来影响后面view的大小</li>
</ol>
</blockquote>
</li>
<li><p>关键代码块：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlideCardLayoutManager</span>:RecyclerView.LayoutManager() &#123;</span><br><span class="line">    override fun <span class="title function_">generateDefaultLayoutParams</span><span class="params">()</span>: RecyclerView.LayoutParams &#123;</span><br><span class="line">        <span class="keyword">return</span> RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        ViewGroup.LayoutParams.WRAP_CONTENT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onLayoutChildren</span><span class="params">(recycler: RecyclerView.Recycler?, state: RecyclerView.State?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onLayoutChildren(recycler, state)</span><br><span class="line">        detachAndScrapAttachedViews(recycler!!)</span><br><span class="line">        <span class="type">val</span> <span class="variable">itemCount</span> <span class="operator">=</span> itemCount</span><br><span class="line">        <span class="type">var</span> <span class="variable">bottomPosition</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount&lt;CardConfig.MAX_SHOW_COUNT)&#123;</span><br><span class="line">            bottomPosition = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            bottomPosition = itemCount - CardConfig.MAX_SHOW_COUNT</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i in bottomPosition until  itemCount)&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recycler.getViewForPosition(i)</span><br><span class="line">            addView(view)</span><br><span class="line">            <span class="comment">//测量</span></span><br><span class="line">            measureChildWithMargins(view,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="type">val</span> <span class="variable">widthSpace</span> <span class="operator">=</span> width - getDecoratedMeasuredHeight(view)</span><br><span class="line">            <span class="type">val</span> <span class="variable">heightSpace</span> <span class="operator">=</span> height - getDecoratedMeasuredHeight(view)</span><br><span class="line">            <span class="comment">//布局</span></span><br><span class="line">            layoutDecoratedWithMargins(view,</span><br><span class="line">            widthSpace/<span class="number">2</span>,</span><br><span class="line">            heightSpace/<span class="number">2</span>,</span><br><span class="line">            widthSpace/<span class="number">2</span>+getDecoratedMeasuredWidth(view),</span><br><span class="line">            heightSpace/<span class="number">2</span>+getDecoratedMeasuredHeight(view))</span><br><span class="line">            <span class="type">var</span> <span class="variable">level</span> <span class="operator">=</span> itemCount -i -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (level&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (level&lt;CardConfig.MAX_SHOW_COUNT-<span class="number">1</span>)&#123;<span class="comment">//提示，这里CardConfig.MAX_SHOW_COUNT=4，可见小编所有代码</span></span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * level</span><br><span class="line">                    view.scaleX = <span class="number">1</span>-CardConfig.SCALE_GAP*level</span><br><span class="line">                    view.scaleY = <span class="number">1</span>-CardConfig.SCALE_GAP*level</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * (level-<span class="number">1</span>)</span><br><span class="line">                    view.scaleX = <span class="number">1</span>-CardConfig.SCALE_GAP*(level-<span class="number">1</span>)</span><br><span class="line">                    view.scaleY = <span class="number">1</span>-CardConfig.SCALE_GAP*(level-<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：这里继承的是<code>ItemTouchHelper.SimpleCallback</code>，<code>ItemTouchHelper.Callback</code>需要重写的方法太多。</li>
<li>重写onChildDraw，因为notifyDataSetChanged()会走onDraw流程，而onDraw又会调用onChildDraw。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlideCallBack</span>(</span><br><span class="line">    <span class="keyword">private</span> val adapter:SlideCardAdapter,</span><br><span class="line">    <span class="keyword">private</span> val mData:MutableList&lt;SlideCardBean&gt;</span><br><span class="line">):ItemTouchHelper.SimpleCallback(<span class="number">0</span>,<span class="number">15</span>) &#123;</span><br><span class="line">    override fun <span class="title function_">onMove</span><span class="params">(</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        viewHolder: RecyclerView.ViewHolder,</span></span><br><span class="line"><span class="params">        target: RecyclerView.ViewHolder</span></span><br><span class="line"><span class="params">    )</span>: Boolean &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NotifyDataSetChanged&quot;)</span></span><br><span class="line">    override fun <span class="title function_">onSwiped</span><span class="params">(viewHolder: RecyclerView.ViewHolder, direction: Int)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">remove</span> <span class="operator">=</span> mData.removeAt(viewHolder.layoutPosition)</span><br><span class="line">        mData.add(<span class="number">0</span>,remove)</span><br><span class="line">        adapter.notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onChildDraw</span><span class="params">(</span></span><br><span class="line"><span class="params">        c: Canvas,</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        viewHolder: RecyclerView.ViewHolder,</span></span><br><span class="line"><span class="params">        dX: Float,</span></span><br><span class="line"><span class="params">        dY: Float,</span></span><br><span class="line"><span class="params">        actionState: Int,</span></span><br><span class="line"><span class="params">        isCurrentlyActive: Boolean</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive)</span><br><span class="line">        <span class="type">val</span> <span class="variable">maxDistance</span> <span class="operator">=</span> recyclerView.width * <span class="number">0.5f</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">distance</span> <span class="operator">=</span> sqrt((dX*dX+dY*dY).toDouble())</span><br><span class="line">        <span class="type">var</span> <span class="variable">fraction</span> <span class="operator">=</span> distance/maxDistance</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(fraction&gt;<span class="number">1</span>)</span>&#123;</span><br><span class="line">            fraction= <span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">val</span> <span class="variable">itemCount</span> <span class="operator">=</span> recyclerView.childCount</span><br><span class="line">        Log.v(<span class="string">&quot;ppp&quot;</span>,<span class="string">&quot;itemCount: $itemCount&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(i in <span class="number">0</span> until itemCount)&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recyclerView.getChildAt(i)</span><br><span class="line">            <span class="type">val</span> <span class="variable">level</span> <span class="operator">=</span> itemCount - i - <span class="number">1</span></span><br><span class="line">            Log.v(<span class="string">&quot;pc&quot;</span>,<span class="string">&quot;level: $level&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (level&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//重绘level=1，2 -&gt;也就是i=5,6</span></span><br><span class="line">                <span class="keyword">if</span> (level&lt;CardConfig.MAX_SHOW_COUNT-<span class="number">1</span>)&#123;</span><br><span class="line">                    view.translationY = (CardConfig.TRANS_Y_GAP * (level-fraction)).toFloat()</span><br><span class="line">                    view.scaleX = (<span class="number">1</span>-CardConfig.SCALE_GAP*level+fraction*CardConfig.SCALE_GAP).toFloat()</span><br><span class="line">                    view.scaleY = (<span class="number">1</span>-CardConfig.SCALE_GAP*level+fraction*CardConfig.SCALE_GAP).toFloat()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s时间</span></span><br><span class="line">    override fun <span class="title function_">getAnimationDuration</span><span class="params">(</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        animationType: Int,</span></span><br><span class="line"><span class="params">        animateDx: Float,</span></span><br><span class="line"><span class="params">        animateDy: Float</span></span><br><span class="line"><span class="params">    )</span>: Long &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前为止，小编已经介绍了RecyclerView自定义用法的两种，自定义ItemDecoration和自定义LayoutManager。这里有一个逻辑上的坑点：顶部的卡片是正常摆放，我们自定义LayoutManager中不用管它，所以在上方两个代码块中都有<code>level&gt;0</code>和<code>level&lt;CardConfig.MAX_SHOW_COUNT-1</code>，也就是重绘索引值<code>i=5,6</code>即第6和7个，在<code>SlideCardLayoutManager</code>中，第5张卡片即一下的重叠在第6张的下面。这个点烦恼了小编好久，刚开始一直不明白顶部的摆放去哪了，从这点可以看出了解原理看源码的重要性。下一章，我们将对RecyclerView源码机制进行解读，再结合这一章的内容，将会对RecyclerView的原理有个更深层次的理解。</p>
<p><a href="https://github.com/gun-ctrl/SlideCard">全部代码地址</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次上传测试</title>
    <url>/2022/07/09/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>阻塞队列与线程池机制</title>
    <url>/2022/07/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ul>
<li>1.Thread</li>
<li>2.Runnable（实例化接口，重新run方法，放入Thread中执行）</li>
</ul>
<p>为什么Callable方式不算?</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148325145.png" alt="1654148325145"></p>
<blockquote>
<p>首先，我们都知道创建线程都需要通过Thread，那么我们来看一下Thread的构造函数</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148402777.png" alt="1654148402777"></p>
<p>可以看到，Thread构造函数中压根就没有Callable类型的参数</p>
<p>接着，我们再来看看Callable，Callable是继承自FutureTask</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148426071.png" alt="1654148426071"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148455965.png" alt="1654148455965"></p>
<p>通过上面的源码截图，我们可以看出来Callable本质上还是Runnable的一种实现</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><strong>Compare And Swap</strong></p>
<blockquote>
<p>提及CAS之前，我们先来提一下原子操作，原子操作就是一气呵成，中间不能被打断，学过操作系统的朋友应该和熟悉，没错，就类似于操作系统中的中断原语。</p>
</blockquote>
<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220730211300257.png" alt="image-20220730211300257"></p>
<blockquote>
<p>会有两个重要的属性变量，旧值与新值（需要更改的值），每次进入前都会用旧值与内存中的变量值进行比较，如果相同，就会用新值替换内存中的变量值，否则将再次循环上述过程。</p>
</blockquote>
<h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>什么是ABA问题呢？</strong></p>
<blockquote>
<p>就是旧值为A，被替换为新值B，后面的线程又替换为新值A。再后面的线程对比其存储的旧值与内存中的值相等，但是它并不知道中间有个A-&gt;B-&gt;A的过程。</p>
</blockquote>
<p><strong>解决方案</strong></p>
<p>通过打标识的方式标记：</p>
<p>1.AtomicMarkableReference-&gt;仅仅标识发生了ABA现象</p>
<p>2.AtomicStampedReference-&gt;可以知道发生了几次ABA现象</p>
<h4 id="开销问题"><a href="#开销问题" class="headerlink" title="开销问题"></a>开销问题</h4><blockquote>
<p>CAS是一个不断循环检测的过程，毫无疑问，这将带来一定的开销。</p>
</blockquote>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><ul>
<li>jdk中相关原子操作类的使用<ul>
<li>更新基本类型：AtomicBoolean，AtomicInteger，AtomicLong</li>
<li>更新数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>
<li>更新引用类型：AtomicReference，AtomicMarkableReference（只关心该没改过），AtomicStampedReference（还关心改过几次）</li>
</ul>
</li>
</ul>
<p>有些时候对于某些简单的操作采用加锁的话未免有些过重了，可以采用原子类型如果你需要改变多个变量，可以进行封装，通过AtomicReference来管理。</p>
<h2 id="线程池机制"><a href="#线程池机制" class="headerlink" title="线程池机制"></a>线程池机制</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><blockquote>
<p>线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。ThreadLocal可以让每个线程拥有属于自己的变量的副本，不会和其他线程的变量副本冲突，实现了线程的数据隔离</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-867510bb5ec6c143.png" alt="threadLocal"></p>
</blockquote>
<h3 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h3><p><strong>什么是线程池？为什么要用线程池？</strong></p>
<blockquote>
<ul>
<li>Thread线程属于操作系统的资源，消耗CPU、内存 -&gt;降低资源消耗</li>
<li>线程有创建、执行、销毁的时间，所以为什么不事先准备好呢？-&gt;提高响应度</li>
<li>所以需要一个策略机制来管理线程-&gt;提高线程的可管理性</li>
</ul>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220731114721901.png" alt="image-20220731114721901"></p>
<h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a><strong>线程池的参数</strong></h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579455105.png" alt="1654140925994"></p>
<ul>
<li><p>keepAliveSize和TimeUnit这俩参数控制空闲线程存活的时间</p>
</li>
<li><p>ThreadFactory对创建线程时做这些微调工作</p>
</li>
<li><p>RejectedExecutionHandler 拒绝策略（阻塞队列满，任务数超过了最大线程数，那么就会拒绝）</p>
<ul>
<li>DiscardOldestPolicy 抛弃最老的，也就是队列队首的任务</li>
<li>AbortPolicy 直接抛出异常</li>
<li>CallerRunsPolicy  谁调用谁执行</li>
<li>DiscardPolicy 丢弃最新提交的任务</li>
</ul>
<p>当然也可以自己实现接口自定义拒绝策略</p>
</li>
<li><p>阻塞队列BlockingQueue</p>
</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>
<p>这里以okhttp中的实用场景对其中几种做简介：</p>
<p>在OkHttp的分发器中的线程池定义如上，其实就和 Executors.newCachedThreadPool()创建的线程一样。首先核心线程为0，表示线程池不会一直为我们缓存线程，线程池中所有线程都是在60s内没有工作就会被回收。而最大线程Integer .MAX_VALUE与等待队列synchronousQueue的组合能够得到最大的吞吐量。即当需要线程池执行任务时，如果不存在空闲线程不需要等待，马上新建线程执行任务!等待队列的不同指定了线程池的不同排队机制。一般来说，等待队列BlockingQueue有: (ArrayBlockingQueue 、LinkedBlockingQueue 与synchronousQueue 。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下:</p>
<p>ArrayBlockingQueue :基于数组的阻塞队列，初始化需要指定固定大小</p>
<p>当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p>LinkedBlockingQueue :基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>当指定大小后，行为就和ArrayBlockingQueue一致。而如果未指定大小，则会使用默认的Integer.MAX_VALUE作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p>SynchronousQueue :无容量的队列。</p>
<p>使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合Integer.MAX_VALUE就实现了真正的无等待。</p>
<p>但是需要注意的时，我们都知道，进程的内存是存在限制的，而每一个线程都需要分配一定的内存。所以线程并不能无限个数。那么当设置最大线程数为Integer.MAX_VALUE时，OkHttp同时还有最大请求任务执行个数: 64的限制。这样即解决了这个问题同时也能获得最大吞吐。</p>
<h3 id="两种线程池的提交任务的方法"><a href="#两种线程池的提交任务的方法" class="headerlink" title="两种线程池的提交任务的方法"></a>两种线程池的提交任务的方法</h3><ul>
<li><p>execute(不关心有无返回结果)</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579682668.png" alt="1654142332347"></p>
</li>
<li><p>submit</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579624953.png" alt="1654142400705"></p>
</li>
</ul>
<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><ul>
<li><p>shutdown 尝试关闭一个线程，把当前没有执行任务的线程中断</p>
</li>
<li><p>shutdownNow 不管有没有执行任务的线程，都尝试中断</p>
<p>但是不一定成功  所谓线程的中断是一个协作机制  看任务执行方</p>
</li>
</ul>
<h3 id="合理配置线程池资源"><a href="#合理配置线程池资源" class="headerlink" title="合理配置线程池资源"></a>合理配置线程池资源</h3><p><strong>任务特性</strong></p>
<ul>
<li><p>CPU密集型  纯计算</p>
<p>配置最大线程数不要超过机器的CPU核心数（Runtime.getRuntime()）顶多+1（保证核心线程有事做），否则切换线程带来时间浪费</p>
</li>
<li><p>IO密集型 与网络、读取磁盘等IO操作相关的</p>
<p>最大线程数：机器的CPU核心线程数*2（推荐的经验值）</p>
</li>
<li><p>混合型 兼并上面两者 </p>
<p>如果两者的执行时间相差不大，拆分成两个线程池专门处理各自类型</p>
<p>如果两者相差很大，不用拆分（谁大配置谁）。</p>
</li>
</ul>
<p>核心线程数，看业务（详情参考Okhttp）</p>
]]></content>
      <categories>
        <category>Java筑基</category>
      </categories>
  </entry>
</search>
