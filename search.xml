<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>APP卡顿与布局优化</title>
    <url>/2022/10/30/APP%E5%8D%A1%E9%A1%BF%E5%92%8C%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大多数用户感知到的卡顿等性能问题的主要根源都是因为渲染性能。Android系统每隔大概16.6ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能达到流畅的画面所需要的60fps，为了能够实现fps（每秒传输帧数），这意味着程序的大多数操作都必须在16ms完成。</p>
<p>我们通常都会提到60fps和16ms，可是知道为何会以程序是否达到60fps来作为APP性能的衡量标准吗？这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。</p>
<p>12fps大概类似手动快速翻动书籍的频率，这明显是可以感知到是不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用的支出。但是低于30fps是无法顺畅表现绚丽的画面的内容的，此时就需要用到60fps来表达想要的效果，当然超过60fps是没有必要的。开发app的性能目标就是保持60fps，这意味着每一帧你只有16ms&#x3D;1000&#x2F;60的时间来处理事务。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps1.jpg" alt="img"></p>
<p>如果某个操作花费时间是24ms，系统在得到VSYNC信号的时候就无法进行正常渲染，这样就发生了丢帧现象。那么用户在32ms内看到的会是同一帧画面。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps2.jpg" alt="img"> </p>
<p>有很多原因可以导致丢帧，一般主线程过多的UI绘制、大量的IO操作或是大量的计算操作占用CPU，都会导致App界面卡顿。</p>
<h3 id="IdleHandler"><a href="#IdleHandler" class="headerlink" title="IdleHandler"></a>IdleHandler</h3><p>IdleHandler会在Handler空闲时执行</p>
<p>适用场景</p>
<blockquote>
<ul>
<li>如果启动的Activity、Fragment、Dialog内含有大量的数据和视图的加载，导致首次打开时切换卡顿或者一瞬间白屏，可将部分加载逻辑放到queueIdle()内处理。例如引导图的加载和弹窗提示等；</li>
<li>一些第三方框架Glide和LeakCanary等也使用到IdleHandler。</li>
</ul>
</blockquote>
<p>实例：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030172939455.png" alt="image-20221030172939455"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030172952411.png" alt="image-20221030172952411"></p>
<h2 id="卡顿分析"><a href="#卡顿分析" class="headerlink" title="卡顿分析"></a>卡顿分析</h2><h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><blockquote>
<p>Systrace是Android平台提供的一款工具，用于记录短期内的设备活动。该工具会生成一份报告，其中汇总了Android内核中的数据，例如CPU调度程序、磁盘活动和应用线程。Systrace主要用来分析绘制性能方面的问题。在发生卡顿时，通过这份报告可以知道当前整个系统所处的状态，从而帮助开发者更直观的分析系统瓶颈，改进性能。</p>
<ul>
<li>CPU Profiler可以看出代码在运行时的一些具体信息，方法调用时长、次数、时间比率、了解代码运行过程的效率问题，从而针对性改善代码。所以对于可能导致卡顿的耗时方法也可以通过CPU Profiler检测。</li>
</ul>
</blockquote>
<p>要使用Systrace，需要先安装Python2.7.(目前不支持高版本)。</p>
<p>Systrace具体使用可以参考这篇博客：<a href="https://www.jianshu.com/p/e73768e66b8d">https://www.jianshu.com/p/e73768e66b8d</a></p>
<p>执行systrace可以选择配置自己感兴趣的category，常用的有：</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>gfx</td>
<td>Graphics图形系统，包括SerfaceFlinger，VSYNC消息，Texture，RenderThread等</td>
</tr>
<tr>
<td>input</td>
<td>Input输入系统，按键或者触摸屏输入；分析滑动卡顿等</td>
</tr>
<tr>
<td>view</td>
<td>View绘制系统的相关信息，比如onMeasure，onLayout等；分析View绘制性能</td>
</tr>
<tr>
<td>am</td>
<td>ActivityManager调用的相关信息；分析Activity的启动、跳转</td>
</tr>
<tr>
<td>dalvik</td>
<td>虚拟机相关信息；分析虚拟机行为；如GC停顿</td>
</tr>
<tr>
<td>sched</td>
<td>CPU调度的信息，能看到CPU在每个时间段在运行什么线程，线程调度情况，锁信息。</td>
</tr>
<tr>
<td>disk</td>
<td>IO信息</td>
</tr>
<tr>
<td>wm</td>
<td>WindowManager的相关信息</td>
</tr>
<tr>
<td>res</td>
<td>资源加载的相关信息</td>
</tr>
</tbody></table>
<p><strong>其实Systrace对于应用开发者来说，能看的并不多。主要用于看是否丢帧，与丢帧时系统以及我们应用大致的一个状态。</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030173502923.png" alt="image-20221030173502923"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030173517795.png" alt="image-20221030173517795"></p>
<blockquote>
<p><strong>注意：我们在抓取systrace文件的时候，切记不要抓取太长的时间，也不要太多不同操作。</strong></p>
<p>打开抓取的html文件，可以看到我们应用存在非常严重的掉帧，不借助工具直接用肉眼看UI是看不出来的。如果只是单独存在一个红色或者黄色都是没有关系的。关键是连续的红&#x2F;黄或者两帧间隔非常大那就需要我们去仔细观察，按“W”放大视图，在UIThread(主线程)上面有一条很细的线，表示线程的状态。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030173601186.png" alt="image-20221030173601186"></p>
<p>Systrace会用不同的颜色来标识不同的线程状态，在每个方法上都会有对应的线程状态来标识目前线程所处的状态。通过查看线程状态我们可以知道目前的瓶颈是什么，是CPU执行慢还是因为Binder调用，又或是进行IO操作，又或是拿不到CPU时间片。</p>
<p>Systrace会用不同的颜色来标识不同的线程状态，在每个方法上都会有对应的线程状态来标识目前线程所处的状态。通过查看线程状态我们可以知道目前的瓶颈是什么，是CPU执行慢还是因为Binder调用，又或是进行IO操作，又或是拿不到CPU时间片。</p>
<p>线程状态主要有以下几种：</p>
<ul>
<li><p><strong>绿色：表示正在运行：</strong></p>
<ul>
<li>是否频率不够？（CPU处理速度）</li>
<li>是否跑在小核上？（不可控，但实际上很多手机都会有游戏模式，如果我们应用是手游，那系统会优先把手游中的任务放到大核上跑。）</li>
</ul>
</li>
<li><p><strong>蓝色：表示可以运行，但是CPU在执行其他线程：</strong></p>
<ul>
<li>是否后台有太多的任务在跑？Runnable状态的线程状态持续时间越长，则表示CPU的调度越忙，没有及时处理到这个任务</li>
<li>没有及时处理是否是因为频率太低？</li>
</ul>
</li>
<li><p><strong>紫色：表示休眠，一般表示IO：</strong></p>
<ul>
<li><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps3.jpg" alt="img"></p>
</li>
<li><p>官方介绍为:</p>
<p>橙色：不可中断的休眠</p>
<p>线程在遇到I&#x2F;O操作时被阻止或正在等待磁盘操作完成。</p>
</li>
<li><p>紫色：可中断的休眠线程在遇到另一项内核操作（通常是内存管理）时被阻止。</p>
</li>
</ul>
<p>但是实际从Android 9模拟器中拉取数据，遇到IO显示紫色，没有橙色状态显示。</p>
</li>
<li><p>**白色：表示休眠,**可能是因为线程在互斥锁上被阻塞，如Binder阻塞&#x2F;Wait&#x2F;Sleep等</p>
</li>
</ul>
<p><strong>点击线程的某段能获取当前的线程信息与状态</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps4.jpg" alt="img"> </p>
<p><strong>实例：</strong></p>
<p>如下图，对比两个“红点”之间与正常“绿点”发现卡顿的发生原因可能是大量的文件操作导致</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps5.jpg" alt="img"> </p>
<p>还可以再结合CPU Profiler-&gt;System Trace分析</p>
<p><strong>找出原因</strong>：排查到出现非法文件操作的位置</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps6.jpg" alt="img"></p>
<p><strong>点击线程的某段能获取当前的线程信息与状态</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174107243.png" alt="image-20221030174107243"></p>
<p><strong>实例：</strong></p>
<p>如下图，对比两个“红点”之间与正常“绿点”发现卡顿的发生原因可能是大量的文件操作导致</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174119469.png" alt="image-20221030174119469"></p>
<p>还可以再结合CPU Profiler-&gt;System Trace分析</p>
<p><strong>找出原因</strong>：排查到出现非法文件操作的位置</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174131882.png" alt="image-20221030174131882"></p>
<h3 id="Profiler-gt-System-Trace"><a href="#Profiler-gt-System-Trace" class="headerlink" title="Profiler-&gt; System Trace"></a>Profiler-&gt; System Trace</h3><blockquote>
<p>Systrace只是能为我们提供一种猜想，猜想发生卡顿的大概位置、原因，要想定位到具体代码块就需要System Trace。</p>
<p>其实目前版本的Android Studio已经封装的很好了，System Trace就是模拟Systrace然后封装到AS中。并且还能看到某个时间区间方法的调用。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174230495.png" alt="image-20221030174230495"></p>
<p><strong>注</strong>：不要Record太多操作！ </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174241101.png" alt="image-20221030174241101"></p>
<p><strong>注</strong>：以下内容针对Android 10以及更低版本（高版本操作雷同，亦可参看官网<a href="https://developer.android.google.cn/studio/profile/jank-detection">界面卡顿检测</a>）</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174305823.png" alt="image-20221030174305823"></p>
<p>相关的操作系统图形管道信息会显示在 CPU 性能分析器系统轨迹中的单个部分，称为 ****Display****。</p>
<ul>
<li><p><strong>Frames</strong>：此部分显示应用中的界面线程和RenderThread轨迹事件。时长超过16ms的事件会以红色表示，以突出显示潜在的卡顿帧，因为它们超出了60帧&#x2F;秒（fps）的速度进行呈现的截止时间。</p>
</li>
<li><p><strong>SurfaceFlinger：</strong>此部分显示SurfaceFlinger处理帧缓冲区的时间。SurfaceFlinger是负责将缓冲区内容发送到显示屏的系统进程。</p>
</li>
<li><p><strong>VSYNC</strong>：此部分显示VSYNC，这是一个表示与显示流水线保持同步的信号。此轨迹会显示VSYNC-app信号，这个信号会在应用启动时间过晚时显示。通常情况下，发生这种情况是因为界面线程处于忙碌状态。在动画播放期间，它会导致屏幕上出现可见的闪烁，并且在动画或滚动完成之前，会持续带来额外的输入延迟。对于刷新率较高的显示屏，尤其要注意查看该轨迹，因为与刷新率为60次&#x2F;秒或刷新率可变的显示屏相比，这种显示屏容易出现此类问题。</p>
</li>
<li><p><strong>BufferQueue</strong>：此部分显示有多少帧缓冲区在排队等待SurfaceFlinger使用。对于部署到搭载Android 9（API级别28）或更高版本的设备的应用，此轨迹显示应用 surface BufferQueue的缓冲区计数（0、1或2）。BufferQueue可帮助我们了解图像缓冲区在Android图形组件之间切换时的状态。例如，值2表示应用当前处于三重缓冲状态，这会导致额外的输入延迟。</p>
</li>
</ul>
<p><strong>Display</strong>部分会提供有助于检测潜在卡顿的实用信号，例如何时界面线程或RenderThread的用时超过16毫秒。若要调查导致卡顿的确切细节，可以查看Threads部分，其中会显示与界面呈现有关的线程。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174425605.png" alt="image-20221030174425605"></p>
<p>在上图中，Threads部分显示了界面线程（java.com.google.samples.apps.iosched）、RenderThread和GPU completion。这些线程与界面呈现有关，可能是导致卡顿的原因。</p>
<p>Android 10或更低版本检测卡顿操作：</p>
<ol>
<li><p>查看<strong>Display</strong>中的<strong>Frames</strong>轨迹。红色帧是要调查的候选对象。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174517716.png" alt="image-20221030174517716"></p>
</li>
<li><p>发现可能存在卡顿的帧后，按“<strong>W</strong>”，或在按住Control键的同时滚动鼠标，以便进行放大。继续放大，直到看到界面线程和RenderThread中的轨迹事件。</p>
</li>
</ol>
<p>   <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030174541910.png" alt="image-20221030174541910"></p>
<p>   在上图中，Choreographer#Frame显示了界面线程何时调用Choreographer来协调动画、视图布局、图像绘制和相关进程。DrawFrames显示了RenderThread何时形成并向GPU发出实际绘制命令。</p>
<ol start="3">
<li><p>如果发现轨迹事件特别长，可以进一步放大，以便找出可能导致呈现速度缓慢的原因。上图显示了界面线程中的inflate，这意味着应用正在花时间膨胀布局。当放大其中一个inflate事件时，可以确切了解每个界面组件花费的时间，如下所示：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps7.jpg" alt="img"></p>
</li>
<li><p>根据Frames缩小排查区域，根据下图右方的Top Down进一步排查出可能导致卡顿的操作。</p>
</li>
</ol>
<p>   <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps8.jpg" alt="img"></p>
<h3 id="APP层面监控卡顿"><a href="#APP层面监控卡顿" class="headerlink" title="APP层面监控卡顿"></a>APP层面监控卡顿</h3><p>Systrace可以让我们了解应用所处的状态，了解应用卡顿因为什么导致的。若需要准确分析卡顿发生在什么函数，资源占用情况如何，目前业界两种主流有效的app监控方式如下：</p>
<ol>
<li><p>利用UI线程的Looper打印的日志匹配；</p>
</li>
<li><p>使用Choregrapher.FrameCallback</p>
</li>
</ol>
<h4 id="Looper日志监控卡顿（BlockCanary）"><a href="#Looper日志监控卡顿（BlockCanary）" class="headerlink" title="Looper日志监控卡顿（BlockCanary）"></a>Looper日志监控卡顿（BlockCanary）</h4><p>其实后面的内容就是BlockCanary的原理，也可以直接使用BlockCanary：</p>
<p><a href="https://github.com/markzhai/AndroidPerformanceMonitor">https://github.com/markzhai/AndroidPerformanceMonitor</a></p>
<p>其提示方式和LeakCanary一样，会生成如下弹窗</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>Android主线程更新UI。如果界面1秒钟少了60次，用户就会产生卡顿感觉。简单来说，Android使用消息机制进行UI更新，UI线程有个Looper，在其Looper方法中会不断去除message，调用其绑定的Handler在UI线程执行。如果在Handler的dispatchMessage方法里有耗时操作，就会发生卡顿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loop</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        <span class="type">Printer</span> <span class="variable">logging</span> <span class="operator">=</span> me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="literal">null</span>)&#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +</span><br><span class="line">                    msg.callback + <span class="string">&quot;:&quot;</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.target.dispatchMessage(msg);</span><br><span class="line">        <span class="keyword">if</span>(logging != <span class="literal">null</span>)&#123;</span><br><span class="line">            logging.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot;</span> + msg.target + <span class="string">&quot; &quot;</span> +    msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要检测msg.target.dispatchMessage(msg)的执行时间，就能检测到部分UI线程是否有耗时操作。注意到这行执行代码前后，有两个logging.println函数，如果设置了logging，会分别打印出&gt;&gt;&gt;&gt;&gt;Dispatching to和&lt;&lt;&lt;&lt;&lt;Finished to这样的日志，这样我们就可以通过两次log的时间差值，来计算dispatchMessage的执行时间，从而设置阈值判断是否发生了卡顿。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030175520451.png" alt="image-20221030175520451"></p>
<p>Looper提供了setMessageLogging(@Nullable Printer printer)方法，所以我们可以自己实现一个Printer，再通过setMessageLogging()方法传入即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockCanary</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">install</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">LogMonitor</span> <span class="variable">logMonitor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LogMonitor</span>();</span><br><span class="line">        Looper.getMainLooper().setMessageLogging(logMonitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogMonitor</span> <span class="keyword">implements</span> <span class="title class_">Printer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> StackSampler mStackSampler;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mPrintingStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mStartTimestamp;</span><br><span class="line">    <span class="comment">//卡顿阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">mBlockThresholdMills</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">//采样频率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">mSampleInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mLogHandler;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LogMonitor</span><span class="params">()</span>&#123;</span><br><span class="line">        mStackSampler = <span class="keyword">new</span> <span class="title class_">StackSampler</span>(mSampleInterval);</span><br><span class="line">        <span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;block-canary-io&quot;</span>);</span><br><span class="line">        handlerThread.start();</span><br><span class="line">        mLogHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//从if到else会执行 dispatchMessage，如果执行耗时超过阈值，输出卡顿信息</span></span><br><span class="line">        <span class="keyword">if</span> (!mPrintingStarted)&#123;</span><br><span class="line">            <span class="comment">//记录开始时间</span></span><br><span class="line">            mStartTimestamp = System.currentTimeMillis();</span><br><span class="line">            mPrintingStarted = <span class="literal">true</span>;</span><br><span class="line">            mStackSampler.startDump();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            mPrintingStarted = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//出现卡顿</span></span><br><span class="line">            <span class="keyword">if</span> (isBlock(endTime))&#123;</span><br><span class="line">                notifyBlockEvent(endTime);</span><br><span class="line">            &#125;</span><br><span class="line">            mStackSampler.stopDump();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyBlockEvent</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> endTime)</span>&#123;</span><br><span class="line">        mLogHandler.post(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">//获取卡顿时主线程堆栈</span></span><br><span class="line">                List&lt;String&gt; stacks = mStackSampler.getStacks(mStartTimestamp,endTime);</span><br><span class="line">                <span class="keyword">for</span> (String stack : stacks)&#123;</span><br><span class="line">                    Log.e(<span class="string">&quot;block-canary&quot;</span>,stack);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isBlock</span><span class="params">(<span class="type">long</span> endTime)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endTime - mStartTimestamp &gt; mBlockThresholdMills;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackSampler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SEPARATOR</span> <span class="operator">=</span> <span class="string">&quot;\r\n&quot;</span>;</span><br><span class="line">    <span class="meta">@SuppressLint(&quot;SimpleDateFormat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">SimpleDateFormat</span> <span class="variable">TIME_FORMATTER</span> <span class="operator">=</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;MM-dd HH:mm:ss.SSS&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Long,String&gt; mStackMap = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">mMaxCount</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> mSampleInterval;</span><br><span class="line">    <span class="comment">//是否需要采样</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">AtomicBoolean</span> <span class="variable">mShouldSample</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StackSampler</span><span class="params">(<span class="type">long</span> sampleInterval)</span>&#123;</span><br><span class="line">        mSampleInterval = sampleInterval;</span><br><span class="line">        <span class="type">HandlerThread</span> <span class="variable">handlerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HandlerThread</span>(<span class="string">&quot;block-canary-sampler&quot;</span>);</span><br><span class="line">        handlerThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> <span class="title class_">Handler</span>(handlerThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始采样 执行堆栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">startDump</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//避免重复开始</span></span><br><span class="line">        <span class="keyword">if</span> (mShouldSample.get())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mShouldSample.set(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        mHandler.removeCallbacks(mRunnable);</span><br><span class="line">        mHandler.postDelayed(mRunnable,mSampleInterval);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stopDump</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mShouldSample.get())&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mShouldSample.set(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        mHandler.removeCallbacks(mRunnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getStacks</span><span class="params">(<span class="type">long</span> startTime,<span class="type">long</span> endTime)</span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">synchronized</span> (mStackMap)&#123;</span><br><span class="line">            <span class="keyword">for</span> (Long entryTime : mStackMap.keySet())&#123;</span><br><span class="line">                <span class="keyword">if</span> (startTime &lt; entryTime &amp;&amp; entryTime &lt; endTime)&#123;</span><br><span class="line">                    result.add(TIME_FORMATTER.format(entryTime)</span><br><span class="line">                            + SEPARATOR</span><br><span class="line">                            + SEPARATOR</span><br><span class="line">                            + mStackMap.get(entryTime));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Runnable</span> <span class="variable">mRunnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            StackTraceElement[] stackTrace = Looper.getMainLooper().getThread().getStackTrace();</span><br><span class="line">            <span class="keyword">for</span> (StackTraceElement s: stackTrace)&#123;</span><br><span class="line">                sb.append(s.toString()).append(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (mStackMap)&#123;</span><br><span class="line">                <span class="comment">//最多保存100条堆栈信息</span></span><br><span class="line">                <span class="keyword">if</span> (mStackMap.size() == mMaxCount)&#123;</span><br><span class="line">                    mStackMap.remove(mStackMap.keySet().iterator().next());</span><br><span class="line">                &#125;</span><br><span class="line">                mStackMap.put(System.currentTimeMillis(),sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mShouldSample.get())&#123;</span><br><span class="line">                mHandler.postDelayed(mRunnable,mSampleInterval);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用时在Application的onCreate()调用BlockCanary.install()即可。</p>
<p>其实这种方法也就是BlockCanary原理。</p>
<p>例如：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030175924056.png" alt="image-20221030175924056"></p>
<h4 id="Choregrapher-FrameCallback"><a href="#Choregrapher-FrameCallback" class="headerlink" title="Choregrapher.FrameCallback"></a>Choregrapher.FrameCallback</h4><blockquote>
<p>Android系统每隔16ms发出VSYNC信号，来通知界面进行重绘、渲染，每一次同步的周期约为16.6ms，代表一帧的刷新频率。通过Choreographer类设置它的FrameCallback，当每一帧被渲染时会触发回调FrameCallback.doFrame(long frameTimeNanos)函数。frameTimeNanos是底层VSYNC信号到达的时间戳。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChoreographerHelper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN)&#123;</span><br><span class="line">            Choreographer.getInstance().postFrameCallback(<span class="keyword">new</span> <span class="title class_">Choreographer</span>.FrameCallback() &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">lastFrameTimeNanos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFrame</span><span class="params">(<span class="type">long</span> frameTimeNanos)</span> &#123;</span><br><span class="line">                    <span class="comment">//上次回调的时间</span></span><br><span class="line">                    <span class="keyword">if</span> (lastFrameTimeNanos == <span class="number">0</span>)&#123;</span><br><span class="line">                        lastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">                        Choreographer.getInstance().postFrameCallback(<span class="built_in">this</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> (frameTimeNanos - lastFrameTimeNanos)/<span class="number">1_000_000</span>;</span><br><span class="line">                    <span class="keyword">if</span> (diff &gt; <span class="number">16.6f</span>)&#123;</span><br><span class="line">                        <span class="comment">//掉帧数</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">droppedCount</span> <span class="operator">=</span> (<span class="type">int</span>)(diff/<span class="number">16.6</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    lastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">                    Choreographer.getInstance().postFrameCallback(<span class="built_in">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过ChoreographerHelper可以实时计算帧率和掉帧率，实时检测App页面的帧率数据，发生帧率过低，还可以自动保存现场堆栈信息。</p>
<p>Looper比较适合在发布前进行测试或者小范围灰度测试然后定位问题，ChoreographerHelper适合监控线上环境的app的掉帧情况来计算app在某些场景的流畅度然后有针对性的做性能优化。</p>
<h2 id="布局优化"><a href="#布局优化" class="headerlink" title="布局优化"></a>布局优化</h2><h3 id="层级优化"><a href="#层级优化" class="headerlink" title="层级优化"></a>层级优化</h3><p>measure、layout、draw这三个过程都包含自顶向下的View Tree遍历耗时，如果视图层级太深自然需要更多的时间来完成整个绘测过程，从而造成启动速度慢、卡顿等问题。而onDraw在频繁刷新时可能多次出发，因此onDraw更不能做耗时操作，同时需要注意内存抖动。对于布局性能的检测，依然可以使用systrace与CPU Profiler按照绘制流程检查绘制耗时函数。</p>
<h3 id="Layout-Inspector"><a href="#Layout-Inspector" class="headerlink" title="Layout Inspector"></a>Layout Inspector</h3><p>视图层次结构的检测工具</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps10.jpg" alt="img"> </p>
<p>然后选择需要查看的进程与Activity后：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030180644284.png" alt="image-20221030180644284"></p>
<p>在左侧id为content之下的就是我们写在XML中的布局。可以明显看出，我们的布局中是一个LinearLayout,其中又包含两个LinearLayout。我们应该尽量减少其层级，可以使用ConstraintLayout约束布局使得布局尽量扁平化，移除非必需的UI组件。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030180704070.png" alt="image-20221030180704070"></p>
<h3 id="使用merge标签"><a href="#使用merge标签" class="headerlink" title="使用merge标签"></a>使用merge标签</h3><p>当我们有一些布局元素需要被多处使用时，这时候我们会考虑将其抽取成一个单独的布局文件。在需要使用的地方通过include加载。同时还能巧妙地减少布局层级。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030181233671.png" alt="image-20221030181233671"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030181217841.png" alt="image-20221030181217841"></p>
<p>这时候我们的主布局文件是垂直的LinearLayout，include的”layout_merge”也是垂直的LinearLayout，这时候include的布局中使用的LinearLayout就没意义了，使用的话反而减慢你的UI表现。这时可以使用merge标签优化。同时还达到了减少布局层级的目的。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030181327339.png" alt="image-20221030181327339"></p>
<p>修改为merge后，通过Layout Inspector能够发现，include的布局中TextView直接被加入到父布局中。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030182934087.png" alt="image-20221030182934087"></p>
<p><strong>merge标签使用注意点</strong>：</p>
<ol>
<li><p>根布局是FrameLayout且不需要设置background或padding等属性，可以用merge代替，因为Activity的ContentView父元素就是FrameLayout，所以可以用merge消除只剩一个。</p>
</li>
<li><p>因为merge标签并不是View，所以在通过LayoutInflate.inflate()方法渲染的时候，第二个参数必须指定一个父容器，且第三个参数必须为true，也就是merge下的视图指定一个父亲节点，由于merge不是View，所以对merge标签设置的所有属性都是无效的。</p>
</li>
</ol>
<h3 id="使用ViewStub标签"><a href="#使用ViewStub标签" class="headerlink" title="使用ViewStub标签"></a>使用ViewStub标签</h3><p>当我们布局中存在一个View&#x2F;ViewGroup，在某个特定时刻才需要他的展示时，你可能会把这个元素在xml中定义为invisible或者gone，在需要显示时再设置为visible可见。比如在登陆时，如果密码错误在密码输入框上显示提示。</p>
<blockquote>
<p>invisible</p>
<p>view设置为invisible，view在layout布局文件中会占用位置，但是view为不可见，该view还是会创建对象，会被初始化，会占用资源。</p>
<p>gone</p>
<p>view设置gone时，view在layout布局文件中不占用位置，但是该view还是会创建对象，会被初始化，会占用资源。</p>
</blockquote>
<p>如果view不一定会显示，此时可以使用ViewStub来包裹此View以避免不需要显示view但是又需要加载view消耗资源。</p>
<p>ViewStub是一个轻量级的view，它不可见，不用占用资源，只有设置viewstub为<code>visible</code>或者调用其<code>inflate()</code>方法时，其对应的布局文件才会被初始化。</p>
<ul>
<li><p>优点：实现View的延迟加载，避免资源的浪费，减少渲染的时间，在需要的时候才加载View</p>
</li>
<li><p>缺点：</p>
<ul>
<li><p>ViewStub所替代的layout文件不能有<code>&lt;merge&gt;</code>标签</p>
</li>
<li><p>ViewStub在加载完后会被移除，或者说是被加载进来的layout替换</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030183918391.png" alt="image-20221030183918391"></p>
<p>用ViewStub加载layout文件时，可以调用 <code>setVisibility()</code>或者 <code>inflate()</code></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030183940211.png" alt="image-20221030183940211"></p>
<p><strong>注意</strong>：</p>
<ul>
<li>一旦ViewStub visible&#x2F;inflated，则ViewStub将从视图框架中移除，其<code>id stub_import</code>也会失效</li>
<li>ViewStub被绘制完成的layout文件取代，并且该layout文件的root view的id是<code>android:inflatedId</code>指定的<code>id panel_import</code>，root view的布局和ViewStub视图的布局保持一致</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="过度渲染"><a href="#过度渲染" class="headerlink" title="过度渲染"></a>过度渲染</h2><blockquote>
<p>过度绘制是指系统在渲染单个帧的过程中多次在屏幕上绘制某一个像素。例如，如果我们有若干界面卡片堆叠在一起，每张卡片都会遮盖其下面一张卡片的部分内容。但是，系统仍然需要绘制堆叠中的卡片被遮盖的部分。</p>
</blockquote>
<h3 id="GPU过度绘制检查"><a href="#GPU过度绘制检查" class="headerlink" title="GPU过度绘制检查"></a>GPU过度绘制检查</h3><p>手机开发者选项中能够显示过度渲染检查功能，通过对界面进行彩色编码来帮我们识别过度绘制。开启步骤如下：</p>
<ol>
<li><p>进入开发者选项(Developer Options)</p>
</li>
<li><p>找到调试GPU过度绘制(Debug GPU overdraw)</p>
</li>
<li><p>在弹出的对话框中，选择显示过度绘制区域（Show overdraw areas）。</p>
<p>Android将按如下方式为界面元素着色，以确定过度绘制的次数：</p>
<ul>
<li>真彩色：没有过度绘制</li>
<li>蓝色：过度绘制1次</li>
<li>绿色：过度绘制2次</li>
<li>粉色：过度绘制3次</li>
<li>红色：过度绘制4次或更多次</li>
</ul>
</li>
</ol>
<p>在优化应用的界面时，应尝试达到大部分显示真彩色或仅有1次过度绘制（蓝色）的视觉效果。</p>
<h3 id="解决过度绘制问题"><a href="#解决过度绘制问题" class="headerlink" title="解决过度绘制问题"></a>解决过度绘制问题</h3><p>可以采取以下几种策略来减少甚至消除过度绘制</p>
<ul>
<li>移除布局中不需要的背景<ul>
<li>默认情况下，布局没有背景，这表示布局本身不会直接渲染任何内容。但是，当布局具有背景时，其有可能会导致过度绘制。</li>
<li>移除不必要的背景可以快速提高渲染的性能。不必要的背景可能永远不可见，因为它会被应用在该视图上绘制的其他内容完全覆盖。例如，当系统在父视图上绘制子视图，可能会完全覆盖父视图的背景。</li>
</ul>
</li>
<li>使视图层次结构扁平化<ul>
<li>可以通过优化视图层次结构来减少重叠界面对象的数量，从而提高性能。</li>
</ul>
</li>
<li>降低透明度<ul>
<li>对于不透明的View，只需要渲染一次即可把它显示出来。但是如果这个View设置了alpha值，则至少需要渲染两次。这是因为使用了alpha的View需要先知道混合View的下一层元素是什么，然后再结合上层的View进行Blend混色处理。透明动画、淡入淡出和阴影等效果都涉及到某种透明度，这就会造成了过度绘制。可以通过减少要渲染的透明对象的数量，来改善这些情况下的过度绘制。例如，如需获得灰色文本，可以在TextView中绘制黑色文本，再为其设置半透明的透明度值-&gt;但是，简单地通过绘制灰色文本也能获得同样的效果，而且能够大幅提升性能。</li>
</ul>
</li>
</ul>
<h2 id="布局加载优化"><a href="#布局加载优化" class="headerlink" title="布局加载优化"></a>布局加载优化</h2><h3 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h3><p>LayoutInflater加载xml布局的过程会在主线程使用IO读取XML布局文件进行XML解析，再根据解析结果利用反射创建布局中的View&#x2F;ViewGroup对象。这个过程随着布局的复杂度上升，耗时自然也会随之增大。Android为我们提供了Asynclayoutinflater把耗时的加载操作在异步线程中完成，最后把加载结果再回调给主线程。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies&#123;</span><br><span class="line">implementation<span class="string">&quot;androidx.asynclayoutinflater:asynclayoutinflater:1.0.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221030210116028.png" alt="image-20221030210116028"></p>
<ol>
<li><p>使用异步inflate，那么需要这个layout的parent的generateLayoutParams函数是线程安全的；</p>
</li>
<li><p>所有构建的View中必须不能创建Handler或者是调用Looper.myLooper；（因为是在异步线程中加载的，异步线程默认没有调用Looper.prepare）；</p>
</li>
<li><p>AsyncLayoutInflater不完全支持设置LayoutInflater.Factory或者LayoutInflater.Factory2；</p>
</li>
<li><p>不支持加载包含Fragment的layout;</p>
</li>
<li><p>如果AsyncLayoutInflater失败，那么会自动回退到UI线程来加载布局.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>Activity生命周期与启动模式</title>
    <url>/2022/10/01/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>今天，小编来聊一聊我们的“老朋友”Activity，我相信作为一个Android开发爱好者，Activity是大家最熟悉的和打交道最多的。今天，我们就来细解Activity的生命周期与启动模式，最后再来介绍一下Activity的最佳实践方式。</p>
</blockquote>
<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><h3 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h3><p>Android由任务（Task）来管理Activity，一个任务就是一组存放在栈里的Activity的集合，这个栈也被称为返回栈（back stack）。栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的Activity，他就会在返回栈中入栈，并处于栈顶的位置。而每当我们按下Back键或调用finish()方法去销毁一个Activity时，处于栈顶的Activity就会出栈，前一个入栈的Activity就会重新处于栈顶的位置。系统总是会显示处于栈顶的Activity给用户。</p>
<h3 id="Activity的状态"><a href="#Activity的状态" class="headerlink" title="Activity的状态"></a>Activity的状态</h3><p>每一个Activity在其生命周期中最多会有4种状态。</p>
<ol>
<li><p>运行状态</p>
<p>当一个Activity位于返回栈的顶部时，Activity就处于运行状态。系统最不愿意回收的就是处于运行状态的Activity，因为这回带来非常差的用户体验。</p>
</li>
<li><p>暂停状态</p>
<p>当一个Activity不处于栈顶位置，但仍然可见时，Activity就处于暂停状态。你可能会觉得，既然Activity已经不在栈顶了，怎么会可见呢？这是因为并不是每一个Activity都会占满整个屏幕，比如对话框形式的Activity只会占用屏幕中间的部分区域，处于暂停状态的Activity仍然是完全存活着的，系统不愿意回收这种Activity（因为它还是可见的，回收可见的东西都会在用户体验方面又不好的影响），只有在内存极低的情况下，系统才会去考虑回收这种Activity。</p>
</li>
<li><p>停止状态</p>
<p>当一个Activity不再处于栈顶位置，并且完全不可见的时候，就进入停止状态。系统仍然会为这种Activity保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于暂停状态的Activity有可能会被系统回收。</p>
</li>
<li><p>销毁状态</p>
<p>一个Activity从返回栈中移除后就变成了销毁状态。系统最倾向于回收处于这种状态的Activity，以保证手机的内存充足。</p>
</li>
</ol>
<h3 id="Activity的生存期"><a href="#Activity的生存期" class="headerlink" title="Activity的生存期"></a>Activity的生存期</h3><p>Activity的7个回调方法：</p>
<ul>
<li>onCreate()：它会在Activity第一次被创建的时候调用。你应该在这个方法中完成Activity的初始化操作，比如加载布局、绑定事件等。</li>
<li>onStart()：这个方法在Activity由不可见变为可见的时候调用。onStart()执行完成之后就可以与用户交互。</li>
<li>onResume()：这个方法在Activity准备好和用户进行交互的时候调用。此时的Activity一定位于返回栈的栈顶，并且处于运行状态。</li>
<li>onPause()：这个方法在系统准备去启动或者恢复另一个Activity的时候调用。我们通常会在这个方法中将一些消耗CPU的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶的Activity的使用。</li>
<li>onStop()：这个方法在Activity完全不可见的时候调用。它和onPause()方法的主要区别在于，如果启动的新Activity是一个对话框式的Activity，那么onPause()会得到执行，而onStop()方法并不会执行。</li>
<li>onDestroy()：这个方法在Activity被销毁之前调用，之后Activity的状态将变为销毁状态。</li>
<li>onRestart()：这个方法在Activity由停止状态变为运行状态之前调用，也就是Activity被重新启动了。</li>
</ul>
<p>以上7中方法，除了onRestart()方法，其他都是两两相对的，从而又可以将Activity分为以下3种生存期。</p>
<ul>
<li>完整生存期。Activity在onCreate()方法和onDestroy()方法之间所经历的就是完整生存期。一般情况下，一个Activity会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。</li>
<li>可见生存期。Activity在onStart()方法和onStop()方法之间所经历的就是可见生存期。在可见生存期内，Activity对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法合理地管理那些对用户可见的资源。比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的Activity不会占用过多内存。</li>
<li>前台生存期。Activity在onResume()方法和onPause()方法之间所经历的就是前台生存期。在前台生存期内，Activity总是处于运行状态，此时的Activity是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的Activity。</li>
</ul>
<p>官方提供的Activity生命周期图：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221001112220780.png" alt="image-20221001112220780"></p>
<h2 id="Activity启动模式"><a href="#Activity启动模式" class="headerlink" title="Activity启动模式"></a>Activity启动模式</h2><p>启动模式一共有4种，分别是standard、singleTop、singleTask和singleInstance，可以在AndroidManifest.xml中通过给<code>&lt;activity&gt;</code>标签指定android:launchMode属性来选择启动模式。</p>
<p>这里给大家推荐一个视频，真的很完美的诠释了启动模式，是由非常有名的GDE专家朱凯 凯哥的食谱……不，视频：</p>
<p><a href="https://www.bilibili.com/video/BV1CA41177Se/?spm_id_from=333.999.0.0">https://www.bilibili.com/video/BV1CA41177Se/?spm_id_from=333.999.0.0</a></p>
<p>因为，小编觉得视频已经讲得非常好了，所以，这里只对启动模式做一个简单的介绍与总结。</p>
<h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><p>standard是Activity默认的启动模式，在不进行显示指定的情况下，所有Activity都会自动使用这种Activity。Android是使用返回栈来管理Activity的，在standard模式下，每当启动一个新的Activity，它就会在返回栈中入栈，并处于栈顶的位置，对于使用standard模式的Activity，系统不会在乎这个Activity是否已经在返回栈中存在，每次启动都会创建一个该Activity的新实例。</p>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><p>可能在很多情况下，你会觉得standard模式不太合理。Activity明明已经在栈顶了，为什么再次启动的时候还要创建一个新的Activity实例呢？为了解决这种情况，singleTop启动模式就出现了。当Activity的启动模式指定为singleTop，在启动Activity时如果发现返回栈的栈顶已经是该Activity，则认为可以直接使用它，不会再创建新的Activity实例。可以认为singleTop是对standard一种优化。</p>
<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><p>使用singleTask模式可以很好地解决重复创建栈顶Activity的问题，但是如果该Activity没有处于栈顶的位置，还是会创建新的Activity实例。为了解决这一问题，singleTask出现了。当Activity的启动模式指定为singleTask，每次启动该Activity时，系统首次会返回栈中检查是否存在该Activity的实例，如果发现已经存在则直接使用该实例，并把这个Activity之上的所有其他Activity统统出栈，如果没有发现就会创建一个新的Activity实例。</p>
<p>当然，对于不同应用之间的跳转与启动模式的灵活应用，凯哥的视屏有更好的介绍。</p>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><p>singleInstance模式应该算是4种启动模式中最特殊也最复杂的一个了。不同于以上3种启动模式，指定为singleInstance模式的Activity会启动一个新的Activity来管理这个Activity（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈，所以由多少个返回栈和taskAffinity的数量有关）。那么这么做有什么意义呢？想象以下场景，假设我们的程序中有一个Activity是允许其他程序调用的，如果想实现其他程序和我们的程序可以共享这个Activity的实例，应该如何实现呢？使用前面3中启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个Activity在不同的返回栈中入栈时必然创建了新的实例。而使用singleInstance模式就可以解决这个问题，在这个情况下，会有一个单独的返回栈来管理这个Activity，不管是哪个应用程序来访问这个Activity，都共用同一个返回栈，也就解决了共享Activity实例的问题。</p>
<h2 id="Activity的最佳实践"><a href="#Activity的最佳实践" class="headerlink" title="Activity的最佳实践"></a>Activity的最佳实践</h2><blockquote>
<p>这里，小编介绍一个在项目中实用的Activity使用技巧。</p>
<p>这个技巧会教会你如何根据程序当前的界面就能判断出这是哪一个Activity。可能你会觉得挺纳闷的，我自己些的代码怎么会不知道这是哪个Activity呢？然而现实情况是，在你进入一个公司之后，更有可能的是接受一份别人的代码，因为你刚进公司就正好有一个新项目七佛那个的概率不高（很不幸，我就成了概率不高那部分）。阅读别人的代码时有一个头疼的问题，就是当你需要在某个界面上修改一些非常简单的东西时，却半天找不到这个界面对应的Activity是哪一个。</p>
</blockquote>
<ul>
<li><p>创建一个基类Activity——BaseActivity，作为项目中所有Activity的父类，值得注意的是，这是一个普通类，不需要注册.</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseActivity</span>: <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        ActivityCollector.addActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        ActivityCollector.removeActivity(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>如果你的项目中又多个Activity，跳转之后再推出会非常不方便，按Home键只是把程序挂起，并没有退出程序。那么有没有一种方法可以实现注销或推出的功能呢？就像我们的QQ在同类设备上登录被强制退出那样。（当然，我们今天没有完全实现那种功能，如果要实现还需要用到广播，下期小编就来回味广播）</p>
<p>其实解决思路很简单，只需要用一个专门的集合对所有的Activity进行管理就可以了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ActivityCollector &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> activities = ArrayList&lt;Activity&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        activities.add(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">removeActivity</span><span class="params">(activity: <span class="type">Activity</span>)</span></span>&#123;</span><br><span class="line">        activities.remove(activity)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">finishAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (activity <span class="keyword">in</span> activities)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!activity.isFinishing)&#123;</span><br><span class="line">                activity.finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        activities.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了单例类，是因为全局只需要一个Activity集合。在集合中，我们通过一个ArrayList来暂存Activity，然后提供了一个addActivity()方法，用于向ArrayList中添加Activity；提供了一个removeActivity()方法，用于从ArrayList中移除Activity；最后提供了一个finishAll()方法，用于将ArrayList中存储的Activity全部销毁。注意在销毁Activity之前，我们需要先调用activity.isFinishing来判断Activity是否正在销毁中，因为Activity还可能通过按下Back键等方式销毁，如果该Activity没有正在销毁中，我们再去调用它的finish()方法来销毁它。</p>
</li>
</ul>
<h3 id="启动Activity的最佳写法"><a href="#启动Activity的最佳写法" class="headerlink" title="启动Activity的最佳写法"></a>启动Activity的最佳写法</h3><blockquote>
<p>有这样一种情况，比如某个Activity（暂且叫做SecondActivity）不是你开发的，但是你负责开发的部分需要启动SecondActivity，而你不清楚启动SecondActivity需要传递那些数据。这时无非就有两种方法：一个是你自己去阅读SecondActivity中的代码，另一个是去访问负责编写SecondActivtiy的同事。你会不会觉得很麻烦呢？其实只需要换一种写法，就可以轻松解决问题。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondActivity</span>:<span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">actionStart</span><span class="params">(context: <span class="type">Context</span>,data1:<span class="type">String</span>,data2:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(context,SecondActivity::<span class="keyword">class</span>.java)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;param1&quot;</span>,data1)</span><br><span class="line">            intent.putExtra(<span class="string">&quot;param2&quot;</span>,data2)</span><br><span class="line">            context.startActivity(intent)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用时：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SecondActivity.actionStart(<span class="keyword">this</span>,<span class="string">&quot;data1&quot;</span>,<span class="string">&quot;data2&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样，即使不用阅读SecondActivity的代码，不去询问负责编写SecondActivity的同事，你也可以非常清晰地直到启动SecondActivity需要传递哪些数据。另外，这样写还简化了启动Activity的代码，只需要一行代码就可以启动SecondActivity。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章主要是对Activity的生命周期和启动模式进行回顾，毕竟有些细节很久不接触就容易忘记。</p>
<p>最后还介绍了Activity实践中的技巧，养成良好的编程习惯，会使我们的效率事半功倍。</p>
<p>参考：《第一行代码》</p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Android APP启动优化</title>
    <url>/2022/10/30/Android%20APP%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="启动状态"><a href="#启动状态" class="headerlink" title="启动状态"></a>启动状态</h2><p>应用有三种启动状态，每种状态都会影响应用向用户显示所需的时间；冷启动、温启动和热启动。在冷启动中，应用从头开始启动。在另外两种状态中，系统需要将后台的应用带入前台。建议始终在假定冷启动的基础上进行优化。这样做也可以提升温启动和热启动的性能。</p>
<ul>
<li>冷启动<ul>
<li>冷启动是指应用从头开始启动；系统进程在冷启动后才创建应用进程。发生冷启动的情况包括自设备启动后或系统终止应用后首次启动。</li>
</ul>
</li>
<li>热启动<ul>
<li>在热启动中，系统的所有工作就是将Activity带到前台。只有应用的所有Activity仍驻留在内存中，应用就不必重复执行对象初始化、布局加载和绘制。</li>
</ul>
</li>
<li>温启动<ul>
<li>温启动包含了在冷启动期间发生的部分操作；同时，它的开销要比热启动高。有潜在状态可视为温启动。例如：<ul>
<li>用户在退出应用后又重新启动应用。进程可能未被销毁，继续运行，但应用需要执行<code>onCreate()</code>从头开始创建Activity。</li>
<li>系统将应用从内存释放，然后用户又重新启动它。进程和Activity需要重新启动，但传递到<code>onCreate()</code>的已保存的实例<code>state bundle</code>对于完成此任务有一定助益。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="冷启动耗时统计"><a href="#冷启动耗时统计" class="headerlink" title="冷启动耗时统计"></a>冷启动耗时统计</h2><p>在性能测试中存在启动时间2-5-8原则：</p>
<ul>
<li><p>当用户能够在2秒以内得到响应时，会感觉系统的响应很快；</p>
</li>
<li><p>当用户在2-5秒之间得到响应时，会感觉系统的响应速度还可以；</p>
</li>
<li><p>当用户在5-8秒以内得到响应时，会感觉系统的响应速度很慢，但是还可以承受；</p>
</li>
<li><p>而当用户在超过8秒后仍然无法得到响应时，会感觉系统糟糕透了，或者认为系统已经失去响应。</p>
</li>
</ul>
<p>实际上不同的应用因为启动时需要初始化的数据不同，启动时间自然也会不同。相同的应用也会因为在不同的设备，因为设备影响性能启动速度不同。所以实际上启动时间并没有绝对统一的标准，我们之所以需要进行启动耗时的统计，可能在于产品对我们应用启动时间提出具体的要求。</p>
<h4 id="系统日志统计"><a href="#系统日志统计" class="headerlink" title="系统日志统计"></a>系统日志统计</h4><p>在 Android 4.4（API 级别 19）及更高版本中，logcat 包含一个输出行，其中包含名为 <code>Displayed </code>的值。此值代表从启动进程到在屏幕上完成对应 Activity 的绘制所用的时间。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps1.jpg" alt="img"> </p>
<p>如果我们使用异步懒加载的方式来提升程序画面的显示速度，这通常会导致的一个问题是，程序画面已经显示，同时 Displayed 日志已经打印，可是内容却还在加载中。为了衡量这些异步加载资源所耗费的时间，我们可以在异 步加载完毕之后调用<code>activity.reportFullyDrawn() </code>方法来让系统打印到调用此方法为止的启动耗时。</p>
<h4 id="adb命令统计"><a href="#adb命令统计" class="headerlink" title="adb命令统计"></a>adb命令统计</h4><p>查看启动时间的另一种方式是使用命令：</p>
<p><strong>adb shell am start –s –w [应用启动入口]</strong></p>
<p>启动完成之后将输出</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps2.jpg" alt="img"> </p>
<ul>
<li><p>WaitTime:总的耗时，包括前一个应用Activity pause的时间和新应用启动的时间；</p>
</li>
<li><p>ThisTime：表示一连串启动Activity的最后一个Activity的启动耗时；</p>
</li>
<li><p>TotalTime：表示新应用启动的耗时，包括新进程的启动和Activity的启动，但不包括前一个应用Activity pause的耗时</p>
</li>
</ul>
<p><strong>开发者一般只要关心TotalTime即可，这个时间才是自己应用真正启动的耗时。</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps3.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps4.jpg" alt="img"></p>
<h2 id="CPU-Profile-x2F-TraceView"><a href="#CPU-Profile-x2F-TraceView" class="headerlink" title="CPU Profile&#x2F;TraceView"></a>CPU Profile&#x2F;TraceView</h2><p>如果发现显示时间比希望的时间长，则可以继续尝试识别启动过程中的瓶颈。 查找瓶颈的一个好方法是使用 Android Studio CPU 性能剖析器。</p>
<p><strong>目前Traceview 已弃用。如果使用 Android Studio 3.2 或更高版本，则应改为使用 CPU Profile</strong></p>
<p>要在应用启动过程中自动开始记录 CPU 活动，请执行以下操作：</p>
<ol>
<li>依次选择 Run &gt; Edit Configurations。</li>
</ol>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps5.jpg" alt="img"> </p>
<ol start="2">
<li>在 Profiling 标签中，勾选 Start recording CPU activity on startup 旁边的复选框。</li>
</ol>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps6.jpg" alt="img"></p>
<ol start="3">
<li><p>从菜单中选择 CPU 记录配置。</p>
<p><strong>Sample Java Methods</strong></p>
<p>对 Java 方法采样：在应用的 Java 代码执行期间，频繁捕获应用的调用堆栈。分析器会比较捕获的数据集，以推导与应用的 Java 代码执行有关的时间和资源使用信息。如果应用在捕获调用堆栈后进入一个方法并在下 次捕获前退出该方法，分析器将不会记录该方法调用。如果您想要跟踪生命周期如此短的方法，应使用检测跟踪。</p>
<p><strong>Trace Java Methods</strong></p>
<p>跟踪 Java 方法：在运行时检测应用，以在每个方法调用开始和结束时记录一个时间戳。系统会收集并比较这 些时间戳，以生成方法跟踪数据，包括时间信息和CPU使用率。</p>
<p><strong>Sample C&#x2F;C++ Functions</strong></p>
<p>对 C&#x2F;C++ 函数采样：捕获应用的原生线程的采样跟踪数据。要使用此配置，您必须将应用部署到搭载 Android 8.0（API 级别 26）或更高版本的设备上。</p>
<p><strong>Trace System Calls</strong></p>
<p>跟踪系统调用：捕获非常翔实的细节，以便您检查应用与系统资源的交互情况。您可以检查线程状态的确切 时间和持续时间、直观地查看所有内核的 CPU 瓶颈在何处，并添加要分析的自定义跟踪事件。要使用此配置，您必须将应用部署到搭载 Android 7.0（API 级别 24）或更高版本的设备上。</p>
<p>此跟踪配置在 systrace 的基础上构建而成。您可以使用 systrace 命令行实用程序指定除 CPU Profiler 提供的 选项之外的其他选项。systrace 提供的其他系统级数据可帮助您检查原生系统进程并排查丢帧或帧延迟问题。</p>
</li>
<li><p>点击 Apply。</p>
</li>
<li><p>依次选择 Run &gt; Profile，将您的应用部署到搭载 Android 8.0（API 级别 26）或更高版本的设备上。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>点击Stop，结束跟踪后显示：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps8.jpg" alt="img"></p>
</li>
</ol>
<h3 id="Call-Chart"><a href="#Call-Chart" class="headerlink" title="Call Chart"></a>Call Chart</h3><p>以图形来呈现方法跟踪数据或函数跟踪数据，其中调用的时间段和时间在横轴上表示，而其被调用方则在纵轴上显 示。对系统 API 的调用显示为橙色，对应用自有方法的调用显示为绿色，对第三方API包括Java语言API）的调 用显示为蓝色。（实际颜色显示有Bug）</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps9.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps10.jpg" alt="img"> </p>
<p>如上图，自定义Application的 onCreate 调用了 Thread.sleep 耗时为：3s。</p>
<p>Call Chart 已经比原数据可读性高很多，但它仍然不方便发现那些运行时间很长的代码，这时我们便需要使用 Flame Chart。</p>
<h3 id="Flame-Chart"><a href="#Flame-Chart" class="headerlink" title="Flame Chart"></a>Flame Chart</h3><p>提供一个倒置的调用图表，用来汇总完全相同的调用堆栈。也就是说，将具有相同调用方顺序的完全相同的方法或 函数收集起来，并在火焰图中将它们表示为一个较长的横条 。</p>
<p>横轴显示的是百分比数值。由于忽略了时间线信息，Flame Chart 可以展示每次调用消耗时间占用整个记录时长的 百分比。 同时纵轴也被对调了，在顶部展示的是被调用者，底部展示的是调用者。此时的图表看起来越往上越窄，就好像火焰一样，因此得名: <strong>火焰图</strong>。（说白了就是将Call Chart上下调用栈倒过来。）</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps11.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps12.jpg" alt="img"> </p>
<p>耗时最长的为：Thread.sleep</p>
<h3 id="Top-Down-Treee"><a href="#Top-Down-Treee" class="headerlink" title="Top Down Treee"></a>Top Down Treee</h3><p>如果我们需要更精确的时间信息，就需要使用 Top Down Tree。Top Down Tree显示一个调用列表，在该列表中展开方法或函数节点会显示它调用了的方法节点。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps13.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps14.jpg" alt="img"> </p>
<p>对于每个节点，三个时间信息:</p>
<ul>
<li><p>Self Time —— 运行自己的代码所消耗的时间；</p>
</li>
<li><p>Children Time —— 调用其他方法的时间；</p>
</li>
<li><p>Total Time —— 前面两者时间之和。</p>
</li>
</ul>
<p>此视图能够非常方便看到耗时最长的方法调用栈。</p>
<h3 id="Bottom-Up-Tree"><a href="#Bottom-Up-Tree" class="headerlink" title="Bottom Up Tree"></a>Bottom Up Tree</h3><p>方便地找到某个方法的调用栈。在该列表中展开方法或函数节点会显示哪个方法调用了自己。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps15.jpg" alt="img"> </p>
<p>通过工具可以定位到耗时代码，然后查看是否可以进行优化。对于APP启动来说，启动耗时包括Android系统启动 APP进程加上APP启动界面的耗时时长，我们可做的优化是APP启动界面的耗时，也就是说从Application的构建到主界面的 onWindowFocusChanged 的这一段时间。</p>
<p>因此在这段时间内，我们的代码需要尽量避免耗时操作，检查的方向包括：主线程IO；第三方库初始化或程序需要 使用的数据等初始化改为异步加载&#x2F;懒加载；减少布局复杂度与嵌套层级；Multidex(5.0以上无需考虑)等。</p>
<h3 id="Debug-API"><a href="#Debug-API" class="headerlink" title="Debug API"></a>Debug API</h3><p>除了直接使用 Profile 启动之外，我们还可以借助Debug API生成trace文件。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps16.jpg" alt="img"> </p>
<p>运行App，则会在sdcard中生成一个enjoy.trace文件（需要sdcard读写权限）。将手机中的trace文件保存至电脑，随后拖入Android Studio即可。</p>
<h2 id="StrictMode-严苛模式"><a href="#StrictMode-严苛模式" class="headerlink" title="StrictMode 严苛模式"></a>StrictMode 严苛模式</h2><p>StrictMode是一个开发人员工具，它可以检测出我们可能无意中做的事情，并提示我们注意，以便我们能够修复它们。</p>
<p>StrictMode最常用于捕获应用程序主线程上的意外磁盘或网络访问。帮助我们让磁盘和网络操作远离主线程，可以使应用程序更加平滑、响应更快。</p>
<p>使用StrictMode一般定义在Application中，实现全局检测。严苛模式的启动同样也是耗时的，所以应限制其在debug模式下才能运行。</p>
<p><strong>线程策略检测</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps17.jpg" alt="img"> </p>
<p><strong>VM策略检测</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps18.jpg" alt="img"> </p>
<p><strong>触发违规的表现方式</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps19.jpg" alt="img"></p>
<h2 id="启动黑白屏"><a href="#启动黑白屏" class="headerlink" title="启动黑白屏"></a>启动黑白屏</h2><p>当系统加载并启动APP时，需要耗费相应的时间，这样会造成用户会感觉到当点击APP图标时会有“延迟”现象，为了解决这一问题，Google的做法实在APP创建的过程中，先展示一个空白页面，让用户体会到点击图标之后立马就有响应（如QQ、微信在重新启动时都会有一个数据准备的过度页面，其实那不是引导页）。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps20.jpg" alt="img"> </p>
<p>如果你的application或activity启动的过程太慢，导致系统的BackgroundWindow没有及时被替换，就会出现启动时白屏或黑屏的情况（取决于Theme主题是Dark还是Light）。</p>
<p>消除启动时的黑&#x2F;白屏问题，大部分APP都采用自己在Theme中设置背景图的方式来解决。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps22.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps22.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps23.jpg" alt="img"> </p>
<p>然后在Activity的onCreate方法，把Activity设置回原来的主题。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps24.jpg" alt="img"> </p>
<p>这么做，只是提高启动的用户体验。并不能做到真正的加快启动速度。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>Android广播机制</title>
    <url>/2022/10/05/Android%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>就像计算机网络中的广播一样，我们的Android中也存在类似的广播机制，并且Android中的广播机制更加灵活。</p>
</blockquote>
<hr>
<h2 id="广播机制简介"><a href="#广播机制简介" class="headerlink" title="广播机制简介"></a>广播机制简介</h2><blockquote>
<p>Android中的每个应用程序都可以对自己感兴趣的广播进行注册，这样改程序就只会收到自己关心的广播内容，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。Android提供了一套完整的API，允许应用程序自由地发送和接收广播。发送广播的方式就是我们熟知的Intent，而接收广播的主角就是四大组件之一的BroadcastReceiver。</p>
<p>Android内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到各种系统的状态信息。比如手机开机完成后会发出一条广播，电池的电量变化会发出一条广播，系统时间发生改变也会发出一条广播，等等。</p>
</blockquote>
<p>广播主要有两种类型</p>
<ul>
<li>标准广播：一种完全异步执行的广播，在发送广播之后，所有的BroadcastReceiver几乎会在同一时刻收到这条广播信息，因此它们之间没有任何先后顺序可言。</li>
<li>有序广播：一种同步执行的广播，在广播发出之后，同一时刻只会有一个BroadcastReceiver能够收到这条广播信息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的BroadcastReceiver是又先后顺序的，优先极高的BroadcastReceiver就可以先收到广播信息，并且前面的BroadcastReceiver还可以截断正在传递的广播，使后面的BroadcastReceiver无法收到这条广播。</li>
</ul>
<hr>
<h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><h3 id="动态注册方式监听广播"><a href="#动态注册方式监听广播" class="headerlink" title="动态注册方式监听广播"></a>动态注册方式监听广播</h3><p>我们可以根据自己感兴趣的广播，自由注册BroadcastReceiver，这样当有相应的广播发出时，相应的BroadcastReceiver就能够收到该广播，并可以在内部进行逻辑处理。注册BroadcastReceiver的方式一般有两种：在代码中注册和在<code>AndroidManifest.xml</code>中注册。其中前者也被成为动态注册，后者也被成为静态注册。</p>
<p><strong>BroadcastReceiver的创建：</strong></p>
<blockquote>
<p>只需要创建一个类继承自BroadcastReceiver并重写onReceive()方法就行。这样当有广播到来时，onReceive()方法就会得到执行，具体的逻辑就可以在这个方法中处理。下面，我来演示一下</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">BaseActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding:ActivityMainBinding</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> timeChangeReceiver: TimeChangeReceiver</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> intentFilter = IntentFilter()</span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.intent.action.TIME_TICK&quot;</span>)</span><br><span class="line">        timeChangeReceiver = TimeChangeReceiver()</span><br><span class="line">        registerReceiver(timeChangeReceiver,intentFilter)</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">        unregisterReceiver(timeChangeReceiver)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">inner</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeChangeReceiver</span>:<span class="type">BroadcastReceiver</span></span>()&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>?, intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">            Toast.makeText(context,<span class="string">&quot;Time has changed&quot;</span>,Toast.LENGTH_LONG).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>首先，我们在MainActivity中定义了一个内部类，并使其继承自BroadcastReceiver，onReceive()里面是简单的打印信息</li>
<li>onCreate()方法中，我们创建了一个IntentFilter实例，并添加了一个值为android.intent.action.TIME_TICK的action，这个action是系统提供的，时间发生变化系统就会发送这条广播</li>
<li>调用registerReceiver()方法进行注册，将TImeChangeReceiver()的实例和IntentFilter()的实例传进去，这样就实现了监听时间变化的功能</li>
<li>最后一定要记得取消注册，否则将带来内存泄漏的风险。</li>
</ul>
<h3 id="静态注册方式监听广播"><a href="#静态注册方式监听广播" class="headerlink" title="静态注册方式监听广播"></a>静态注册方式监听广播</h3><p>动态的BroadcastReceiver可以自由地控制注册和注销，在灵活性方面有很大优势。但是它存在一个缺点，即必须在程序启动之后才能接受广播，因为注册的逻辑是卸载onCreate()方法中的。那么有什么方法可以让程序在未启动的情况下也能接受广播呢？这就需要使用静态注册的方式了。</p>
<p>理论上讲，动态注册能监听到的系统广播，静态注册也能监听到，再过去的Android系统中确实是这样的。但是由于大量恶意的应用程序利用这个机制在程序未启动的情况下监听系统广播，因此Android系统几乎每个版本都在削弱静态注册BroadcastReceiver的功能。</p>
<p>在Android8.0之后，所有隐式广播都不允许使用静态注册的方式接收了。<strong>隐式广播指的是哪些没有具体指定发送给哪个应用程序的广播</strong>，大多数系统广播属于隐式广播，但是少数特殊的系统广播目前仍然允许使用静态注册的方式接收。详情见：<a href="https://developer.android.google.cn/guide/components/broadcast-exceptions.html">https://developer.android.google.cn/guide/components/broadcast-exceptions.html</a></p>
<p>这些特殊广播中有一条非常值得关注的是android.intent.action.BOOT_COMPLETED的广播，这是一条开机广播。</p>
<p>接下来我们来实操一下，要在开机后做一些事：</p>
<ul>
<li>首先按如下方式创建一个BroadcastReceiver，右键New-&gt;Other-&gt;Broadcast Receiver，这样的好处是我们不用再手动在<code>AndroidManifest.xml</code>注册BroadcastReceiver</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221012115440320.png" alt="image-20221012115440320"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BootCompleteReceiver</span> : <span class="type">BroadcastReceiver</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onReceive</span><span class="params">(context: <span class="type">Context</span>, intent: <span class="type">Intent</span>)</span></span> &#123;</span><br><span class="line">        Toast.makeText(context,<span class="string">&quot;Boot Complete&quot;</span>,Toast.LENGTH_LONG).show()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AndroidManifest.xml中</p>
<ul>
<li><p>添加权限声明</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<receiver>标签中又添加了一个<intent-filter>标签，并在里面声明了相应的action</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>到此，我们就实现了静态监听广播，我这里只是做了个简单的打印，你可以在你的项目中做自己的逻辑。</p>
<p>注意：不要再<code>onReceive()</code>方法中做过多的逻辑或者任何耗时的操作，因为BroadcastReceiver中是不允许开启线程的，当<code>onReceive()</code>方法运行了较长时间而没有结束时，程序就会出现错误。</p>
<hr>
<h2 id="发送自定义广播"><a href="#发送自定义广播" class="headerlink" title="发送自定义广播"></a>发送自定义广播</h2><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><ol>
<li><p>首先需要一个BroadcastReceiver，这里就不在放代码了，前面提过很多次了。</p>
</li>
<li><p>在<code>AndroidManifest.xml</code>的<receiver>中添加如下信息</p>
<p>com.example.broadcast.MY_BROADCAST是一会儿自定义的广播，可以看到我的格式是模拟系统的广播，可以自己任意命名</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;.MyBroadcastReceiver&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;com.example.broadcast.MY_BROADCAST&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>&#96;&#96;&#96;kotlin<br>class MainActivity : BaseActivity() {<br>lateinit var binding:ActivityMainBinding<br><br>override fun onCreate(savedInstanceState: Bundle?) {<br>    super.onCreate(savedInstanceState)<br>    binding &#x3D; ActivityMainBinding.inflate(layoutInflater)<br>    setContentView(binding.root)<br><br><br>    binding.startActivityBtn.setOnClickListener {<br>        SecondActivity.actionStart(this,”data1”,”data2”)<br>    }<br>    binding.sendBroadcast.setOnClickListener {<br>        val intent &#x3D; Intent(“com.example.broadcast.MY_BROADCAST”)<br>        intent.setPackage(packageName)<br>        sendBroadcast(intent)<br>    }<br>}<br><br>override fun onDestroy() {<br>    super.onDestroy()<br>}<br>}</p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   &gt; - 创建一个Intent对象，并把要发送的广播的值传入</span><br><span class="line">   &gt; - 然后调用Intent的`setPackage()`方法，并传入当前应用程序的包名。`packageName`是`getPackageName()`的语法糖写法。</span><br><span class="line">   &gt; - Android8.<span class="number">0</span>之后，静态注册的BroadcastReceiver是无法接收隐式广播的，而默认情况下我们发出的自定义广播恰恰都是隐式广播。因此这里一定要调用`setPackage()`方法，指定这条广播发送给哪个应用程序，从而把它编程一条显示广播。</span><br><span class="line">   &gt; - 最后调用`sendBroadcast()`方法将广播发送出去</span><br><span class="line">   </span><br><span class="line">   这样，我们的自定义广播的步骤就完成了。</span><br><span class="line">   </span><br><span class="line">   另外，由于广播是使用Intent来发送的，因此我们可以在Intent值中携带一些数据传递给相应的BroadcastReceiver，这一点和Activity的用法是比较相似的。</span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 发送有序广播</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<p>sendOrderedBroadcast(intent,null)</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">发送有序广播只需要该一行代码即可，即将`send<span class="constructor">Broadcast()</span>`方法改成send<span class="constructor">OrderedBroadcast()</span>方法。send<span class="constructor">OrderedBroadcast()</span>方法接收两个参数：第一个参数仍然是Intent；第二个参数是一个与权限相关的字符串，这里传入null就行了。</span><br><span class="line"></span><br><span class="line">还没结束，有序广播最大的好处就是按顺序接收，那么如何确定接收顺序呢？</span><br><span class="line"></span><br><span class="line">- 设置权重：</span><br><span class="line"></span><br><span class="line">  `priority`的值越高，优先级越高。</span><br><span class="line"></span><br><span class="line">  !<span class="literal">[<span class="identifier">image</span>-<span class="number">20221012144015349</span>]</span>(https:<span class="comment">//banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221012144015349.png)</span></span><br><span class="line"></span><br><span class="line">- 截断广播</span><br><span class="line"></span><br><span class="line">  可以在优先级高的BroadcastReceiver中截断这条，使后面的BroadcastReceiver都接收不到这条广播。</span><br><span class="line"></span><br><span class="line">  !<span class="literal">[<span class="identifier">image</span>-<span class="number">20221012144112193</span>]</span>(https:<span class="comment">//banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221012144112193.png)</span></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 广播的最佳实践：实现强制下线功能</span><br><span class="line"></span><br><span class="line">&gt; 强制下线应该算是一个比较常见的功能，比如如果你的QQ号在别处登录了，就会将你强制挤下线。其实实现强制下线功能的思路比较简单，只需要在界面上弹出一个对话框，让用户无法进行任何其他操作，必须点击对话框的“确定”按钮，然后回到登录界面即可。可是这样就会存在一个问题：当用户被通知需要强制下线时，可能正处于任何一个界面，难道需要在每个界面上都编写弹出对话框的逻辑？那当然不是，且听我娓娓道来。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 强制下线功能需要先关闭所有Activity，然后回到登录界面。这部分大家应该很熟悉，没错，就是我前面在介绍Activity的声明周期时提到的一套实践方法，详情见<span class="literal">[A<span class="identifier">ctivity</span>声明周期和启动模式]</span>(http:<span class="comment">//banmaman.com/2022/10/01/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%8E%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/)，下面小编来贴上核心代码和讲解。</span></span><br><span class="line"></span><br><span class="line">核心代码：</span><br><span class="line"></span><br><span class="line">```kotlin</span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> BaseActivity: <span class="constructor">AppCompatActivity()</span> &#123;</span><br><span class="line">    lateinit var receiver:ForceOfflineReceiver</span><br><span class="line">    override <span class="keyword">fun</span> on<span class="constructor">Create(<span class="params">savedInstanceState</span>: Bundle?)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Create(<span class="params">savedInstanceState</span>)</span></span><br><span class="line">        set<span class="constructor">ContentView(R.<span class="params">layout</span>.<span class="params">activity_main</span>)</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ActivityCollector</span>.</span></span>add<span class="constructor">Activity(<span class="params">this</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override <span class="keyword">fun</span> on<span class="constructor">Resume()</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Resume()</span></span><br><span class="line">        <span class="keyword">val</span> intentFilter = <span class="constructor">IntentFilter()</span></span><br><span class="line">        <span class="comment">//com.example.broadcastpractice.FORCE_OFFLINE为自定义下线广播</span></span><br><span class="line">        intentFilter.add<span class="constructor">Action(<span class="string">&quot;com.example.broadcastpractice.FORCE_OFFLINE&quot;</span>)</span></span><br><span class="line">        receiver = <span class="constructor">ForceOfflineReceiver()</span></span><br><span class="line">        register<span class="constructor">Receiver(<span class="params">receiver</span>,<span class="params">intentFilter</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override <span class="keyword">fun</span> on<span class="constructor">Pause()</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Pause()</span></span><br><span class="line">        unregister<span class="constructor">Receiver(<span class="params">receiver</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override <span class="keyword">fun</span> on<span class="constructor">Destroy()</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Destroy()</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ActivityCollector</span>.</span></span>remove<span class="constructor">Activity(<span class="params">this</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">    inner <span class="keyword">class</span> ForceOfflineReceiver:<span class="constructor">BroadcastReceiver()</span>&#123;</span><br><span class="line">        override <span class="keyword">fun</span> on<span class="constructor">Receive(<span class="params">context</span>: Context, <span class="params">intent</span>: Intent?)</span> &#123;</span><br><span class="line">            AlertDialog.<span class="constructor">Builder(<span class="params">context</span>)</span>.apply &#123; </span><br><span class="line">                set<span class="constructor">Title(<span class="string">&quot;Warning&quot;</span>)</span></span><br><span class="line">                set<span class="constructor">Message(<span class="string">&quot;You are forced to be offline.Please try to login again.&quot;</span>)</span></span><br><span class="line">                set<span class="constructor">Cancelable(<span class="params">false</span>)</span></span><br><span class="line">                set<span class="constructor">PositiveButton(<span class="string">&quot;OK&quot;</span>)</span>&#123;_,_-&gt;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ActivityCollector</span>.</span></span>finish<span class="constructor">All()</span><span class="comment">//销毁所有Activity</span></span><br><span class="line">                    <span class="keyword">val</span> intent = <span class="constructor">Intent(<span class="params">context</span>,LoginActivity::<span class="params">class</span>.<span class="params">java</span>)</span></span><br><span class="line">                    context.start<span class="constructor">Activity(<span class="params">intent</span>)</span><span class="comment">//重新启动LoginActivity</span></span><br><span class="line">                &#125;</span><br><span class="line">                show<span class="literal">()</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>只要触发机制发送一条值为<code>com.example.broadcastpractice.FORCE_OFFLINE</code>的广播，这条广播就是用于通知程序强制用户下线的，也就是说，强制用户下线的逻辑并不是写在MainActivity里，而是应该写在接收这条广播的BroadcastReceiver里。这样强制下线的功能就不会依附于任何界面了，不管是在程序的任何地方，只要发出这样的广播，就可以完成强制下线的操作。</li>
<li>由于BroadcastReceiver中需要弹出一个对话框来阻塞用户的正常操作，但如果创建的是一个静态注册的BroadcastReceiver，是没有办法在onReceive()方法里弹出对话框这样的UI控件（弹窗依附于Activity），而我们显然不可能在每个Activity中都注册一个动态的BroadcastReceiver。怎么办？很简单——只需要在BaseActivity中动态注册一个BroadcastReceiver即可，毕竟此程序中所有的Activity都继承自BaseActivtiy。</li>
<li>在ForceOfflineReceiver中：<ul>
<li>首先是使用<code> AlertDialog.Builder</code>构建一个对话框。注意，这里一定要调用setCancelable()方法将对话框设置为不可取消，否则用户按一下Back按钮就可以关闭对话框继续使用程序了</li>
<li>使用setPositiveButton()方法给对话框注册确定按钮，当用户点击了“OK”按钮时，就调用<code>ActivityCollector</code>的<code>finishAll()</code>方法销毁所有的Activity，并重新启动<code>LoginActivity</code>。</li>
</ul>
</li>
<li>再来看看ForceOfflineReceiver这个BroadcastReceiver的注册：<ul>
<li>分别在onResume()和onPause()这两个声明周期方法中完成注册和注销</li>
<li>为什么不在onDestroy()中注销呢？因为我们始终需要保证只有处于栈顶的Activity才能收到这条下线广播，产生弹窗。如果其他Activity都能弹窗，那么岂不是做了无用功！</li>
</ul>
</li>
<li>当然还需要配置的是，在<code>AndroidManifest.xml</code>中将LoginActivity设置为主Activity，因为你不可能不登录就进入程序主页面吧？</li>
</ul>
<p>参考资料：《第一行代码》</p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Android运行时权限</title>
    <url>/2022/09/13/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们在应用开发中如果需要联网就需要在<code>AndroidManifest.xml</code>文件中添加网络访问权限。在我们新安装应用时，往往会弹出提示框问我们是否允许系统获取定位、读取联系人、读取短信等权限。那这些权限有什么用？区别是什么？为什么会有运行时权限这一说法……下面让小编来一一梳理并解答。</p>
<h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><blockquote>
<p> Android的权限机制并不是什么新鲜事物，从系统的第一个版本开始就已经存在了。但其实之前Android的权限机制在保护安全和隐私等方面起到的作用十分有限，尤其是一些大家离不开的常用软件，非常容易“店大欺客”。为此，Android开发团队在Android6.0系统中引入了运行时权限这个功能，从而更好地保护了用户的安全和隐私。</p>
</blockquote>
<h2 id="Android权限机制详解"><a href="#Android权限机制详解" class="headerlink" title="Android权限机制详解"></a>Android权限机制详解</h2><p>如下，监听开机广播需要开启广播接收的权限：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220913165504245.png" alt="image-20220913165504245"></p>
<p>因为监听开机广播涉及了用户设备的安全，因此必须在<code>AndroidManifest.xml</code>文件中加入权限声明，否则我们的程序就会崩溃。</p>
<p>那么问题来了，加入了这句权限声明后，对于用户来说到底有什么影响呢？为什么这样就可以保护设备的安全了呢？</p>
<p>其实用户主要在两方面得到保护。一方面，如果用户在低于Android6.0系统的设备商安装该程序，会在安装界面弹出一连串提示。这样用户就可以知晓该程序一共申请了哪些权限，从而决定是否安装这个程序。另一方面，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况。这样该程序申请的权限就尽收眼底，什么都瞒不过用户，以此保证应用程序不会出现滥用权限的情况。</p>
<p>但是，很多时候我们离不开的常用软件普遍存在滥用权限的情况，不管到底有没有用得到，反正先申请了再说。</p>
<blockquote>
<p>考虑到上述问题，Android6.0以后加入了动态申请权限功能。但是，如果安装一个应用需要不停地授权很多权限，就很繁琐，用户体验极差。那么就将权限进行了划分——普通权限与危险权限。普通权限会默认开启，而危险权限需要用户进行授权。</p>
</blockquote>
<h2 id="危险权限"><a href="#危险权限" class="headerlink" title="危险权限"></a>危险权限</h2><p>下面列出Android危险权限，除了这些剩余的都是普通权限。</p>
<table>
<thead>
<tr>
<th>权限组名</th>
<th>权限名</th>
</tr>
</thead>
<tbody><tr>
<td>CALENDAR（日历）</td>
<td>READ_CALENDAR、WRITE_CALENDAR</td>
</tr>
<tr>
<td>CAMERA（相机）</td>
<td>CAMERA、READ_CONTACTS</td>
</tr>
<tr>
<td>CONTACTS（联系人）</td>
<td>WRITE_CONTACTS、GET_ACCOUNTS</td>
</tr>
<tr>
<td>LOCATION（位置）</td>
<td>ACCESS_FINE_LOCATION、ACCESS_COARSE_LOCATION</td>
</tr>
<tr>
<td>MICROPHONE（麦克风）</td>
<td>RECORD_AUDIO、 READ_PHONE_STATE、CALL_PHONE、ERAD_CALL_LOG</td>
</tr>
<tr>
<td>PHONE（手机）</td>
<td>WRITE_CALL_LOG、ADD_VOICEMAIL、USE_SIP、PROCESS_OUTGOING_CALLS</td>
</tr>
<tr>
<td>SENSORS（传感器）</td>
<td>BODY_SENSORS、 SEND_SMS、RECEIVE_SMS</td>
</tr>
<tr>
<td>SMS（短信）</td>
<td>READ_SMS、RECEIVE_WAP_PUSH、RECEIVE_MMS</td>
</tr>
<tr>
<td>STORAGE（存储卡）</td>
<td>READ_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE</td>
</tr>
</tbody></table>
<p>这张表看起来不怎么轻松，因为里面的权限不都是能接触到的。不过没有关系，你不需要了解表格中每个权限的作用，只需要把它当成一个参照表来看就行了。每当需要使用一个权限时，可以查表，如果该权限出现在这张表中，那么就需要动态申请权限。</p>
<p>另外注意，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名。原则上，用户一旦同意了某个权限申请之后，同组的其它权限都会被系统自动开启。</p>
<p><strong>特别注意</strong>：不要基于此规则来实现任何逻辑，因为Android系统随时有可能调整权限的分组。</p>
<h2 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h2><p><strong>运行效果</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_09_13_17_51_50_995.gif" alt="录制_2022_09_13_17_51_50_995"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding:ActivityMainBinding;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.Call.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>,Manifest.permission.CALL_PHONE)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                ActivityCompat.requestPermissions(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    arrayOf(Manifest.permission.CALL_PHONE)</span><br><span class="line">                , REQUEST_CODE)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                call()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            REQUEST_CODE -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    call()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;You denied the permission&quot;</span>,Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(Intent.ACTION_CALL)</span><br><span class="line">            intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;tel:10086&quot;</span>)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:SecurityException)&#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码覆盖了运行时权限的完整流程，下面我们来具体分析一下。</p>
<ul>
<li><p>第一步就是要先判断用户是不是已经给我们进行了授权，借助的是<code>ContextCompat.checkSelfPermission()</code>方法接收两个参数：</p>
<ul>
<li>Context</li>
<li>具体的权限名，比如打电话的权限名<code>Manifest.permission.CALL_PHONE</code></li>
</ul>
<p>然后我们使用方法的返回值与<code>PackageManager.PERMISSION_GRANTED</code>做比较，相等就说明用户已经授权，不等就表示用户没有权限。</p>
</li>
<li><p>如果已经授权了，直接执行拨打电话的逻辑就可以了，这里我们把拨打电话的逻辑封装到call()方法中。如果没有授权的话，则需要调用<code>ActivityCompat.requestPermissions()</code>方法向用户申请权限。<code>requestPermissions()</code>接收3个参数：</p>
<ul>
<li>第一个参数要求是Activity实例</li>
<li>第二个参数是String数组，我们把要申请的权限名放到数组中即可</li>
<li>第三个要求是请求码，只要是唯一值就可以</li>
</ul>
</li>
<li><p>调用完<code>requestPermissions()</code>方法之后，系统会弹出一个权限申请的对话框，用户可以选择同意我们的权限申请。无论是哪种结果，最终都会回调 <code>onRequestPermissionsResult()</code>方法中，而授权的结果则会封装在<code>grantResults</code>参数中。这里我们只需要判断一下最后的授权结果，如果用户同意的话，就调用call()方法拨打电话；如果用户拒绝的话，我们只能放弃操作，并且弹出一条失败的提示。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>运行时权限</tag>
      </tags>
  </entry>
  <entry>
    <title>AsyncTask的使用介绍</title>
    <url>/2022/09/24/AsyncTask%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>今天，小编介绍一下Android中的老朋友——AsyncTask，很久没有见过它了，但是在前段时间小编在查资料的时候又见到了AsyncTask。小编现在就来简单介绍一下它的功能与使用。</p>
<p>在Android中，谈到异步消息处理我们首先想到的就是Handler，的确！Handler宛如Android的心脏一般不停地处理消息，支持着Android的运转。</p>
<p>但是，为了更加方便我们在子线程中对UI进行操作，Android还提供了另外一些好用的工具，比如AsyncTask。</p>
</blockquote>
<h2 id="AsyncTask简介"><a href="#AsyncTask简介" class="headerlink" title="AsyncTask简介"></a>AsyncTask简介</h2><p>借助AsyncTask，即使你对异步消息处理机制完全不了解，也可以十分简单地从子线程切换到主线程。当然，AsyncTask背后的实现原理也是基于异步消息处理机制Handler的，只是Android帮我们做了很好的封装。</p>
<p>由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须创建一个子类去继承它。在继承时我们可以为AsyncTask类指定3个泛型参数：</p>
<ul>
<li>Params：在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</li>
<li>Progress：在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</li>
<li>Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Unit,Int,Boolean</span>&gt;</span>()&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们把AsyncTask的第一个泛型参数指定为Unit，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Int，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用Boolean数据来反馈执行结果。</p>
<h2 id="AsyncTask的使用"><a href="#AsyncTask的使用" class="headerlink" title="AsyncTask的使用"></a>AsyncTask的使用</h2><p>上述的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要重写AsyncTask中的几个方法才能完成对任务的定制。经常需要重写的方法有以下4个：</p>
<ol>
<li><p>onPreExecute()</p>
<p>这个方法会在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等</p>
</li>
<li><p>doInBackground(Params…)</p>
<p>这个方法中的所有代码都会在子线程中进行，我们应该在这里去处理所有的耗时任务。任务一旦完成，就可以通过return语句将任务的执行结果返回，如果AsyncTask的第三个泛型参数指定的是Unit，就可以不返回任务执行结果。</p>
<p><strong>注意：</strong>在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。</p>
</li>
<li><p>onProgressUpdate(Progress…)</p>
<p>当前后台任务中调用了publishProgress(Progress…)方法后，onProgressUpdate(Progress…)方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对UI界面元素进行相应的更新。</p>
</li>
<li><p>onPostExecute(Result)</p>
<p>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据进行一些UI操作，比如说提醒任务执行的结果，以及关闭进度条对话框等。</p>
</li>
</ol>
<p><strong>代码示例</strong>：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span> : <span class="type">AsyncTask</span>&lt;<span class="type">Unit,Int,Boolean</span>&gt;</span>()&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPreExecute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        progressDialog.show()<span class="comment">//显示进度对话框</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doinBackground</span><span class="params">(<span class="keyword">vararg</span> params:<span class="type">Unit</span>?)</span></span> = <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">val</span> downloadPercent = doDownload()<span class="comment">//这是一个虚构的方法</span></span><br><span class="line">            publishProgress(downloadPercent)</span><br><span class="line">            <span class="keyword">if</span>(downloadPercent&gt;=<span class="number">100</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(e:Exception)&#123;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onProgressUpdate</span><span class="params">(<span class="keyword">vararg</span> values:<span class="type">Int</span>?)</span></span>&#123;</span><br><span class="line">        <span class="comment">//在这里更新下载进度</span></span><br><span class="line">        progressDialog.setMessage(<span class="string">&quot;Downloaded <span class="subst">$&#123;values[<span class="number">0</span>]&#125;</span>%&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPostExecute</span><span class="params">(result:<span class="type">Boolean</span>)</span></span>&#123;</span><br><span class="line">        progressDialog.dismiss()<span class="comment">//关闭对话框</span></span><br><span class="line">        <span class="keyword">if</span>(result)&#123;</span><br><span class="line">            Toast.makeText(context,<span class="string">&quot;Download succeeded&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Toast.makeText(context,<span class="string">&quot;Download failed&quot;</span>,Toast.LENGTH_SHORT).show()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个DownloadTask中，我们在<code>doInBackground()</code>方法里执行具体的下载任务。这个方法里的代码都是在子线程中运行的，因而不会影响主线程的运行。注意，这里虚构一个doDownload()方法，用于计算当前的下载进度并返回，我们假设这个方法已经存在了。在得到了当前的下载进度后，下面就该考虑如何把它显示到界面上，由于<code>doInBackground()</code>方法是在子线程中运行的，在这里肯定不能进行UI操作，所以我们可以调用<code>publishProgress()</code>方法并传入当前的下载进度，这样<code>onProgressUpdate()</code>方法就会很快被调用，在这里就可以进行UI操作了。</p>
<p>当下载完成后，<code>doInBackground()</code>方法会返回一个Boolean变量，这样<code>onPostExecute()</code>方法就会很快被调用，这个方法也是在主线程中运行的。然后，在这里我们会根据下载的结果弹出相应的Toast提示，从而完成整个DownloadTask任务。</p>
<p>简单来说，使用AsyncTask的诀窍就是：</p>
<ul>
<li><code>doInBackground()</code>方法中执行具体的耗时任务</li>
<li><code>onProgressUpdate()</code>方法中进行UI操作</li>
<li><code>onPostExecute()</code>方法中执行一些任务的收尾工作。</li>
</ul>
<p>如果想要启动这个任务，只需要：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">DownloadTask.<span class="built_in">execute</span>()</span><br></pre></td></tr></table></figure>

<p>当然，你也可以给<code>execute()</code>方法中传入任意数量的参数，这些参数将会传递到DownloadTask的<code>doInBackground()</code>方法中。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><blockquote>
<p>以上就是关于AsyncTask的全部内容，是不是觉得很容易。不过很可惜的是AsyncTask现在被<code>@Deprecated</code>了，因为：</p>
<p>在使用AsyncTask加载数据时，如果遇到设备配置改变，比如设备旋转，你得负责管理它的生命周期，同时还要保存好数据，不让其因旋转丢失。虽然调用Fragment的setRetainInstance(true)方法来保存数据可以解决问题，但它不是万能的。很多时候，你还得编写特殊场景应对代码，让应用无懈可击。这些特殊场景有：用户在AsyncTask运行时点击后退键，以及启动AsyncTask的fragment因内存紧张而被销毁。<br>使用Loader是一种可行的解决方案，它可以代劳很多棘手的事情。Loader用来从某些数据源加载数据对象，数据源可以是磁盘、数据库、ContentProvider、网络甚至是另一进程。</p>
<p>AsyncTaskLoader是个抽象Loader，它可以使用AsyncTask把数据加载工作转移到其他线程上。我们创建的loader类几乎都是AsyncTaskLoader的子类。AsyncTaskLoader能在不阻塞主线程的前提下获取到数据，并把结果发送给目标对象。</p>
<p>至于AsyncTaskLoader的用法，大家可以自行搜索，相信大家见过小编这篇关于AsyncTask的文章后，学习AsyncTaskLoader的使用就很容易了。</p>
</blockquote>
<p>参考资料：《第一行代码》</p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>异步任务</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存管理深度剖析</title>
    <url>/2022/08/13/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="JVM与操作系统的关系"><a href="#JVM与操作系统的关系" class="headerlink" title="JVM与操作系统的关系"></a>JVM与操作系统的关系</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813203305453.png" alt="image-20220813203305453"></p>
<blockquote>
<p>以HelloWord.java程序为例，简单介绍一下java程序的执行过程</p>
<ul>
<li>HelloWord.java通过javac编译成字节码文件HelloWorld.class</li>
<li>通过类加载器ClassLoader将字节码文件加载到运行时数据区（这个会在后面介绍）</li>
<li>通过执行引擎执行并与操作系统交互</li>
</ul>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813203540635.png" alt="image-20220813203540635"></p>
<h3 id="关于Java-SE体系结构"><a href="#关于Java-SE体系结构" class="headerlink" title="关于Java SE体系结构"></a>关于Java SE体系结构</h3><ul>
<li>JVM只是一个翻译工具</li>
<li>JRE提供了基础类库</li>
<li>JDK提供了工具</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813204206894.png" alt="image-20220813204206894"></p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><strong>运行时数据区</strong></p>
<blockquote>
<p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>Java堆</li>
<li>方法区（运行时常量池）</li>
</ul>
<p>线程私有的：虚拟机栈、本地方法栈、程序计数器</p>
<ul>
<li>线程共享的：堆、方法区</li>
</ul>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813204329860.png" alt="image-20220813204329860"></p>
<h3 id="程序计数器和栈"><a href="#程序计数器和栈" class="headerlink" title="程序计数器和栈"></a>程序计数器和栈</h3><ul>
<li><p>程序计数器是JVM内存区域中 <strong>唯一不会OOM的内存区</strong></p>
</li>
<li><p>局部变量表只能存储8大数据类型（</p>
<p>byte[1]、short[2]、int[4]、long[8]、float[4]、double[8]、char[2]、boolean[1]）+引用</p>
</li>
<li><p>一个线程有多个方法</p>
</li>
<li><p>一个方法一个栈帧</p>
</li>
<li><p>操作数栈：存放方法的执行和操作。</p>
</li>
<li><p>下面通过一个简单的1+2&#x3D;3的计算过程解释局部变量表与操作数栈之间的关系</p>
<ol>
<li>操作数栈将局部变量表中的1、2拷贝入操作数栈</li>
<li>操作数栈弹出1、2并计算得3压入操作数栈</li>
<li>之后又压入局部变量表</li>
</ol>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_14_12_11_14_245.gif" alt="录制_2022_08_14_12_11_14_245"></p>
</li>
<li><p>关于动态链接的理解：</p>
<p>口述不清，咱们以实例来理解</p>
<p>下图中Man与Woman为Person类的子类都有wc的实现方法</p>
<p>引用首先指向Man，执行wc方法</p>
<p>当引用指向新的对象调用wc方法，但是这俩wc并不一样，系统却能调用正确的方法，这就是动态链接的作用。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813210956693.png" alt="image-20220813211001482"></p>
</li>
<li><p>本地方法栈</p>
<ul>
<li>本地方法栈保存的是native方法的信息</li>
<li>当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机中创建栈帧，JVM只是简单地调用动态链接库并直接调用native方法。</li>
</ul>
</li>
</ul>
<h2 id="方法区和堆"><a href="#方法区和堆" class="headerlink" title="方法区和堆"></a>方法区和堆</h2><p>首先解决一个问题，<strong>为什么堆和方法区都是线程共享的，但却分成两份？</strong></p>
<p>​	1. 堆中存放的是数组和对象，需要频繁回收。</p>
<p>​	2. 方法区中存放的有<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong></p>
<h3 id="深入辨析堆和栈"><a href="#深入辨析堆和栈" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h3><ul>
<li>功能<ul>
<li>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；</li>
<li>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；</li>
</ul>
</li>
<li>线程独享还是共享<ul>
<li>栈内存归属于单个线程，每个线程都有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</li>
<li>堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。</li>
</ul>
</li>
<li>存储空间<ul>
<li>栈的内存要远远小于堆内存，栈的深度是有限制的，可能发生StackOverFlowError问题。</li>
</ul>
</li>
</ul>
<p><strong>堆的内存模型</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814102942978.png"></p>
<blockquote>
<ul>
<li>堆的内存空间分为Eden（新生代）、From区和To区（也可划分到新生代）、Tenured（老年代）</li>
<li>对象被分配到的是连续的内存空间，也就是说上述的几个区域都是连续的内存空间。</li>
</ul>
<p>这里先浅谈一下堆的内存模型，后面在讲解对象的分配存储时将深入。</p>
</blockquote>
<h2 id="虚拟机优化技术"><a href="#虚拟机优化技术" class="headerlink" title="虚拟机优化技术"></a>虚拟机优化技术</h2><ul>
<li><p>编译优化技术</p>
<ul>
<li><p>方法内联</p>
<p>比如有的场景，可以用一个表达式代替一个Boolean判断方法。</p>
</li>
</ul>
</li>
<li><p>栈帧之间的数据共享</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814103626937.png" alt="image-20220814103626937"></p>
</li>
</ul>
<h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><strong>对象的创建过程</strong>（一般对象）</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814103830376.png" alt="image-20220814103830376"></p>
<h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>内存划分引发的并发编程问题（指针碰撞） 解决方案：</p>
<ul>
<li><p>CAS加锁</p>
</li>
<li><p>本地线程分配缓冲TLAB（Thread Local Allocation Buffer）：</p>
<p>给每个线程分配一块区域（一般在Eden区）</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814104057751.png" alt="image-20220814104057751"></p>
</li>
</ul>
<h3 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h3><p>先初始化默认值（不需要赋值就可以使用，当然程序可以越早使用对象那么效率越高）</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>设置对象头信息</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814105348748.png" alt="image-20220814105348748"></p>
<h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><ul>
<li>执行构造方法</li>
</ul>
<h2 id="关于对象的访问定位"><a href="#关于对象的访问定位" class="headerlink" title="关于对象的访问定位"></a>关于对象的访问定位</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814105534396.png" alt="image-20220814105534396"></p>
<ul>
<li>使用句柄<ul>
<li>引用reference不再存对象地址，而是存对象所对应的指针（句柄），句柄池再映射一次。</li>
<li>句柄池具有指针定位的开销，开销比较小。</li>
</ul>
</li>
<li>直接指针<ul>
<li>直接指向真实的地址（Hotspot以及一些主流的虚拟机就使用这种）</li>
</ul>
</li>
</ul>
<h2 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h2><p>GC是不会主动触发的，内存不足时触发。</p>
<h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><blockquote>
<p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p>
</blockquote>
<h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote>
<p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p>
</blockquote>
<p>在Java中，可作为GCRoot的对象包括：</p>
<ol>
<li><p>方法区：类静态属性的对象；</p>
</li>
<li><p>方法区：常量的对象；</p>
</li>
<li><p>虚拟机栈（本地变量表）中的对象；</p>
</li>
<li><p>本地方法栈JNI（Native方法）中的对象。</p>
</li>
</ol>
<p>使用可达性分析算法，对象一定会被GC吗？</p>
<p>答案是否定的，那就要涉及到finalize这个Object万类之主中的方法</p>
<h3 id="finalize与try-catch-finally"><a href="#finalize与try-catch-finally" class="headerlink" title="finalize与try catch finally"></a>finalize与try catch finally</h3><ul>
<li><p>finalize</p>
<ul>
<li><p>finalize()只能执行一次，且优先级较低</p>
</li>
<li><p>finalize()不一定能救活对象</p>
</li>
<li><p>所以<strong>使用try finally</strong>救活对象更好。</p>
</li>
</ul>
</li>
<li><p>try catch finally</p>
<ul>
<li>不管有没有出现异常，finally块中的代码一定会执行</li>
<li>当try和catch中有return时，finally仍然会执行</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值只在finally执行之前确定的</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中包含的返回值。</li>
</ul>
</li>
</ul>
<h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><ul>
<li><p>强引用：就像我们平时使用的“&#x3D;”</p>
</li>
<li><p>软引用（SoftReference）：</p>
<p>当OOM时被回收</p>
<ul>
<li>软引用测试：</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654658511709.png" alt="1654658511709"></p>
<p>第一次测试结果：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654658638965.png" alt="1654658638965"></p>
<p>第二次测试结果：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654658686941.png" alt="1654658686941"></p>
<ul>
<li><strong>软引用的实际使用：图片加载</strong></li>
</ul>
</li>
<li><p>弱引用（WeakReference）：</p>
<p>只要GC就被回收</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659017602.png" alt="1654659017602"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659061704.png" alt="1654659061704"></p>
<ul>
<li>实际应用：一些不是很重要的东西，比如缓存。可以用来防止内存泄漏</li>
<li>实际过程中弱引用使用的更多，因为发生GC的频次肯定比OOM的频次高</li>
</ul>
</li>
<li><p>虚引用（PhantomReference）：</p>
<ul>
<li><p>最弱的：随时会被回收，GC时会收到一个通知</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659537857.png" alt="1654659537857"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659543594.png" alt="1654659543594"></p>
</li>
<li><p>实际应用：监控垃圾回收器是否正常工作</p>
</li>
</ul>
</li>
</ul>
<h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814111523597.png" alt="image-20220814111523597"></p>
<ul>
<li><p><strong>几乎</strong>所有的对象都在堆中分配</p>
<ul>
<li>所以不是所有的对象都是在堆中分配，未发生逃逸的对象内存其实是分配在栈上</li>
<li>首先会判断是否在栈上分配</li>
</ul>
</li>
<li><p>栈上分配 -&gt; 虚拟机栈</p>
<ul>
<li>栈中运行完了，不需要垃圾回收，栈是跟随线程存在。</li>
</ul>
</li>
<li><p>逃逸分析</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654660876349.png" alt="1654660876349"></p>
</li>
<li><p>堆中的优化技术</p>
<ul>
<li>本地线程缓冲（TLAB）</li>
</ul>
</li>
<li><p>如果是大对象（很长的字符串、数组）</p>
<ul>
<li>放入到老年代（Tenured）中</li>
</ul>
</li>
<li><p>长期存活的对象进入老年代</p>
<ul>
<li>首先进入From区，然后接下来的GC中在From和To区移动（复制回收算法，只要把复制的对象传递过去，就可以对内存区域直接处理，效率高）</li>
<li>age最大15，超过15将进入老年代，age也可以自定义</li>
<li>From区与To区等大</li>
<li>大数据显示，大部分的新生对象中90%以上会在第一次GC被回收，剩下的才进入From区，所以可以让我们的空间利用率达到90%以上（并且空间比例Eden：From：To&#x3D;8:1:1）。</li>
</ul>
</li>
<li><p><strong>空间分配担保</strong></p>
<ul>
<li><p>From区与To区空间不够用，进入老年代（Tenured区）</p>
</li>
<li><p>由JVM做担保，不用fullGC（GC在堆中分为minorGC-&gt;Eden、From、To和fullGC-&gt;Tenured），空间够用</p>
</li>
<li><p>如果担保失败（空间不够用），那么首先需要fullGC，然后再存储对象到老年代</p>
</li>
<li><p>如此处理，就不用再每次向老年代存储对象时都fullGC</p>
</li>
</ul>
</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ol>
<li>绝大多数对象都是“朝生夕死” -&gt;新生代</li>
<li>对象熬过了很多次垃圾回收，越难回收 -&gt;老年代</li>
<li>fullGC也会回收包括方法区在内的空间，即使方法区中的内容很难回收（静态变量、常量…）</li>
</ol>
<h4 id="复制算法（即前面的复制回收算法）"><a href="#复制算法（即前面的复制回收算法）" class="headerlink" title="复制算法（即前面的复制回收算法）"></a>复制算法（即前面的复制回收算法）</h4><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122152653.png" alt="image-20220814122152653"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122206391.png" alt="image-20220814122206391"></p>
<ul>
<li><p>实现简单、运行高效</p>
</li>
<li><p>内存复制、没有内存碎片</p>
</li>
<li><p>利用率只有一半（预留一半进行复制）</p>
</li>
<li><p>Appel式回收</p>
<p>即前面提到的，Eden区与From、To区分配比例大致为8:1:1（理由上面提及过，第一次回收时90%以上的都会被回收，只有不到10%才能进入From区）</p>
<p>这样使空间利用率提高了，提升至90%。</p>
</li>
</ul>
<h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><ul>
<li>即在回收前标记需要回收的空间</li>
<li>执行效率不稳定（可能有90%需要回收、可能10%需要回收）</li>
<li>内存碎片导致提前GC</li>
</ul>
<h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><blockquote>
<p>是标记清楚算法缺点的一种解决方案，但同样也存在明显缺陷。</p>
<ul>
<li>对象移动</li>
<li>引用更新</li>
<li>用户线程暂停</li>
<li>没有内存碎片</li>
</ul>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122427544.png" alt="image-20220814122427544"></p>
<h4 id="JVM中常见的垃圾回收器"><a href="#JVM中常见的垃圾回收器" class="headerlink" title="JVM中常见的垃圾回收器"></a>JVM中常见的垃圾回收器</h4><ul>
<li>单线程垃圾回收器</li>
<li>多线程并行垃圾回收器</li>
<li><strong>多线程并发垃圾回收器</strong>：支持垃圾回收线程与用户线程 同时工作。</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122835721.png" alt="image-20220814122835721"></p>
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>Concurrent Mark Seep并发标记清除</p>
<ul>
<li>减少了STW（Stop The World）的时间</li>
<li>只针对老年代</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814123049105.png" alt="image-20220814123049105"></p>
<p><strong>标记阶段</strong></p>
<ul>
<li>初始标记（暂停所有用户线程）：标记GCRoots直接相连的对象，所以速度很快。</li>
<li>并发标记：标记GCRoots所有关联的对象。</li>
<li>重新标记（暂停所有用户线程）：将中间有变动的重新标记（并发收集是GC不干净的，所以需要重新标记），时间短。</li>
</ul>
<p><strong>清理阶段</strong></p>
<ul>
<li>并发清理（用户和GC同时进行）：时间长</li>
<li>重置线程</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>CPU敏感：用户线程、GC线程都要跑，如果CPU核心数不足，那么对用户影响会很大</li>
<li>浮动垃圾：并发清理时，用户线程还是会产生垃圾</li>
<li>内存碎片</li>
</ul>
<h2 id="常量池与String"><a href="#常量池与String" class="headerlink" title="常量池与String"></a>常量池与String</h2><p>最后再来谈一个易混淆的知识点，String，同时介绍一个常量池。</p>
<p><strong>静态常连池</strong></p>
<blockquote>
<p>所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅包含字符串(数字)<strong>字面量</strong>，还包含类、方法的信息，占用class文件绝大部分空间。 </p>
</blockquote>
<p><strong>运行时常量池</strong></p>
<blockquote>
<p>而<strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，<strong>咱们常说的常量池，就是指方法区中的运行时常量池。</strong> </p>
</blockquote>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote>
<p>String str &#x3D; new String(“abc”)；</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814153313986.png" alt="image-20220814153313986"></p>
</blockquote>
<p><strong>intern</strong></p>
<blockquote>
<p>在调用intern方法之后，会去常量池中查找是否有等于该字符串常量对象的引用，有就返回引用。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654865473328.png"></p>
]]></content>
      <categories>
        <category>Java筑基</category>
      </categories>
  </entry>
  <entry>
    <title>CoordinatorLayout原理解析与Behavior</title>
    <url>/2022/08/06/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8EBehavior/</url>
    <content><![CDATA[<h2 id="CoordinatorLayout的功能"><a href="#CoordinatorLayout的功能" class="headerlink" title="CoordinatorLayout的功能"></a>CoordinatorLayout的功能</h2><p><strong>事先警示：</strong>CoordinatorLayout只继承了NestedScrollParent，也就是说它只能做顶层父View，别踩坑！！！</p>
<ol>
<li><p>处理子控件之间依赖下的交互</p>
</li>
<li><p>处理子控件之间的嵌套滑动</p>
</li>
<li><p>处理子控件的测量与布局</p>
</li>
<li><p>处理子控件的事件拦截与响应</p>
<p>以上四个功能，都建立与CoordinatorLayout中提供的一个叫做Behavior的“插件”之上。Behavior内部也提供了相应方法来对应这四个不同的功能。<br>Behavior内部集成了上述四种功能对应的方法，实现解耦。</p>
</li>
</ol>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806114929932.png" alt="image-20220806114929932"></p>
<p><strong>什么是Behavior？</strong><br>可以把Behavior理解成插件，当我们的组件想实现什么样的功能的时候就使用对应的Behavior，也就是说很多种不同功能的Behavior，当然也可以自定义Behavior。</p>
<h2 id="CoordinatorLayout下依赖交互原理"><a href="#CoordinatorLayout下依赖交互原理" class="headerlink" title="CoordinatorLayout下依赖交互原理"></a>CoordinatorLayout下依赖交互原理</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115038051.png" alt="image-20220806115038051"></p>
<blockquote>
<p>当CoordinatorLayout中子控件dependency的位置、大小发生变化的时候，那么在CoordinatorLayout内部会通知所有依赖depandency的控件，并调用对应声明的Behavior，告知其依赖的dependency发生变化。<br>那么如何判断依赖-&gt;layoutDependsOn<br>接收到通知后如何处理-&gt;onDependentViewChanged&#x2F;onDependentViewRemoved<br>这些都是由Behavior来处理。</p>
</blockquote>
<h3 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h3><ul>
<li><p><strong>layoutDependsOn(CoordinatorLayout parent, View child, View dependency)</strong>  表示是否给应用了Behavior 的View 指定一个依赖的布局</p>
<ul>
<li>参数1：coordinatorlayout对象</li>
<li>参数2：child 被观察的View</li>
<li>参数3：依赖变化的View（被观察的View）</li>
</ul>
</li>
<li><p><strong>onDependentViewChanged(CoordinatorLayout parent, View child, View dependency)</strong> 当依赖的View发生变化的时候hi掉的方法</p>
</li>
<li><p><strong>onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type)</strong> 当用户手指按下的时候，你是否要处理这次操作。当你确定要处理这次操作的时候，返回true；如果返回false的时候，就不会去响应后面的回调事件了。你想怎么滑就怎么话，我都不做处理。这里的(axes)滚动方向很重要，可以通过此参数判断滚动方向！</p>
<ul>
<li>参数3：直接目标，相当于能滑动的控件</li>
<li>参数4：观察的View</li>
<li>参数5：这个可以简单理解为滚动方向<ul>
<li>ViewCompat#SCROLL_AXIS_HORIZONTAL 水平方向</li>
<li>ViewCompat#SCROLL_AXIS_VERTICAL 竖直方向</li>
</ul>
</li>
<li>参数6：这个参数是之后有的，如果你输入的类型不是TYPE_TOUCH那么就不会相应这个滚动</li>
</ul>
</li>
<li><p><strong>onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</strong> 当onStartNestedScroll准备处理这次滑动的时候(返回true的时候)，回调这个方法。可以在这个方法中做一些响应的准备工作！</p>
</li>
<li><p><strong>onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</strong> 当滚动开始执行的时候回调这个方法。</p>
<ul>
<li>参数4&#x2F;参数5：用户x&#x2F;y轴滚动的距离(注意这里是每一次都回调的啊！！！)</li>
<li>参数6：处理滚动的距离的参数，内部维护着输出距离，假设用户滑动了100px,child 做了90px的位移，你需要把consumed［1］的值改成90，这样coordinatorLayout就能知道只处理剩下的10px的滚动。其中consumed[0]代表x轴、consumed[1]代表y轴。可能你不理解这个问题，换个形象点的比喻，比如你开发某一个功能，但是你只会其中的90%那么怎么办呢？不能就不管了。好你找到了你的同事或者老大，让他去完成剩下的10%。这样问题就完美的解决了，是一个概念的！</li>
</ul>
</li>
<li><p><strong>onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type)</strong> 上面这个方法结束的时候，coordinatorLayout处理剩下的距离，比如还剩10px。但是coordinatorLayout发现滚动2px的时候就已经到头了。那么结束其滚动，调用该方法，并将coordinatorLayout处理剩下的像素数作为参<code>(dxUnconsumed、dyUnconsumed)</code>传过来，这里传过来的就是 8px。参数中还会有coordinatorLayout处理过的像素数（dxConsumed、dyConsumed）。老大开始处理剩下的距离了！这个方法主要处理一些越界后的滚动。还是不懂对吧！还拿你们老大做比喻：比如上面还剩 10%的工作，这时老大处理了2%后发现已经可以上线了，于是老大结束了工作，并将处理剩下的内容（dxUnconsumed、dyUnconsumed）纪录下来，告诉你。老大处理了的内容（dxConsumed、dyConsumed）也告诉了你。</p>
<ul>
<li>参数4&#x2F;参数5：当没有滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
<li>参数6&#x2F;参数7：当滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
</ul>
</li>
<li><p>onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, float velocityX, float velocityY) 当手指松开发生惯性动作之前调用，这里提供了响应的速度，你可以根据速度判断是否需要进行折叠等一系列的操作，你要确定响应这个方法的话，返回true。</p>
<ul>
<li>参数4&#x2F;参数5：代表相应的速度</li>
</ul>
</li>
<li><p>onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int type) 停止滚动的时候回调的方法。当你不去响应Fling的时候会直接回调这个方法。在这里可以做一些清理工作。或者其他的内容。。。</p>
</li>
<li><p>onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) 确定子View位置的方法，这个方法可以重新定义子View的位置(这里明确是设置behavior的那个View哦),例如下面这样</p>
<ul>
<li>ViewCompat#LAYOUT_DIRECTION_LTR 视图方向从左到右</li>
<li>ViewCompat#LAYOUT_DIRECTION_RTL 视图方向从优到左</li>
</ul>
</li>
</ul>
<h2 id="CoordinatorLayout下嵌套滑动原理"><a href="#CoordinatorLayout下嵌套滑动原理" class="headerlink" title="CoordinatorLayout下嵌套滑动原理"></a>CoordinatorLayout下嵌套滑动原理</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115051276.png" alt="image-20220806115051276"></p>
<blockquote>
<p>CoordinatorLayout实现了NestedScrollingParent2接口。那么当事件(scroll或fling)产生后，内部实现了NestedScrollingChild接口的子控件会将事件分发给CoordinatorLayout，CoordinatorLayout又会将事件传递给所有的Behavior中实现子控件的嵌套滑动。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806142237581.png" alt="image-20220806142237581"></p>
<blockquote>
<p>相对于NestedScrollView机制（参数角色只有子控件和父控件），CoordinatorLayout中的交互角色玩出了新高度，在CoordinatorLayout下的子控件可以与多个兄弟控件进行交互。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115109848.png" alt="image-20220806115109848"></p>
</blockquote>
<p>大家可以看一下整个事件的流程图</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806144653508.png" alt="image-20220806144653508"></p>
<p><strong>浅谈View的生命周期</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115156782.png" alt="image-20220806115156782"></p>
<blockquote>
<p>层级关系：activity-&gt;window-&gt;view<br>LayoutInflater.inflate将view解析出来<br>在onFinishInflate阶段add到content中，content属于DecorView<br>在Activity中通过attach方法new一个PhoneWindow<br>在resume阶段通过makevisible方法PhoneWindow.addView(DecorView)<br>再回调onAttachToWindow，然后已经一系列方法（包括setView-&gt;WMS…开始绘制)才呈现出View</p>
</blockquote>
<h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>下面是截取的重要源码截图</p>
<p><strong>ViewTreeObserver介绍</strong></p>
<blockquote>
<p>ViewTreeObserver注册一个观察者来监听视图树，当是图书的布局、视图树的焦点、视图将要绘制、视图滚动等发生改变时，ViewTreeObserver都会收到通知，ViewTreeObsrver不能被实例化，可以调用，View.getViewTreeObserver()来获得</p>
</blockquote>
<blockquote>
<p>dispatchOnOreDraw():通知观察者绘制即将开始，如果其中的某个观察者返回true，那么绘制会取消，并且重新安排绘制，如果想在View Layout或View hierarchy还未依附到Window时，或者在View处于CONE状态时强制绘制，可以手动调用这个方法。<br>通过ViewTreeObserver添加绘制监听</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115229067.png" alt="image-20220806115229067"></p>
<p>注意，这里不是<code>getChildAt()</code>而是<code>mDependencySortedChildren.get()</code>，因为mDependencySortedChildren在这里是一个特殊的集合，因为CoordinatorLayout管理着多个子View，并且子View之间还存在依赖关系，所以还利用了有向无环图来记录View的依赖关系。只需理解原因即可，这里不用深究，否则会陷到坑里面去。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115313761.png" alt="image-20220806115313761"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115333029.png" alt="image-20220806115333029"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115712870.png" alt="image-20220806115712870"></p>
<p>Behavior在哪里被实例化？<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115344751.png" alt="image-20220806115344751"></p>
<p>如果自定义ViewGroup并且需要提供一些特殊的属性给子View，那么就需要重写LayoutParams</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115427736.png" alt="image-20220806115427736"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115502591.png" alt="image-20220806115444264"></p>
<p><code>HierarchyChangeListener</code>回调监听，当childView添加与删除时调用</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115502591.png" alt="image-20220806115502591"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115532076.png" alt="image-20220806115532076"></p>
<p>前面提到了mDependencySortedChildren，那么mDependencySortedChildren在哪初始化呢？</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115554255.png" alt="image-20220806115554255"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115611892.png" alt="image-20220806115611892"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115633713.png" alt="image-20220806115633713"></p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><strong>效果展示</strong></p>
<p>这是利用Behavior实现的嵌套滑动效果，上滑时顶部会隐藏，往下滑时顶部又会回显出来</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_15_07_40_12.gif" alt="录制_2022_08_06_15_07_40_12"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SampleHeaderBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mOffsetTopAndBottom;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mLayoutTop;</span><br><span class="line">    public <span class="constructor">SampleHeaderBehavior()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="constructor">SampleHeaderBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span>&#123;</span><br><span class="line">        super(context,attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">LayoutChild(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull TextView <span class="params">child</span>, <span class="params">int</span> <span class="params">layoutDirection</span>)</span> &#123;</span><br><span class="line">        parent.on<span class="constructor">LayoutChild(<span class="params">child</span>,<span class="params">layoutDirection</span>)</span>;</span><br><span class="line">        mLayoutTop = child.get<span class="constructor">Top()</span>;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">StartNestedScroll(@NonNull CoordinatorLayout <span class="params">coordinatorLayout</span>, @NonNull TextView <span class="params">child</span>, @NonNull View <span class="params">directTargetChild</span>, @NonNull View <span class="params">target</span>, <span class="params">int</span> <span class="params">axes</span>, <span class="params">int</span> <span class="params">type</span>)</span> &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void on<span class="constructor">NestedPreScroll(@NonNull CoordinatorLayout <span class="params">coordinatorLayout</span>, @NonNull TextView <span class="params">child</span>, @NonNull View <span class="params">target</span>, <span class="params">int</span> <span class="params">dx</span>, <span class="params">int</span> <span class="params">dy</span>, @NonNull <span class="params">int</span>[] <span class="params">consumed</span>, <span class="params">int</span> <span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> consumedy = <span class="number">0</span>;<span class="comment">//记录消费的距离</span></span><br><span class="line">        <span class="built_in">int</span> offset = mOffsetTopAndBottom - dy;</span><br><span class="line">        <span class="comment">//因为offset是带方向的，这里获取到最大可滑动距离需要在前面添加负号</span></span><br><span class="line">        <span class="built_in">int</span> minOffset = -get<span class="constructor">ChildScrollRange(<span class="params">child</span>)</span>;</span><br><span class="line">        <span class="built_in">int</span> maxOffset = <span class="number">0</span>;</span><br><span class="line">        offset = offset&lt;minOffset? minOffset:(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(offset, maxOffset));</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">child</span>,<span class="params">offset</span>-(<span class="params">child</span>.<span class="params">getTop</span>()</span>-mLayoutTop));</span><br><span class="line">        consumedy = mOffsetTopAndBottom - offset;</span><br><span class="line">        <span class="comment">//将本次滑动到的位置记录下来</span></span><br><span class="line">        mOffsetTopAndBottom = offset;</span><br><span class="line">        consumed<span class="literal">[<span class="number">1</span>]</span> = consumedy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取childView最大可滑动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> get<span class="constructor">ChildScrollRange(View <span class="params">childView</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (childView==null)&#123;</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return childView.get<span class="constructor">Height()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> ScrollerBehavior extends CoordinatorLayout.Behavior&lt;RecyclerView&gt; &#123;</span><br><span class="line">    public <span class="constructor">ScrollerBehavior()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">ScrollerBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull RecyclerView <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof TextView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull RecyclerView <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">child</span>,<span class="params">dependency</span>.<span class="params">getBottom</span>()</span>-child.get<span class="constructor">Top()</span>);</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>上面demo其实是对前面提到的嵌套滑动方法的实践。而这个例子才是对依赖与被依赖组件关系的效果展示，红色方块是被依赖方，而“跟随兄弟”和变色兄弟都是依赖方，会根据红色方块的位置变化而变化。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_15_09_45_364.gif" alt="录制_2022_08_06_15_09_45_364"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DependedView extends View &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mLastX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mLastY;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mDragSlop;</span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, <span class="params">int</span> <span class="params">mDragSlop</span>)</span> &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.mDragSlop = mDragSlop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, @Nullable AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, @Nullable AttributeSet <span class="params">attrs</span>, <span class="params">int</span> <span class="params">defStyleAttr</span>)</span> &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        mDragSlop = <span class="module-access"><span class="module"><span class="identifier">ViewConfiguration</span>.</span></span>get(context).get<span class="constructor">ScaledTouchSlop()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> action = event.get<span class="constructor">Action()</span>;</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mLastX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                mLastY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="built_in">int</span> dx = (<span class="built_in">int</span>) (event.get<span class="constructor">X()</span> - mLastX);</span><br><span class="line">                <span class="built_in">int</span> dy = (<span class="built_in">int</span>) (event.get<span class="constructor">Y()</span> - mLastY);</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs(dx) &gt; mDragSlop<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs(dy) &gt; mDragSlop) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">this</span>, <span class="params">dy</span>)</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">LeftAndRight(<span class="params">this</span>, <span class="params">dx</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                mLastY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> BrotherChameleonBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ArgbEvaluator mArgbEvaluator = <span class="keyword">new</span> <span class="constructor">ArgbEvaluator()</span>;</span><br><span class="line">    public <span class="constructor">BrotherChameleonBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull View <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof DependedView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull View <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> color = (<span class="built_in">int</span>)mArgbEvaluator.evaluate(dependency.get<span class="constructor">Y()</span>/parent.get<span class="constructor">Height()</span>, Color.WHITE,Color.BLACK);</span><br><span class="line">        child.set<span class="constructor">BackgroundColor(<span class="params">color</span>)</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> BrotherFollowBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line">    public <span class="constructor">BrotherFollowBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(CoordinatorLayout <span class="params">parent</span>, View <span class="params">child</span>, View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof DependedView;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(CoordinatorLayout <span class="params">parent</span>, View <span class="params">child</span>, View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        child.set<span class="constructor">Y(<span class="params">dependency</span>.<span class="params">getBottom</span>()</span> + <span class="number">50</span>);</span><br><span class="line">        child.set<span class="constructor">X(<span class="params">dependency</span>.<span class="params">getX</span>()</span>);</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用好Behavior对我们做好看的UI效果有很大的帮助，毕竟NestedScrollParent和NestedScrollChild也只能实现两个组件之间的嵌套关系，而Behavior能够实现一对多的嵌套关系。这节内容主要是对CoordinatorLayout的介绍以及只是对自定义Behavior的浅尝试，后面小编将写一篇真正意义的自定义Behavior的Demo介绍与实现。</p>
<p><a href="https://github.com/gun-ctrl/CoordanatorLayout">代码链接</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
  </entry>
  <entry>
    <title>NestedScrollView嵌套滑动原理</title>
    <url>/2022/08/06/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h2 id="事件分发机制简介"><a href="#事件分发机制简介" class="headerlink" title="事件分发机制简介"></a>事件分发机制简介</h2><p>其实小编应该在前面准备一章关于Android的事件分发和处理机制的专题，因为时间原因和内容源码比较多吧(小编有强迫症，不想不贴源码)，不过还是因为小编懒，哈哈。这里就对事件分发机制做一个简单的回忆，大家感兴趣的可以去看看相关资料和源码，小编后面有空也会出一期。</p>
<p>这里介绍一位优秀博主的博客，大家可以看这篇文章对事件分发机制与滑动冲突、以及解决方案有个全面的了解：</p>
<p><a href="https://wiwiyiyi.com/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html">事件分发机制以及滑动冲突的处理</a></p>
<p>下面对事件分发与处理做一个简单总结</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806150250279.png" alt="image-20220806150250279"></p>
<p>关键的一点大家需要记住：事件的分发是由上层到底层，而事件的处理是由底层到上层。</p>
<ul>
<li>也就是说父View可以拦截触摸事件直接消费，而不传递给子View。</li>
<li>子View可以处理事件，也可以选择给父类消费。</li>
<li>ViewGroup既可以消费事件，也可以分发事件</li>
<li>View只能处理事件，也就是消费。</li>
</ul>
<h4 id="View滑动冲突"><a href="#View滑动冲突" class="headerlink" title="View滑动冲突"></a>View滑动冲突</h4><ol>
<li>外部滑动方向与内部滑动方向不一致</li>
</ol>
<blockquote>
<p>解决方案：外部拦截法，当事件传递到父View时，父View需要处理此事件，就拦截，不处理此事件就不拦截</p>
</blockquote>
<ol start="2">
<li>外部滑动方向与内部滑动方向一致；</li>
</ol>
<blockquote>
<p>内部拦截法，当事件传递到父View时，父View都传递给子View，如果子View需要处理此事件就消耗掉，否则就交给父View处理。但是这种方法和Android事件分发不一致，需要配合 requestDisallowInterceptTouchEvent 方法才能正常工作</p>
</blockquote>
<ol start="3">
<li>上面两种情况的嵌套。</li>
</ol>
<blockquote>
<p>某个View一旦决定拦截，那么这一个事件序列都只能由它来处理，并且它的onInterceptTouchEvent不会再被调用<br>解决方案： 解决这种滑动冲突，可以用NestedScrollingParent 和 NestedScrollingChild 来解决</p>
</blockquote>
<h2 id="分析NestedScrollView机制"><a href="#分析NestedScrollView机制" class="headerlink" title="分析NestedScrollView机制"></a>分析NestedScrollView机制</h2><blockquote>
<p>NestedScrollView和ScrollView类似，是一个支持滚动的控件。此外，它还同时支持作NestedScrollingParent或者NestedScrollingChild进行嵌套滚动操作。默认是启用嵌套滚动的</p>
</blockquote>
<p>首先介绍两个重要接口</p>
<p>1.NestedScrollingParent</p>
<p>当可滑动的ViewGroup充当父View时实现该接口</p>
<p>2.NestedScrollingChild</p>
<p>当可滑动的ViewGroup充当子View时实现该接口</p>
<blockquote>
<p>我们所熟知的RecyclerView就对上面两个接口都进行了实现，所以它才能完美的处理滑动与点击item之间的关系，同时RecyclerView还支持惯性滑动（快速滑-&gt;手指松开-&gt;滑动一段距离停下），这都是上面两个接口中封装的方法的功劳。小编后面展示的demo就比较拉了，没有实现惯性滑动效果，别问！问就是因为懒。</p>
</blockquote>
<h4 id="整个事件流程"><a href="#整个事件流程" class="headerlink" title="整个事件流程"></a>整个事件流程</h4><p>这张图还是很清晰的展示了从点击-&gt;滑动-&gt;松开的方法调用过程</p>
<p>NestedScrollingChildHelper、NestedScrollingParentHelper是Google提供的帮助类，其内部是去调用ViewCompat中的方法调用（xxxCompat都是兼容处理），也就是说很多操作都可以由helper帮我们完成，对于小编这种懒人还是很友好的。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806160049703.png" alt="image-20220806160049703"></p>
<p>下面对方法进行介绍：</p>
<ul>
<li><p><strong>onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type)</strong> 当用户手指按下的时候，你是否要处理这次操作。当你确定要处理这次操作的时候，返回true；如果返回false的时候，就不会去响应后面的回调事件了。你想怎么滑就怎么话，我都不做处理。这里的(axes)滚动方向很重要，可以通过此参数判断滚动方向！</p>
<ul>
<li><p>参数3：直接目标，相当于能滑动的控件</p>
</li>
<li><p>参数4：观察的View</p>
</li>
<li><p>参数5：这个可以简单理解为滚动方向</p>
<ul>
<li>ViewCompat#SCROLL_AXIS_HORIZONTAL 水平方向</li>
<li>ViewCompat#SCROLL_AXIS_VERTICAL 竖直方向</li>
</ul>
</li>
<li><p>参数6：这个参数是之后有的，如果你输入的类型不是TYPE_TOUCH那么就不会相应这个滚动</p>
</li>
</ul>
</li>
<li><p><strong>onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</strong> 当onStartNestedScroll准备处理这次滑动的时候(返回true的时候)，回调这个方法。可以在这个方法中做一些响应的准备工作！</p>
</li>
<li><p><strong>onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</strong> 当滚动开始执行的时候回调这个方法。</p>
<ul>
<li>参数4&#x2F;参数5：用户x&#x2F;y轴滚动的距离(注意这里是每一次都回调的啊！！！)</li>
<li>参数6：处理滚动的距离的参数，内部维护着输出距离，假设用户滑动了100px,child 做了90px的位移，你需要把consumed［1］的值改成90，这样coordinatorLayout就能知道只处理剩下的10px的滚动。其中consumed[0]代表x轴、consumed[1]代表y轴。可能你不理解这个问题，换个形象点的比喻，比如你开发某一个功能，但是你只会其中的90%那么怎么办呢？不能就不管了。好你找到了你的同事或者老大，让他去完成剩下的10%。这样问题就完美的解决了，是一个概念的！</li>
</ul>
</li>
<li><p><strong>onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type)</strong> 上面这个方法结束的时候，coordinatorLayout处理剩下的距离，比如还剩10px。但是coordinatorLayout发现滚动2px的时候就已经到头了。那么结束其滚动，调用该方法，并将coordinatorLayout处理剩下的像素数作为参<code>(dxUnconsumed、dyUnconsumed)</code>传过来，这里传过来的就是 8px。参数中还会有coordinatorLayout处理过的像素数（dxConsumed、dyConsumed）。老大开始处理剩下的距离了！这个方法主要处理一些越界后的滚动。还是不懂对吧！还拿你们老大做比喻：比如上面还剩 10%的工作，这时老大处理了2%后发现已经可以上线了，于是老大结束了工作，并将处理剩下的内容（dxUnconsumed、dyUnconsumed）纪录下来，告诉你。老大处理了的内容（dxConsumed、dyConsumed）也告诉了你。</p>
<ul>
<li>参数4&#x2F;参数5：当没有滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
<li>参数6&#x2F;参数7：当滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li>
</ul>
</li>
<li><p>onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, float velocityX, float velocityY) 当手指松开发生惯性动作之前调用，这里提供了响应的速度，你可以根据速度判断是否需要进行折叠等一系列的操作，你要确定响应这个方法的话，返回true。</p>
<ul>
<li>参数4&#x2F;参数5：代表相应的速度</li>
</ul>
</li>
<li><p>onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int type) 停止滚动的时候回调的方法。当你不去响应Fling的时候会直接回调这个方法。在这里可以做一些清理工作。或者其他的内容。</p>
</li>
</ul>
<p><strong>再来看看两个接口的源码</strong></p>
<p>1.NestedScrollingChild</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启用或禁用嵌套滚动的方法，设置为true，并且当前界面的View的层次结构是支持嵌套滚动的</span></span><br><span class="line"><span class="comment">    * (也就是需要NestedScrollingParent嵌套NestedScrollingChild)，才会触发嵌套滚动。</span></span><br><span class="line"><span class="comment">    * 一般这个方法内部都是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNestedScrollingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前View是否支持嵌套滑动。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNestedScrollingEnabled</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 表示view开始滚动了,一般是在ACTION_DOWN中调用，如果返回true则表示父布局支持嵌套滚动。</span></span><br><span class="line"><span class="comment">    * 一般也是直接代理给NestedScrollingChildHelper的同名方法即可。这个时候正常情况会触发Parent的onStartNestedScroll()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="type">int</span> axes)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一般是在事件结束比如ACTION_UP或者ACTION_CANCLE中调用,告诉父布局滚动结束。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前View是否有嵌套滑动的Parent。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View消费滚动距离之后。通过调用该方法，把剩下的滚动距离传给父布局。如果当前没有发生嵌套滚动，或者不支持嵌套滚动，调用该方法也没啥用。</span></span><br><span class="line"><span class="comment">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    * dxConsumed：被当前View消费了的水平方向滑动距离</span></span><br><span class="line"><span class="comment">    * dyConsumed：被当前View消费了的垂直方向滑动距离</span></span><br><span class="line"><span class="comment">    * dxUnconsumed：未被消费的水平滑动距离</span></span><br><span class="line"><span class="comment">    * dyUnconsumed：未被消费的垂直滑动距离</span></span><br><span class="line"><span class="comment">    * offsetInWindow：输出可选参数。如果不是null，该方法完成返回时，</span></span><br><span class="line"><span class="comment">    * 会将该视图从该操作之前到该操作完成之后的本地视图坐标中的偏移量封装进该参数中，offsetInWindow[0]水平方向，offsetInWindow[1]垂直方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true：表示滚动事件分发成功,fasle: 分发失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View消费滚动距离之前把滑动距离传给父布局。相当于把优先处理权交给Parent</span></span><br><span class="line"><span class="comment">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可。</span></span><br><span class="line"><span class="comment">	* dx：当前水平方向滑动的距离</span></span><br><span class="line"><span class="comment">	* dy：当前垂直方向滑动的距离</span></span><br><span class="line"><span class="comment">	* consumed：输出参数，会将Parent消费掉的距离封装进该参数consumed[0]代表水平方向，consumed[1]代表垂直方向</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> true：代表Parent消费了滚动距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@Nullable</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *将惯性滑动的速度分发给Parent。内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">	* velocityX：表示水平滑动速度</span></span><br><span class="line"><span class="comment">	* velocityY：垂直滑动速度</span></span><br><span class="line"><span class="comment">	* consumed：true：表示当前View消费了滑动事件，否则传入false</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@return</span> true：表示Parent处理了滑动事件</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View自己处理惯性滑动前，先将滑动事件分发给Parent,一般来说如果想自己处理惯性的滑动事件，</span></span><br><span class="line"><span class="comment">    * 就不应该调用该方法给Parent处理。如果给了Parent并且返回true，那表示Parent已经处理了，自己就不应该再做处理。</span></span><br><span class="line"><span class="comment">    * 返回false，代表Parent没有处理，但是不代表Parent后面就不用处理了</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true：表示Parent处理了滑动事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="type">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow,</span></span><br><span class="line"><span class="params">            <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@Nullable</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild3</span> <span class="keyword">extends</span> <span class="title class_">NestedScrollingChild2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow, <span class="meta">@ViewCompat</span>.NestedScrollType <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="type">int</span>[] consumed)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.NestedScrollingParent</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当NestedScrollingChild调用方法startNestedScroll()时,会调用该方法。主要就是通过返回值告诉系统是否需要对后续的滚动进行处理</span></span><br><span class="line"><span class="comment">    * child：该ViewParen的包含NestedScrollingChild的直接子View，如果只有一层嵌套，和target是同一个View</span></span><br><span class="line"><span class="comment">    * target：本次嵌套滚动的NestedScrollingChild</span></span><br><span class="line"><span class="comment">    * nestedScrollAxes：滚动方向</span></span><br><span class="line"><span class="comment">    * @return </span></span><br><span class="line"><span class="comment">    * true:表示我需要进行处理，后续的滚动会触发相应的回到</span></span><br><span class="line"><span class="comment">    * false: 我不需要处理，后面也就不会进行相应的回调了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//child和target的区别，如果是嵌套两层如:Parent包含一个LinearLayout，LinearLayout里面才是NestedScrollingChild类型的View。这个时候，</span></span><br><span class="line">    <span class="comment">//child指向LinearLayout，target指向NestedScrollingChild；如果Parent直接就包含了NestedScrollingChild，</span></span><br><span class="line">    <span class="comment">//这个时候target和child都指向NestedScrollingChild</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onStartNestedScroll</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果onStartNestedScroll()方法返回的是true的话,那么紧接着就会调用该方法.它是让嵌套滚动在开始滚动之前,</span></span><br><span class="line"><span class="comment">    * 让布局容器(viewGroup)或者它的父类执行一些配置的初始化的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScrollAccepted</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 停止滚动了,当子view调用stopNestedScroll()时会调用该方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onStopNestedScroll</span>(<span class="variable">@NonNull</span> View target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当子view调用dispatchNestedScroll()方法时,会调用该方法。也就是开始分发处理嵌套滑动了</span></span><br><span class="line"><span class="comment">    * dxConsumed：已经被target消费掉的水平方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dyConsumed：已经被target消费掉的垂直方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dxUnconsumed：未被tagert消费掉的水平方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dyUnconsumed：未被tagert消费掉的垂直方向的滑动距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当子view调用dispatchNestedPreScroll()方法是,会调用该方法。也就是在NestedScrollingChild在处理滑动之前，</span></span><br><span class="line"><span class="comment">    * 会先将机会给Parent处理。如果Parent想先消费部分滚动距离，将消费的距离放入consumed</span></span><br><span class="line"><span class="comment">    * dx：水平滑动距离</span></span><br><span class="line"><span class="comment">    * dy：处置滑动距离</span></span><br><span class="line"><span class="comment">    * consumed：表示Parent要消费的滚动距离,consumed[0]和consumed[1]分别表示父布局在x和y方向上消费的距离.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedPreScroll</span>(<span class="variable">@NonNull</span> View target, int dx, int dy, <span class="variable">@NonNull</span> int[] consumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 你可以捕获对内部NestedScrollingChild的fling事件</span></span><br><span class="line"><span class="comment">    * velocityX：水平方向的滑动速度</span></span><br><span class="line"><span class="comment">    * velocityY：垂直方向的滑动速度</span></span><br><span class="line"><span class="comment">    * consumed：是否被child消费了</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * true:则表示消费了滑动事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onNestedFling</span>(<span class="variable">@NonNull</span> View target, float velocityX, float velocityY, boolean consumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在惯性滑动距离处理之前，会调用该方法，同onNestedPreScroll()一样，也是给Parent优先处理的权利</span></span><br><span class="line"><span class="comment">    * target：本次嵌套滚动的NestedScrollingChild</span></span><br><span class="line"><span class="comment">    * velocityX：水平方向的滑动速度</span></span><br><span class="line"><span class="comment">    * velocityY：垂直方向的滑动速度</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * true：表示Parent要处理本次滑动事件，Child就不要处理了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onNestedPreFling</span>(<span class="variable">@NonNull</span> View target, float velocityX, float velocityY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回当前滑动的方向，一般直接通过NestedScrollingParentHelper.getNestedScrollAxes()返回即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @<span class="selector-tag">ScrollAxis</span></span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">getNestedScrollAxes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent2</span> <span class="selector-tag">extends</span> <span class="selector-tag">NestedScrollingParent</span> &#123;</span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onStartNestedScroll</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScrollAccepted</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onStopNestedScroll</span>(<span class="variable">@NonNull</span> View target, <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed, <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedPreScroll</span>(<span class="variable">@NonNull</span> View target, int dx, int dy, <span class="variable">@NonNull</span> int[] consumed,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent3</span> <span class="selector-tag">extends</span> <span class="selector-tag">NestedScrollingParent2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed, int dxUnconsumed,</span><br><span class="line">            int dyUnconsumed, <span class="variable">@ViewCompat</span>.NestedScrollType int type, <span class="variable">@NonNull</span> int[] consumed);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>在那之前再补一张较全的事件流程图，还包括传值的过程欧，结合demo代码看也不错。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806164857678.png" alt="image-20220806164857678"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806164945258.png" alt="image-20220806164945258"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806165039684.png" alt="image-20220806165039684"></p>
<p>效果演示</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_16_21_53_330.gif" alt="录制_2022_08_06_16_21_53_330"></p>
<p>这里就不贴大量代码了，展示一些主要代码，详情可见文章下方的全部代码</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806163510871.png" alt="image-20220806163510871"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806163541253.png" alt="image-20220806163541253"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要对NestedScrollView的嵌套滑动机制过程掌握，利用NestedScrollingParent、NestedScrollingChild这两个接口可以很轻松的实现自定义嵌套滑动机制，当然也可以直接通过继承自定义NestedScrollView实现一些炫酷的滑动、吸顶效果，这种效果在现在的电商平台还是很常见的。当然仅仅利用NestedScrollingParent、NestedScrollingChild实现嵌套还是有局限，只能一对一，要想实现一对多的嵌套滑动那就需要Behavior，下一章将会初步接触。</p>
<p><a href="https://github.com/gun-ctrl/NestedScrollViewTry">全部代码</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
  </entry>
  <entry>
    <title>OOM与内存优化</title>
    <url>/2022/08/19/OOM%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><h3 id="App内存组成以及限制"><a href="#App内存组成以及限制" class="headerlink" title="App内存组成以及限制"></a>App内存组成以及限制</h3><p>Android 给每个 App 分配一个 VM ，让App运行在 dalvik 上，这样即使 App 崩溃也不会影响到系统。系统给 VM 分配了一定的内存大小， App 可以申请使用的内存大小不能超过此硬性逻辑限制，就算物理内存富余，如果应用超出 VM 最大内存，就会出现内存溢出 crash。</p>
<p>由程序控制操作的内存空间在 heap 上，分 java heapsize 和 native heapsize</p>
<ul>
<li>Java申请的内存在 vm heap 上，所以如果 java 申请的内存大小超过 VM 的逻辑内存限制,就会出现内存溢出的异常</li>
<li><strong>native层内存申请不受其限制</strong>, native 层受 native process 对内存大小的限制</li>
</ul>
<h3 id="如何查看Android设备对App的内存限制"><a href="#如何查看Android设备对App的内存限制" class="headerlink" title="如何查看Android设备对App的内存限制"></a>如何查看Android设备对App的内存限制</h3><ol>
<li>主要查看系统配置文件 build.prop ，我们可以通过 adb shell 在 命令行窗口查看</li>
</ol>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> <span class="built_in">cat</span> /system/build.prop</span></span><br></pre></td></tr></table></figure>

<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819150211884.png" alt="image-20220819150211884"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819150239269.png" alt="image-20220819150239269"></p>
<ol start="2">
<li><p>通过代码获取</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">ActivityManager activityManager = (ActivityManager)<span class="built_in">context</span>.getSystemService(<span class="built_in">Context</span>.ACTIVITY_SERVICE) activityManager.getMemoryClass()<span class="comment">;//以m为单位</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以修改</p>
<ul>
<li><p>修改 \frameworks\base\core\jni\AndroidRuntime.cpp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="type">bool</span> zygote)</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * The default starting and maximum size of the heap. Larger </span></span><br><span class="line"><span class="comment">    * values should be specified in a product property override.</span></span><br><span class="line"><span class="comment">    */</span>parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapstartsize&quot;</span>, heapstartsizeOptsBuf, <span class="string">&quot;-Xms&quot;</span>, <span class="string">&quot;4m&quot;</span>);                   parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapsize&quot;</span>, heapsizeOptsBuf, <span class="string">&quot;-Xmx&quot;</span>, <span class="string">&quot;16m&quot;</span>);<span class="comment">//修改这里</span></span><br><span class="line">    * &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 platform&#x2F;dalvik&#x2F;+&#x2F;eclair-release&#x2F;vm&#x2F;Init.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gDvm.heapSizeStart = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Spec says 16MB; too big for us. </span></span><br><span class="line">gDvm.heapSizeMax = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Spec says 75% physical mem</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="内存指标概念"><a href="#内存指标概念" class="headerlink" title="内存指标概念"></a>内存指标概念</h3><table>
<thead>
<tr>
<th><strong>Item</strong></th>
<th><strong>全称</strong></th>
<th><strong>含义</strong></th>
<th><strong>等价</strong></th>
</tr>
</thead>
<tbody><tr>
<td>USS</td>
<td>Unique Set Size</td>
<td>物理内存</td>
<td>进程独占的内存</td>
</tr>
<tr>
<td>PSS</td>
<td>Proportional Set Size</td>
<td>物理内存</td>
<td>PSS&#x3D; USS+ 按比例包含共享库</td>
</tr>
<tr>
<td>RSS</td>
<td>Resident Set Size</td>
<td>物理内存</td>
<td>RSS&#x3D; USS+ 包含共享库</td>
</tr>
<tr>
<td>VSS</td>
<td>Virtual Set Size</td>
<td>虚拟内存</td>
<td>VSS&#x3D; RSS+ 未分配实际物理内存</td>
</tr>
</tbody></table>
<p>总结:VSS &gt;&#x3D; RSS &gt;&#x3D; PSS &gt;&#x3D; USS,但&#x2F;dev&#x2F;kgsl-3d0部份必须考虑VSS，一般我们只需要考虑PSS</p>
<h3 id="Android内存分配与回收机制"><a href="#Android内存分配与回收机制" class="headerlink" title="Android内存分配与回收机制"></a>Android内存分配与回收机制</h3><p>这部分内容小编已经在之前的章节介绍了</p>
<p>附上链接：<a href="http://banmaman.com/2022/08/13/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">JVM内存管理剖析</a></p>
<h3 id="Android低内存杀进程机制"><a href="#Android低内存杀进程机制" class="headerlink" title="Android低内存杀进程机制"></a>Android低内存杀进程机制</h3><p>Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819151608768.png" alt="image-20220819151608768"></p>
<ul>
<li><p>Empty process(空进程)</p>
</li>
<li><p>Background process(后台进程)</p>
</li>
<li><p>Service process(服务进程)</p>
</li>
<li><p>Visible process(可见进程)</p>
</li>
<li><p>Foreground process(前台进程)</p>
</li>
</ul>
<blockquote>
<p>系统需要进行内存回收时最先回收空进程,然后是后台进程，以此类推最后才会回收前台进程（一般情况</p>
<p>下前台进程就是与用户交互的进程了,如果连前台进程都需要回收那么此时系统几乎不可用了）。</p>
</blockquote>
<p><code>ActivityManagerService</code> 会对所有进程进行评分（存放在变量adj中），然后再讲这个评分更新到内</p>
<p>核，由内核去完成真正的内存回收( lowmemorykiller , Oom_killer )。</p>
<h2 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM"></a>什么是OOM</h2><blockquote>
<p>OOM（OutOfMemoryError）内存溢出错误，在常见的Crash疑难排行榜上，OOM绝对可以名列前茅并且经久不衰。因为它发生时的Crash堆栈信息往往不是导致问题的根本原因，而只是压死骆驼的最后一根稻草</p>
</blockquote>
<h2 id="发生OOM的条件"><a href="#发生OOM的条件" class="headerlink" title="发生OOM的条件"></a>发生OOM的条件</h2><ul>
<li><p>Android 2.x系统 GC LOG中的dalvik allocated + external allocated + 新分配的大小 &gt;&#x3D;</p>
<p>getMemoryClass()值的时候就会发生OOM。 例如，假设有这么一段Dalvik输出的GC LOG：</p>
<p>GC_FOR_MALLOC free 2K, 13% free 32586K&#x2F;37455K, external 8989K&#x2F;10356K, paused 20ms，</p>
<p>那么32586+8989+(新分配23975)&#x3D;65550&gt;64M时，就会发生OOM。</p>
</li>
<li><p>Android 4.x系统 Android 4.x的系统废除了external的计数器，类似bitmap的分配改到dalvik的</p>
<p>java heap中申请，只要allocated + 新分配的内存 &gt;&#x3D; getMemoryClass()的时候就会发生OOM</p>
</li>
</ul>
<h2 id="OOM原因"><a href="#OOM原因" class="headerlink" title="OOM原因"></a>OOM原因</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819152424482.png" alt="image-20220819152424482"></p>
<p>对于应用开发来说，其实只需要关心上述第1、2点以及4即可。</p>
<h2 id="Android内存分析命令介绍"><a href="#Android内存分析命令介绍" class="headerlink" title="Android内存分析命令介绍"></a>Android内存分析命令介绍</h2><p>常用的内存调优分析命令：</p>
<ol>
<li>dumpsys meminfo</li>
<li>procrank</li>
<li>cat  &#x2F;proc&#x2F;meminfo</li>
<li>free</li>
<li>showmap</li>
<li>vmstat</li>
</ol>
<h3 id="dumpsys-meminfo"><a href="#dumpsys-meminfo" class="headerlink" title="dumpsys meminfo"></a>dumpsys meminfo</h3><p>命令：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> dumpsys meminfo [<span class="keyword">App</span>文件名]</span><br></pre></td></tr></table></figure>



<blockquote>
<p>通常可以通过比较Heap Size以及Objects数据的增加来判断发生了内存泄漏</p>
<p>操作方法：首先执行一次<code>dumpsys meminfo</code>，然后再App的各项Activity或者不同App之间跳转，最后再切回来，再执行一次<code>dumpsys meminfo</code>，比较数据变化。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819154734084.png" alt="image-20220819154734084"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819161522100.png" alt="image-20220819161522100"></p>
<p>虽然参数很多，但是我们主要关注Dalvik Heap与TOTAL这两行的内容即可。</p>
<p>相关参数的说明：</p>
<p>Pss Total：是一个进程实际使用的内存，该统计方法包括比例分配共享库占用的内存，即如果有三个进</p>
<p>程共享了一个共享库，则平摊分配该共享库占用的内存。Pss Total统计方法的一个需要注意的地方是如</p>
<p>果使用共享库的一个进程被杀死，则共享库的内存占用按比例分配到其他共享该库的进程中，而不是将</p>
<p>内存资源返回给系统，这种情况下PssTotal不能够准确代表内存返回给系统的情况。</p>
<p>Private Dirty：进程私有的脏页内存大小，该统计方法只包括进程私有的被修改的内存。</p>
<p>Private Clear：进程私有的干净页内存大小，该统计方法只包括进程私有的没有被修改的内存。</p>
<p>Swapped Dirty：被交换的脏页内存大小，该内存与其他进程共享。</p>
<p>其中private Dirty + private Clean &#x3D; Uss，该值是一个进程的使用的私有内存大小，即这些内存唯一被</p>
<p>该进程所有。该统计方法真正描述了运行一个进程需要的内存和杀死一个进程释放的内存情况，是怀疑</p>
<p>内存泄露最好的统计方法。</p>
<p>共享比例：sharing_proportion &#x3D; (Pss Total - private_clean - private_dirty) &#x2F; (shared_clean +</p>
<p>shared_dirty)</p>
<p>享学课堂能够被共享的内存：swappable_pss &#x3D; (sharing_proportion * shared_clean) + private_clean</p>
<p>Native Heap：本地堆使用的内存，包括C&#x2F;C++在堆上分配的内存</p>
<p><strong>Dalvik Heap：dalvik虚拟机使用的内存</strong></p>
<p>Dalvik other：除Dalvik和Native之外分配的内存，包括C&#x2F;C++分配的非堆内存</p>
<p>Cursor：数据库游标文件占用的内存</p>
<p>Ashmem：匿名共享内存</p>
<p>Stack：Dalvik栈占用的内存</p>
<p>Other dev：其他的dev占用的内存</p>
<p>.so mmap：so库占用的内存</p>
<p>.jar mmap：.jar文件占用的内存</p>
<p>.apk mmap：.apk文件占用的内存</p>
<p>.ttf mmap：.ttf文件占用的内存</p>
<p>.dex mmap：.dex文件占用的内存</p>
<p>image mmap：图像文件占用的内存</p>
<p>code mmap：代码文件占用的内存</p>
<p>Other mmap：其他文件占用的内存</p>
<p>Graphics：GPU使用图像时使用的内存</p>
<p>GL：GPU使用GL绘制时使用的内存</p>
<p>Memtrack：GPU使用多媒体、照相机时使用的内存</p>
<p>Unknown：不知道的内存消耗</p>
<p>Heap Size：堆的总内存大小</p>
<p>Heap Alloc：堆分配的内存大小</p>
<p>Heap Free：堆待分配的内存大小</p>
<p>Native Heap | Heap Size : 从mallinfo usmblks获的，当前进程Native堆的最大总共分配内存</p>
<p>Native Heap | Heap Alloc : 从mallinfo uorblks获的，当前进程navtive堆的总共分配内存 </p>
<p>Native Heap | Heap Free : 从mallinfo fordblks获的，当前进程Native堆的剩余内存</p>
<p>Native Heap Size ≈ Native Heap Alloc + Native Heap Free</p>
<p>mallinfo是一个C库，mallinfo()函数提供了各种各样通过malloc()函数分配的内存的统计信息。</p>
<p><strong>Dalvik Heap | Heap Size : 从Runtime totalMemory()获得，Dalvik Heap总共的内存大小</strong></p>
<p><strong>Dalvik Heap | Heap Alloc : 从Runtime totalMemory() - freeMemory()获得，Dalvik Heap分配的内存大小</strong></p>
<p><strong>Dalvik Heap | Heap Free : 从Runtime freeMemory()获得，Dalvik Heap剩余的内存大小</strong></p>
<p><strong>Dalvik Heap Size &#x3D; Dalvik Heap Alloc + Dalvik Heap Free</strong></p>
<p>Obejcts当前进程中的对象个数</p>
<p>Views:当前进程中实例化的视图View对象数量 </p>
<p>ViewRootImpl:当前进程中实例化的视图根ViewRootImpl对象数量</p>
<p>AppContexts:当前进程中实例化的应用上下文ContextImpl对象数量</p>
<p>Activities:当前进程中实例化的Activity对象数量</p>
<p>Assets:当前进程的全局资产数量</p>
<p>AssetManagers:当前进程的全局资产管理数量</p>
<p>Local Binders:当前进程有效的本地binder对象数量</p>
<p>Proxy Binders:当前进程中引用的远程binder对象数量</p>
<p>Death Recipients:当前进程到binder的无效链接数量</p>
<p>OpenSSL Sockets:安全套接字对象数量</p>
<h3 id="procrank"><a href="#procrank" class="headerlink" title="procrank"></a><strong>procrank</strong></h3><blockquote>
<p>功能： 获取所有进程的内存使用的排行榜，排行是以 Pss 的大小而排序。 procrank 命令比 dumpsys meminfo 命令，能输出更详细的VSS&#x2F;RSS&#x2F;PSS&#x2F;USS内存指标。</p>
</blockquote>
<h3 id="cat-x2F-proc-x2F-meminfo"><a href="#cat-x2F-proc-x2F-meminfo" class="headerlink" title="cat &#x2F;proc&#x2F;meminfo"></a><strong>cat &#x2F;proc&#x2F;meminfo</strong></h3><blockquote>
<p>功能：能否查看更加详细的内存信息</p>
</blockquote>
<p>指令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> <span class="built_in">cat</span> /proc/meminfo</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下(结果内存值不带小数点，此处添加小数点的目的是为了便于比对大小)：</p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">root@phone:/ # cat /<span class="keyword">proc</span>/meminfo<span class="title"> </span></span><br><span class="line"><span class="title">MemTotal:</span> 2857.032<span class="title"> kB</span> //RAM可用的总大小 (即物理总内存减去系统预留和内核二进 制代码大小)<span class="title"> </span></span><br><span class="line"><span class="title">MemFree:</span> 1020.708<span class="title"> kB</span> //RAM未使用的大小<span class="title"> </span></span><br><span class="line"><span class="title">Buffers:</span> 75.104<span class="title"> kB</span> //用于文件缓冲<span class="title"> </span></span><br><span class="line"><span class="title">Cached:</span> 448.244<span class="title"> kB</span> //用于高速缓存<span class="title"> </span></span><br><span class="line"><span class="title">SwapCached:</span> 0<span class="title"> kB</span> //用于swap缓存<span class="title"> </span></span><br><span class="line"><span class="title">Active:</span> 832.900<span class="title"> kB</span> //活跃使用状态，记录最近使用过的内存，通常不回收用于其它目的<span class="title"> </span></span><br><span class="line"><span class="title">Inactive:</span> 391.128<span class="title"> kB</span> //非活跃使用状态，记录最近并没有使用过的内存，能够被回 收用于其他目的<span class="title"> </span></span><br><span class="line"><span class="title">Active(anon):</span> 700.744<span class="title"> kB</span> //Active =<span class="title"> Active(anon)</span> +<span class="title"> Active(file)</span> <span class="title"></span></span><br><span class="line"><span class="title">Inactive(anon):</span> 228<span class="title"> kB</span> //Inactive =<span class="title"> Inactive(anon)</span> +<span class="title"> Inactive(file)</span> <span class="title"></span></span><br><span class="line"><span class="title">Active(file):</span> 132.156<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Inactive(file):</span> 390.900<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Unevictable:</span> 0<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Mlocked:</span> 0<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">SwapTotal:</span> 524.284<span class="title"> kB</span> //swap总大小<span class="title"> </span></span><br><span class="line"><span class="title">SwapFree:</span> 524.284<span class="title"> kB</span> //swap可用大小<span class="title"> </span></span><br><span class="line"><span class="title">Dirty:</span> 0<span class="title"> kB</span> //等待往磁盘回写的大小<span class="title"> </span></span><br><span class="line"><span class="title">Writeback:</span> 0<span class="title"> kB</span> //正在往磁盘回写的大小<span class="title"> </span></span><br><span class="line"><span class="title">AnonPages:</span> 700.700<span class="title"> kB</span> //匿名页，用户空间的页表，没有对应的文件<span class="title"> </span></span><br><span class="line"><span class="title">Mapped:</span> 187.096<span class="title"> kB</span> //文件通过mmap分配的内存，用于map设备、文件或者库<span class="title"> </span></span><br><span class="line"><span class="title">Shmem:</span> .312<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Slab:</span> 91.276<span class="title"> kB</span> //kernel数据结构的缓存大小，<span class="title"> </span></span><br><span class="line"><span class="title">Slab=SReclaimable+SUnreclaim</span> <span class="title"></span></span><br><span class="line"><span class="title">SReclaimable:</span> 32.484<span class="title"> kB</span> //可回收的slab的大小<span class="title"> </span></span><br><span class="line"><span class="title">SUnreclaim:</span> 58.792<span class="title"> kB</span> //不可回收slab的大小<span class="title"> </span></span><br><span class="line"><span class="title">KernelStack:</span> 25.024<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">PageTables:</span> 23.752<span class="title"> kB</span> //以最低的页表级<span class="title"></span></span><br><span class="line"><span class="title">NFS_Unstable:</span> 0<span class="title"> kB</span> //不稳定页表的大小<span class="title"></span></span><br><span class="line"><span class="title">Bounce:</span> 0<span class="title"> kB</span></span><br><span class="line">WritebackTmp: 0<span class="title"> kB</span></span><br><span class="line">CommitLimit: 1952.800<span class="title"> kB</span></span><br><span class="line">Committed_AS: 82204.348<span class="title"> kB</span> //评估完成的工作量，代表最糟糕case下的值，该值也包含<span class="title"> swap内存</span></span><br><span class="line">VmallocTotal: 251658.176<span class="title"> kB</span> //总分配的虚拟地址空间<span class="title"></span></span><br><span class="line"><span class="title">VmallocUsed:</span> 166.648<span class="title"> kB</span> //已使用的虚拟地址空间<span class="title"></span></span><br><span class="line"><span class="title">VmallocChunk:</span> 251398.700<span class="title"> kB</span> //虚拟地址空间可用的最大连续内存块</span><br></pre></td></tr></table></figure>

<p>对于cache和buffer也是系统可以使用的内存。所以系统总的可用内存为 MemFree+Buffers+Cached</p>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h3><blockquote>
<p>主功能：查看可用内存，缺省单位KB。该命令比较简单、轻量，专注于查看剩余内存情况。数据来源于&#x2F;proc&#x2F;meminfo。</p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实小编使用过的就只有<code>dumpsys meminfo</code>与<code>cat /proc/meminfo</code>其他的实用情况不多</p>
<ol>
<li>dumpsys meminfo 适用场景： 查看进程的oom adj，或者dalvik&#x2F;native等区域内存情况，或者某</li>
</ol>
<p>   个进程或apk的内存情况，功能非常强大；</p>
<ol start="2">
<li><p>procrank 适用场景： 查看进程的VSS&#x2F;RSS&#x2F;PSS&#x2F;USS各个内存指标；</p>
</li>
<li><p>cat &#x2F;proc&#x2F;meminfo 适用场景： 查看系统的详尽内存信息，包含内核情况；</p>
</li>
<li><p>free 适用场景： 只查看系统的可用内存；</p>
</li>
<li><p>showmap 适用场景： 查看进程的虚拟地址空间的内存分配情况；</p>
</li>
<li><p>vmstat 适用场景： 周期性地打印出进程运行队列、系统切换、CPU时间占比等情况；</p>
</li>
</ol>
<h2 id="Android内存泄漏分析工具"><a href="#Android内存泄漏分析工具" class="headerlink" title="Android内存泄漏分析工具"></a>Android内存泄漏分析工具</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>这个需要在官网下载</p>
<h3 id="Android-Studio-Memory-profiler"><a href="#Android-Studio-Memory-profiler" class="headerlink" title="Android Studio Memory-profiler"></a><strong>Android Studio Memory-profiler</strong></h3><p>就在Android Studio下方菜单栏中</p>
<p>具体用法可参考官网：</p>
<p><a href="https://developer.android.google.cn/studio/profile/memory-profiler#performance">https://developer.android.google.cn/studio/profile/memory-profiler#performance</a></p>
<h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a><strong>LeakCanary</strong></h3><p>检测内存泄漏非常方便的工具</p>
<p>只需要导入，就可以在运行界面查看定位到的内存泄漏位置，以及依赖树</p>
<p><a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p>
<h2 id="Android内存泄漏常见场景以及解决方案"><a href="#Android内存泄漏常见场景以及解决方案" class="headerlink" title="Android内存泄漏常见场景以及解决方案"></a>Android内存泄漏常见场景以及解决方案</h2><h3 id="1、资源性对象未关闭"><a href="#1、资源性对象未关闭" class="headerlink" title="1、资源性对象未关闭"></a>1、资源性对象未关闭</h3><p>对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后再置为null。例如Bitmap等资源未关闭会造成内存泄漏，此时我们应该再Activity销毁时关闭。</p>
<h3 id="2、注册对象未销毁"><a href="#2、注册对象未销毁" class="headerlink" title="2、注册对象未销毁"></a>2、注册对象未销毁</h3><p>例如BroadcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。</p>
<h3 id="3、类的静态变量持有大数据对象"><a href="#3、类的静态变量持有大数据对象" class="headerlink" title="3、类的静态变量持有大数据对象"></a>3、类的静态变量持有大数据对象</h3><p>尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。</p>
<h3 id="4、单例造成的内存泄漏"><a href="#4、单例造成的内存泄漏" class="headerlink" title="4、单例造成的内存泄漏"></a>4、单例造成的内存泄漏</h3><p>优先使用Application的Context，如需使用Activity的Context，可以在传入Context时使用弱引用进行封装，然后，在使用到的地方从弱引用中获取Context，如果获取不到，则直接return即可。</p>
<h3 id="5、非静态内部类的静态实例"><a href="#5、非静态内部类的静态实例" class="headerlink" title="5、非静态内部类的静态实例"></a>5、非静态内部类的静态实例</h3><p>该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。此时，我们可以将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。</p>
<h3 id="Handler临时性内存泄漏"><a href="#Handler临时性内存泄漏" class="headerlink" title="Handler临时性内存泄漏"></a>Handler临时性内存泄漏</h3><p>Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler持有Activity的引用，所以导致Activity的内存资源无法及时回收，引发内存泄漏。解决方案如下：</p>
<ul>
<li>1、使用一个静态Handler内部类，然后对Handler持有的对象(一般是Activity)使用弱引用，这样在回收时，也可以回收Handler持有的对象。</li>
<li>2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。</li>
</ul>
<p>需要注意的是，AsyncTask内部也是Handler机制，同样存在内存泄漏风险，但其一般是临时性的。对于<br>类似AsyncTask或是线程造成的内存泄漏，我们也可以将AsyncTask和Runnable类独立出来或者使用静态内部类。</p>
<h3 id="7、容器中的对象没清理造成的内存泄漏"><a href="#7、容器中的对象没清理造成的内存泄漏" class="headerlink" title="7、容器中的对象没清理造成的内存泄漏"></a>7、容器中的对象没清理造成的内存泄漏</h3><p>在退出程序前，将集合里的东西clear，然后置为null，再退出程序。</p>
<h3 id="8、WebView"><a href="#8、WebView" class="headerlink" title="8、WebView"></a>8、WebView</h3><p>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。我们可以为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p>
<h3 id="9、使用ListView造成的内存泄漏"><a href="#9、使用ListView造成的内存泄漏" class="headerlink" title="9、使用ListView造成的内存泄漏"></a>9、使用ListView造成的内存泄漏</h3><p>在构造Adapter时，使用缓存的convertView。</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>RecyclerView高级用法——吸顶效果</title>
    <url>/2022/07/19/RecycleView%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们对RecyclerView的使用不能仅仅停留在表面，可以探索一些高级的用法——自定义，不过要实现这些的前提是必须对RecycleView的源码流程有所了解。今天小编就略讲一下，主要是和今天的主体有关的内容。我们今天就来实现如下的吸顶效果。</p>
<h3 id="通过绘制实现RecyclerView的吸顶效果"><a href="#通过绘制实现RecyclerView的吸顶效果" class="headerlink" title="通过绘制实现RecyclerView的吸顶效果"></a>通过绘制实现RecyclerView的吸顶效果</h3><p>ItemDecoration</p>
<p>ItemDecoration允许应用给具体的View添加具体的图画或者layout的偏移，对于绘制View之间的分割线，视觉分组边界等等是非常有用的。</p>
<p>当我们调用addItemDecoration()方法添加decoration的时候，RecyclerView就会调用该类的onDraw方法区绘制分割线，也就是说：分割线是绘制出来的。</p>
<blockquote>
<p>RecyclerView.ItemDecoration，该类为抽象类，官方目前只提供了一个实现类DividerItemDecoration。</p>
<p>并且只有LinearLayoutManager能够使用</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220719205304144.png" alt="image-20220719205304144"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C.gif" alt="吸顶效果"></p>
<p>要实现这样的吸顶效果，首先，就需要了解一下RecyclerView.ItemDecoration的绘制流程。</p>
<p>1.onDraw</p>
<p>在绘制每个itemView之前绘制，上图中的每个跟着滑动的头部就是在此处绘制</p>
<p>2.onDrawOver</p>
<p>在绘制了每个ItemView之后绘制，上图中固定的顶部在此处绘制</p>
<p>3.getItemOffsets</p>
<p>设置偏移值，可以在绘制itemView时设置偏移值，其实上demo中的每个头部（红色区域）就是在绘制itemView预留了部分空间用于绘制头部。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220719210625576.png" alt="image-20220719210625576"></p>
<blockquote>
<p>也就是说绘制流程是：onDraw()-&gt;ItemView-&gt;onDrawOver</p>
</blockquote>
<h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul>
<li>在Adapter中创建两个方法<ul>
<li>1.获取组名</li>
<li>2.判断是否是组的头部<ul>
<li>首先，position&#x3D;0一定是组的头部</li>
<li>其次，可以通过前后两次组名判断当前item是不是组的头部</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否是 组的第一个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isGroupHeader</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">String</span> currentName = <span class="built_in">getGroupName</span>(position);</span><br><span class="line">            <span class="type">String</span> preGroupName = <span class="built_in">getGroupName</span>(position<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (preGroupName.<span class="built_in">equals</span>(currentName))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getGroupName</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelList.<span class="built_in">get</span>(position).<span class="built_in">getGroupName</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>自定义分割线</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void on<span class="constructor">Draw(@NonNull Canvas <span class="params">c</span>, @NonNull RecyclerView <span class="params">parent</span>, @NonNull RecyclerView.State <span class="params">state</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Draw(<span class="params">c</span>, <span class="params">parent</span>, <span class="params">state</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent.get<span class="constructor">Adapter()</span> instanceof ModelAdapter)&#123;</span><br><span class="line">            ModelAdapter adapter = (ModelAdapter) parent.get<span class="constructor">Adapter()</span>;</span><br><span class="line">            <span class="built_in">int</span> count  = parent.get<span class="constructor">ChildCount()</span>;</span><br><span class="line">            <span class="built_in">int</span> left = parent.get<span class="constructor">PaddingLeft()</span>;</span><br><span class="line">            <span class="built_in">int</span> right  = parent.get<span class="constructor">Width()</span> - parent.get<span class="constructor">PaddingRight()</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">//获取对应的View</span></span><br><span class="line">                View view = parent.get<span class="constructor">ChildAt(<span class="params">i</span>)</span>;</span><br><span class="line">                <span class="comment">//获取View的布局位置</span></span><br><span class="line">                <span class="built_in">int</span> position = parent.get<span class="constructor">ChildLayoutPosition(<span class="params">view</span>)</span>;</span><br><span class="line">                <span class="comment">//判断是不是头部</span></span><br><span class="line">                boolean isGroupHeader = adapter.is<span class="constructor">GroupHeader(<span class="params">position</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (isGroupHeader<span class="operator"> &amp;&amp; </span>view.get<span class="constructor">Top()</span> - groupHeaderHeight - parent.get<span class="constructor">PaddingTop()</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">view</span>.<span class="params">getTop</span>()</span>-groupHeaderHeight,right,view.get<span class="constructor">Top()</span>,headPaint);</span><br><span class="line">                    String groupName = adapter.get<span class="constructor">GroupName(<span class="params">position</span>)</span>;</span><br><span class="line">                    textPaint.get<span class="constructor">TextBounds(<span class="params">groupName</span>, 0, <span class="params">groupName</span>.<span class="params">length</span>()</span>, textRect);</span><br><span class="line">                    c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">view</span>.<span class="params">getTop</span>()</span>-groupHeaderHeight/<span class="number">2</span>+textRect.height<span class="literal">()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (view.get<span class="constructor">Top()</span> - groupHeaderHeight - parent.get<span class="constructor">PaddingTop()</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//分割线</span></span><br><span class="line">                    c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">view</span>.<span class="params">getTop</span>()</span>-<span class="number">4</span>,right,view.get<span class="constructor">Top()</span>,headPaint);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void on<span class="constructor">DrawOver(@NonNull Canvas <span class="params">c</span>, @NonNull RecyclerView <span class="params">parent</span>, @NonNull RecyclerView.State <span class="params">state</span>)</span> &#123;</span><br><span class="line">       super.on<span class="constructor">DrawOver(<span class="params">c</span>, <span class="params">parent</span>, <span class="params">state</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span> (parent.get<span class="constructor">Adapter()</span> instanceof ModelAdapter)&#123;</span><br><span class="line">           ModelAdapter adapter = (ModelAdapter) parent.get<span class="constructor">Adapter()</span>;</span><br><span class="line">           <span class="comment">//返回可见区域的第一个item的position</span></span><br><span class="line">           <span class="built_in">int</span> position = ((LinearLayoutManager)parent.get<span class="constructor">LayoutManager()</span>).find<span class="constructor">FirstVisibleItemPosition()</span>;</span><br><span class="line">           <span class="comment">//获取对应的position的View</span></span><br><span class="line">           View itemView = parent.find<span class="constructor">ViewHolderForAdapterPosition(<span class="params">position</span>)</span>.itemView;</span><br><span class="line">           <span class="built_in">int</span> left = parent.get<span class="constructor">PaddingLeft()</span>;</span><br><span class="line">           <span class="built_in">int</span> right = parent.get<span class="constructor">Width()</span> - parent.get<span class="constructor">PaddingRight()</span>;</span><br><span class="line">           <span class="built_in">int</span> top = parent.get<span class="constructor">PaddingTop()</span>;</span><br><span class="line">           <span class="comment">//当下一个是组的头部时</span></span><br><span class="line">           boolean isGroupHeader = adapter.is<span class="constructor">GroupHeader(<span class="params">position</span>+1)</span>;</span><br><span class="line">           String groupName = adapter.get<span class="constructor">GroupName(<span class="params">position</span>)</span>;</span><br><span class="line">           textPaint.get<span class="constructor">TextBounds(<span class="params">groupName</span>,0,<span class="params">groupName</span>.<span class="params">length</span>()</span>,textRect);</span><br><span class="line">           <span class="keyword">if</span> (isGroupHeader)&#123;</span><br><span class="line">               <span class="comment">//对顶部进行缩小效果，在视觉上是被下一个组的顶部推进去的</span></span><br><span class="line">               <span class="built_in">int</span> bottom = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(groupHeaderHeight,itemView.get<span class="constructor">Bottom()</span>-parent.get<span class="constructor">PaddingTop()</span>);</span><br><span class="line">               c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">bottom</span>,<span class="params">headPaint</span>)</span>;</span><br><span class="line">               c.clip<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">bottom</span>)</span>;</span><br><span class="line">               c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">top</span>+<span class="params">bottom</span>-<span class="params">groupHeaderHeight</span><span class="operator">/</span>2+<span class="params">textRect</span>.<span class="params">height</span>()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">groupHeaderHeight</span>,<span class="params">headPaint</span>)</span>;</span><br><span class="line">               c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">top</span>+<span class="params">groupHeaderHeight</span><span class="operator">/</span>2+<span class="params">textRect</span>.<span class="params">height</span>()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void getItemOffsets(@N<span class="keyword">on</span>Null Rect <span class="keyword">out</span>Rect, @N<span class="keyword">on</span>Null View view, @N<span class="keyword">on</span>Null RecyclerView <span class="keyword">parent</span>, @N<span class="keyword">on</span>Null RecyclerView.State <span class="keyword">state</span>) &#123;</span><br><span class="line">        super.getItemOffsets(<span class="keyword">out</span>Rect, view, <span class="keyword">parent</span>, <span class="keyword">state</span>);</span><br><span class="line">        if (<span class="keyword">parent</span>.getAdapter() instanceof ModelAdapter)&#123;</span><br><span class="line">            ModelAdapter adapter = (ModelAdapter) <span class="keyword">parent</span>.getAdapter();</span><br><span class="line">            int position = <span class="keyword">parent</span>.getChildAdapterPosition(view);</span><br><span class="line">            boolean isGroupHeader = adapter.isGroupHeader(position);</span><br><span class="line">            //判断itemView是不是头部</span><br><span class="line">            if (isGroupHeader)&#123;</span><br><span class="line">                //如果是头部，预留更大的地方</span><br><span class="line">                <span class="keyword">out</span>Rect.<span class="built_in">set</span>(<span class="number">0</span>,<span class="keyword">group</span>HeaderHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                <span class="keyword">out</span>Rect.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这部分的重点就是自定义分割线（ItemDecoration），弄清绘制顺序以及设置偏移值的作用就简单多了。当然，难点（也不是难点）就是弄清除尺寸参数,特别是尺寸变化引起的换组顶部推动效果。</p>
<p>其次就是特别注意有padding的情况，相信大家看出小编在这设置了顶部padding，有padding的时候需要注意尺寸。（不过有设置padding的情况很少）</p>
<p><a href="https://github.com/gun-ctrl/RecyclerViewPro">全部代码</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>后台默默的劳动者，Service</title>
    <url>/2022/09/16/Service/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>前段时间，小编在修改bug的时候和Service打了不少交道。突然发现，已经很久没碰过Service了，有些东西记忆模糊，那么今天做一个Service总结，方便日后查看。</p>
</blockquote>
<h2 id="Service是什么？"><a href="#Service是什么？" class="headerlink" title="Service是什么？"></a>Service是什么？</h2><p>Service是Android中实现程序后台运行的解决方案，它非常适合执行哪些不需要和用户交互而且要求长期运行的任务。Service的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，Service仍然能够保持正常运行。</p>
<p>不过需要注意的是，Service并不是运行在一个独立的进程中，而是依赖于创建Service时所在的应用程序的进程。当某个应用程序进程被杀时，所有依赖于该进程的Service也会停止运行。</p>
<p>另外，也不要被Service的后台概念所迷惑，实际上Service并不会自动打开线程，所有的代码都是默认运行在主线程中。也就是说，我们需要在Service的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。</p>
<h2 id="Service的基本用法"><a href="#Service的基本用法" class="headerlink" title="Service的基本用法"></a>Service的基本用法</h2><h3 id="定义一个Service"><a href="#定义一个Service" class="headerlink" title="定义一个Service"></a>定义一个Service</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220916115158211.png" alt="image-20220916115158211"></p>
<ul>
<li>MyService：我们将类的名字定义为MyService</li>
<li>Exported：表示是否将这个Service暴露给外部其他程序访问</li>
<li>Enabled：表示是否启用这个Service</li>
</ul>
<p>创建好之后：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，MyService继承自系统的Service类的。目前MyService中可以算是空空如也，但是有一个<code>onBind()</code>方法特别醒目。这个是Service唯一的抽象方法。后面会讲解<code>onBind</code>的使用，这里暂时不用它。</p>
<p>Service中同样有类似于Activity的生命周期方法，这里咱们先使用，后面会讲解Service的生命周期。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些是Service最常用的三个方法，看名字也知道是什么意思，这里就不浪费时间了。</p>
<p>另外，每一个Service都需要在<code>AndroidManifest.xml</code>文件中注册才能生效（这也是四大组件的特点）。不过按照我上述的操作，直接右键New一个Service的话，AndroidStudio就会自动为我们注册，不用再手写，还是很方便的。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">           android:<span class="attribute">name</span>=<span class="string">&quot;.MyService&quot;</span></span><br><span class="line">           android:<span class="attribute">enabled</span>=<span class="string">&quot;true&quot;</span></span><br><span class="line">           android:<span class="attribute">exported</span>=<span class="string">&quot;true&quot;</span>&gt;&lt;/service&gt;</span><br></pre></td></tr></table></figure>



<h3 id="启动和停止Service"><a href="#启动和停止Service" class="headerlink" title="启动和停止Service"></a>启动和停止Service</h3><p>下面是两个按钮触发Service</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.startServiceBtn.setOnClickListener &#123; </span><br><span class="line">           <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">           startService(intent)<span class="comment">//启动Service</span></span><br><span class="line">       &#125;</span><br><span class="line">binding.stopServiceBtn.setOnClickListener &#123; </span><br><span class="line">           <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">           stopService(intent)<span class="comment">//停止Service</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在startServiceBtn按钮的点击事件里，我们构建了一个Intent对象，并调用<code>startService()</code>方法来启动MyService。在stopServiceBtn按钮的点击事件里，我们同样构建了一个Intent对象，并调用<code>stopService()</code>方法来停止MyService。<code>startService()</code>和<code>stopService()</code>方法都是定义在<code>Context</code>类中的，所以我们在Activity里可以直接调用这两个方法。另外，Service也可以自我停止运行，只需要在Service内调用<code>stopself()</code>方法即可。</p>
<blockquote>
<p>从Android8.0之后，应用的后台功能被大幅削减。现在只有当应用保持在前台可见状态的情况下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时可能被系统回收。这样改动，是为了防止许多恶意的应用程序长期在后台占用手机资源，从而导致手机变得越来越卡。</p>
</blockquote>
<p><strong>那么，onCreate()和onStartCommand()方法的区别是什么呢？</strong></p>
<ul>
<li>onCreate()方法是在Service第一次创建的时候调用</li>
<li>而onStartCommand()方法则在每次启动Service的时候都会调用</li>
</ul>
<h3 id="Activity和Service进行通信"><a href="#Activity和Service进行通信" class="headerlink" title="Activity和Service进行通信"></a>Activity和Service进行通信</h3><p>通过上述的例子，我们可以知道Activity只是起到启动Service的作用，启动完之后，二者就基本没有关系了。</p>
<p>那如果我们想Activity与Service有关系，或者说Activity能控制Service，能交互，又该怎么办呢？那就要用到前面被搁置的<code>onBind()</code>。</p>
<p>我们在MyService中模拟提供下载功能，然后在Activity中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的Binder对象来对下载功能进行管理。修改MyService中的代码。如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> : <span class="type">Binder</span></span>()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownloader</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;startDownload executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;getProgress executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里，我们新建了一个DownloadBinder类，并让它继承自Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法。</p>
<p>接着，在MyService中创建了DownloadBinder的实例，然后再onBinder()方法里返回了这个实例，这样MyService中准备的工作就完成了。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> downloadBinder:MyService.DownloadBinder</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span> :ServiceConnection&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">        downloadBinder = service <span class="keyword">as</span> MyService.DownloadBinder</span><br><span class="line">        downloadBinder.startDownloader()</span><br><span class="line">        downloadBinder.getProgress()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">    binding.bindServiceBtn.setOnClickListener &#123; </span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">        bindService(intent,connection,Context.BIND_AUTO_CREATE)<span class="comment">//绑定Service</span></span><br><span class="line">    &#125;</span><br><span class="line">    binding.unbindServiceBtn.setOnClickListener &#123; </span><br><span class="line">        unbindService(connection)<span class="comment">//解绑Service</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><p>首先，我们创建了一个<code>ServiceConnection</code>的匿名内部类实现，并在里面重写了<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法</p>
<ul>
<li>onServiceConnected()：会在Activity与Service成功绑定的时候调用</li>
<li>onServiceDisconnected()：只有在Service的创建进程崩溃或被杀掉的时候才会调用，这个方法不太常用</li>
</ul>
<p>在<code>onServiceConnected()</code>方法中，我们通过向下转型得到了DownloadBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。</p>
</li>
<li><p>当然，需要真正的绑定还需要<code>bindService()</code>，需要三个参数：</p>
<ul>
<li>Intent对象</li>
<li>ServiceConnection实例，已经创建</li>
<li>一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service进行绑定后自动创建Service。这会使得MyServicede onCreate()方法得到执行，但onStartCommand()方法不会执行。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220916163946370.png" alt="image-20220916163946370"></p>
<blockquote>
<p>一旦在项目中的任何位置调用了Context的startService()方法，相应的Service就会启动，并回调onStartCommand()方法。如果这个Service之前还没有创建过，onCreate()方法会先于onStartCommand()方法执行。Service启动之后会一直保持运行状态，直到stopService()或stopself()方法被调用，或者被系统回收。注意，虽然每调用一次startService()方法，onStartCommaned()就会执行一次，但实际上每个Service只会保存一个实例。虽然不管你调用了多少次startService()方法，只需调用一次stopService()或stopself()方法，Service就会停止。</p>
<p>另外，还可以调用Context的bindService()来获取一个Service的持久连接，这时就会回调Service中的onBind()方法。类似地，如果这个Service之前还没有创建过，onCreate()方法会先于onBind()方法执行。之后，调用方可以获取到onBind()方法里返回地IBinder对象的实例，这样就能自由地和Service进行通信了。只要调用方和Service之间的连接没有断开，Service就会一直保持运行状态，直到被系统回收。</p>
<p>当调用了startService()方法后，再去调用stopService()方法。这时，Service中的onDestroy()方法就会执行，表示Service已经销毁。类似的，当调用了bindService()方法后，再去调用unbindService()方法，onDestroy()方法也会执行，这两种情况都很好理解。但是需要注意，我们是完全有可能对一个Service既调用了startService()又调用了bindService()方法，在这种情况下该如何让Service销毁呢？根据Android系统的机制，一个Service只要被启动或绑定了之后，就会处于运行状态，必须要让以上两种条件同时不满足，Service才能被销毁。所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。</p>
</blockquote>
<h2 id="前台Service"><a href="#前台Service" class="headerlink" title="前台Service"></a>前台Service</h2><blockquote>
<p>前面说过，Android8.0以后，只有当应用保持在前台可见状态下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时都有可能被系统回收。而你如果希望Service能够一直保持运行状态，就可以考虑使用前台Service。前台Service与后台Service最大的区别就在于，它一直会有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。比如你的音乐、导航都用到了前台Service。</p>
</blockquote>
<p>由于状态栏一直有一个正在运行的图标，相当于我们的应用以另外一种形式保持在前台可见状态，所以系统不会倾向于回收前台Service。另外，用户也可以通过下拉状态栏清楚地直到当前什么应用正在运行，因此也不存在某些应用长期在后台偷偷占用手机资源的情况。</p>
<p>下面来看一下如何创建前台Service。</p>
<p>首先，需要在<code>AndroidManifest.xml</code>中加入权限</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> : <span class="type">Binder</span></span>()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownloader</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;startDownload executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;getProgress executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class="line">            <span class="keyword">val</span> channel = NotificationChannel(<span class="string">&quot;my_service&quot;</span>,<span class="string">&quot;前台Service通知&quot;</span>,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">&quot;my_service&quot;</span>)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;This is content title&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;This is content text&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_launcher_foreground)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(resources, androidx.loader.R.drawable.notification_bg))</span><br><span class="line">            .setContentIntent(pi)</span><br><span class="line">            .build()</span><br><span class="line">        startForeground(<span class="number">1</span>,notification)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，这里只是修改了onCreate()方法中的代码，相信大家对这部分代码都比较熟悉——没错，就是创建通知（后续，小编会加一章关于通知的文章）。</p>
<ul>
<li>创建通知渠道<code>channel</code></li>
<li><code>PendingIntent</code>用于让通知实现可点击进入应用</li>
<li>然后是通知的创建<code>notification</code></li>
</ul>
<p>调用startForeground()方法，两个参数：</p>
<ul>
<li>通知的id</li>
<li>构建的Notification对象</li>
</ul>
</blockquote>
<p>看一下效果：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_09_16_17_53_49_838.gif" alt="录制_2022_09_16_17_53_49_838"></p>
<h2 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h2><p>Service中的代码都是默认运行在主线程，如果直接在Service里处理一些耗时任务，同样很容易出现ANR。</p>
<p>解决方法是开启一个子线程，并且还要记得线程执行完后主动<code>stopself()</code>或调用<code>stopService()</code>。</p>
<p><strong>是不是很麻烦？！</strong>因为程序要很可能会忘记开线程，或者忘记调用<code>stopself()</code>。</p>
<p>这个时候，我们的主角IntentService就诞生了！！！一个集Service、HandlerThread、Handler一身的“天才”（感兴趣的读者可以查一下它的原理，或者如果有需要可以联系小编出一期关于Handler和HandlerThread的文章，小编可以尝试聊聊它们的原理）</p>
<p>使用那就很简单了，不然我们怎么会用它呢，直接上代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> : <span class="type">IntentService</span></span>(<span class="string">&quot;MyIntentService&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHandleIntent</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//用于处理耗时任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建方式也是与Service一样，可以右键直接new一个，亦或创建个类继承IntentService，同样的使用后者这种方式别忘了注册。</p>
<p>这里就不介绍使用了，因为IntentService和Service的使用一摸一样，而且大家分别打印Activity和IntentService中的当前线程<code>Thread.currentThread().name</code>就会发现，IntentService自动为我们完成了线程切换，当然，这一切还是归功于Handler。</p>
<p>参考资料：《第一行代码》</p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>Service总结</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView的回收复用机制</title>
    <url>/2022/07/24/RecyclerView%E7%9A%84%E5%9B%9E%E6%94%B6%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章，小编介绍了RecyclerView的高级用法——自定义LayoutManager。今天，我们来从源码的角度深度剖析RecyclerView，主要是对RecyclerView的回收复用机制熟悉掌握。</p>
<h2 id="RecyclerView介绍"><a href="#RecyclerView介绍" class="headerlink" title="RecyclerView介绍"></a>RecyclerView介绍</h2><blockquote>
<p>RecyclerView可以说是项目必备的系统高级控件，相比于传统的ListVIew，RecyclerView最大的优势就是四级缓存机制，ListView是两级缓存机制（屏幕内可见、屏幕外）。</p>
</blockquote>
<h3 id="四级缓存机制"><a href="#四级缓存机制" class="headerlink" title="四级缓存机制"></a>四级缓存机制</h3><ul>
<li><p>mChangeScrap（主要与动画相关）与mAttachedScrap（一般这两算一级）</p>
<p>用来缓存还在屏幕内的ViewHolder</p>
</li>
<li><p>mCachedViews</p>
<p>用来缓存移除屏幕之外的ViewHolder</p>
</li>
<li><p>mViewCacheExtension</p>
<p>用户的自定义扩展缓存，需要用户自己管理View的创建和缓存</p>
</li>
<li><p>RecyclerViewPool</p>
<p>ViewHolder缓存池</p>
</li>
</ul>
<h3 id="回收复用的入口"><a href="#回收复用的入口" class="headerlink" title="回收复用的入口"></a>回收复用的入口</h3><p>上一章中自定义LayoutManager中有<code> detachAndScrapAttachedViews(recycler!!)</code>这样一个方法，用于回收ViewHolder。下面就来介绍一下RecyclerView的回收。</p>
<p>回收有两个入口，一是布局onLayout时，二是在fill填充itemVIew时</p>
<ul>
<li>onLayout</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220724172908391.png" alt="image-20220724172908391"></p>
<p>1.因为RecyclerView的具体onLayout是交给具体的LayoutManager来实现的，所以回收复用的具体操作是由LayoutManager来完成，在自定义LayoutManager时需考虑这一点，参考系统提供的LinearLayoutManager</p>
<p>2.上图的两个重心是LinearLayoutManager中回收入口的分叉和Recycler中的实际回收情况，而我们在自定义LayoutManager时，回收Holder只需要通过detachAndScrapAttachedViews这一个方法即可，具体是如何进行回收的我们不关心，但需要知道有哪几种，因为这对应了几种缓存，上面已经介绍了四级缓存。</p>
<p>3.缓存池与mCacheViews的关系：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144808720.png" alt="image-20220717144808720"></p>
<blockquote>
<p> <strong>注意：</strong>缓存池中保存的只是ViewHolder，没有数据，所以缓存池中的ViewHolder复用还需要绑定</p>
</blockquote>
<ul>
<li><p>fill</p>
<p>在fill中只考虑了recycleViewHolderInternal这种情况，滑动过程中会触发</p>
</li>
</ul>
<p><strong>回收重要源码截图</strong></p>
<blockquote>
<p>如果觉得上述回收流程图理解起来抽象的，可见结合部分源码截图理解。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717115957690.png" alt="image-20220717115957690"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717121349370.png" alt="image-20220717121349370"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717141954608.png" alt="image-20220717141954608"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717142707778.png"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717142831116.png" alt="image-20220717142831116"></p>
<blockquote>
<p>如果超过mCacheView最大值（2），就加入到缓存池</p>
<p>缓存到缓存池之后，就从mCacheView中移除</p>
<p>从“0”拿出，说明是先进先出的</p>
</blockquote>
<ul>
<li>否则，直接进缓存池  和上面一样都是调用<code>addViewHolderToRecycledViewPool</code></li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717143953794.png" alt="image-20220717143953794"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144255403.png" alt="image-20220717144255403"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144354585.png" alt="image-20220717144354585"></p>
<blockquote>
<p>ScrapData -&gt; ArrayList<ViewHolder></p>
<p>mScrap-&gt;SpareArray<ScrapData></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144443187.png" alt="image-20220717144443187"></p>
</blockquote>
<p><strong>recycler.scrapView()</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717153414420.png" alt="image-20220717153414420"></p>
<p><strong>ViewHolder的包装源码</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120045307.png" alt="image-20220717120045307"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120201306.png" alt="image-20220717120201306"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120910841.png" alt="image-20220717120910841"></p>
<h3 id="复用入口"><a href="#复用入口" class="headerlink" title="复用入口"></a>复用入口</h3><blockquote>
<p>复用的入口点同样也是两个，分别是布局时与滑动时。</p>
</blockquote>
<ul>
<li><p>onLayout</p>
<p>上一章中我们在自定义LayoutManager中就是重写的下面的<code>4.onLayoutChildren</code></p>
</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717165422042.png" alt="image-20220717165422042"></p>
<ul>
<li>onTouch</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220724174858215.png" alt="image-20220724174858215"></p>
<p>其实二者雷同，从fill入口开始，onLayout与onTouch几乎一样，只是第一张图用的时序图，绘制的比较详细。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们阅读源码了解原理机制，不用记住每个方法的入口、流程细节等，只需要记住大致过程，并理解重要部分。比如RecyclerView的四级缓存，以及回收复用的大致过程。</p>
<p>这章的几个重点：</p>
<p>1.从mAttachedScrap、mChangedScrap、mCachedViews中取出的holder不需要再绑定数据</p>
<p>2.从RecyclerPool取出的holder需要重新绑定数据</p>
<p>3.mAttachedScrap、mChangedScrap缓存的是屏幕看到的holder</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wiwiyiyi.com/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#%E5%9B%9B-%E6%80%BB%E7%BB%93">https://wiwiyiyi.com/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#%E5%9B%9B-%E6%80%BB%E7%BB%93</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
  <entry>
    <title>adb命令</title>
    <url>/2022/07/19/adb%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文为小编学习总结的一些adb的常用命令，可能一些命令有待验证，更多内容可以参考<a href="https://github.com/mzlogin/awesome-adb#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">adb用法大全</a></p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="语法命令"><a href="#语法命令" class="headerlink" title="语法命令"></a>语法命令</h4><p>adb 命令的基本语法如下：<br>adb [ -d| -e| -s <sericalNumber>] <command><br>如果只有一个设备&#x2F;模拟器连接时，可以省略掉[ -d| -e| -s] <sericalNumber>] 这一部分，直接使用adb <command>。</p>
<h4 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h4><p>如果有多个设备&#x2F;模拟器,则需要为命令指定目标设备</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>-d</td>
<td align="left">指定当前唯一通过 USB 连接的 Android 设备为命令目标</td>
</tr>
<tr>
<td>-e</td>
<td align="left">指定当前唯一运行的模拟器为目标命令</td>
</tr>
<tr>
<td>-s<serialNumber></td>
<td align="left">指定相应 serialNumber 号的设备&#x2F;模拟器为命令目标</td>
</tr>
</tbody></table>
<h2 id="常用adb命令"><a href="#常用adb命令" class="headerlink" title="常用adb命令"></a>常用adb命令</h2><h3 id="查看adb版本号"><a href="#查看adb版本号" class="headerlink" title="查看adb版本号"></a>查看adb版本号</h3><p>adb version</p>
<h3 id="查看已连接设备"><a href="#查看已连接设备" class="headerlink" title="查看已连接设备"></a>查看已连接设备</h3><p>adb devices</p>
<h3 id="查看手机序列号"><a href="#查看手机序列号" class="headerlink" title="查看手机序列号"></a>查看手机序列号</h3><p>adb get-serialno<br>如返回127.0.0.1:7555</p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>adb logcat</p>
<blockquote>
<p>adb logcat -c 清除日志<br>adb logcat | grep “tag” 过滤日志 这里的tag就是你打印日志的时候需要设置的第一个参数TAG，通过TAG我们可以很轻松的过滤出我们想要的日志，轻松高效。</p>
</blockquote>
<h3 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h3><p>adb install [apk文件的路径]</p>
<blockquote>
<p>adb install douyin.apk</p>
</blockquote>
<ul>
<li>多个设备安装apk<br>adb -s [设备号] install [apk文件的路径]<blockquote>
<p>adb -s 127.0.0.1:7555 install douyin.apk</p>
</blockquote>
</li>
<li>如果apk已经存在，需要覆盖安装</li>
<li>adb install -r [apk文件的路径]<blockquote>
<p>adb install -r douyin.apk</p>
</blockquote>
</li>
</ul>
<p>adb install后面可以跟一些可选参数来控制安装APK的行为，可选参数及含义如下</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>-l</td>
<td align="left">将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td>
</tr>
<tr>
<td>-r</td>
<td align="left">允许覆盖安装</td>
</tr>
<tr>
<td>-t</td>
<td align="left">允许安装AndroidMainfest.xml里application指定<code>android:testOnly=&quot;true&quot;</code>的应用</td>
</tr>
<tr>
<td>-s</td>
<td align="left">应用安装到sdcard</td>
</tr>
<tr>
<td>-d</td>
<td align="left">允许降级覆盖安装</td>
</tr>
<tr>
<td>-g</td>
<td align="left">授予所有运行时权限</td>
</tr>
<tr>
<td>–abi abi-identifier</td>
<td align="left">为特定ABI强制安装apk，abi-identifier可以是armeabi-v7a、arm64-v8a、v86、x86_64 等</td>
</tr>
</tbody></table>
<h3 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h3><ul>
<li>普通卸载</li>
<li>adb uninstall [apk文件的路径]<blockquote>
<p>adb uninstall douyin.apk</p>
</blockquote>
</li>
<li>卸载但是保留数据</li>
<li>adb uninstall -k [apk文件的路径]<blockquote>
<p>adb uninstall -k douyin.apk</p>
</blockquote>
</li>
</ul>
<h3 id="获取手机root权限"><a href="#获取手机root权限" class="headerlink" title="获取手机root权限"></a>获取手机root权限</h3><p>adb root</p>
<h3 id="连接不稳定时需要挂载"><a href="#连接不稳定时需要挂载" class="headerlink" title="连接不稳定时需要挂载"></a>连接不稳定时需要挂载</h3><p>adb remount</p>
<h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><ul>
<li>正常重启<br>adb reboot</li>
<li>重启手机到recovery<br>adb reboot recovery</li>
<li>重启到bootloader界面<br>adb reboot bootloader</li>
</ul>
<h3 id="关闭adb服务"><a href="#关闭adb服务" class="headerlink" title="关闭adb服务"></a>关闭adb服务</h3><p>adb kill -server</p>
<h3 id="启动adb服务"><a href="#启动adb服务" class="headerlink" title="启动adb服务"></a>启动adb服务</h3><p>adb start -server</p>
<h3 id="查看手机设备型号"><a href="#查看手机设备型号" class="headerlink" title="查看手机设备型号"></a>查看手机设备型号</h3><p>adb shell getprop ro.product.model<br>如返回MI 8</p>
<h3 id="查看设备的Android版本"><a href="#查看设备的Android版本" class="headerlink" title="查看设备的Android版本"></a>查看设备的Android版本</h3><p>adb shell getprop ro.build.version.release</p>
<h3 id="获取手机厂商名称"><a href="#获取手机厂商名称" class="headerlink" title="获取手机厂商名称"></a>获取手机厂商名称</h3><p>adb shell getprop ro.product.brand<br>如返回Xiaomi</p>
<h3 id="获取手机SDK版本"><a href="#获取手机SDK版本" class="headerlink" title="获取手机SDK版本"></a>获取手机SDK版本</h3><p>adb shell getprop ro.build.version.sdk</p>
<h3 id="查看手机分辨率"><a href="#查看手机分辨率" class="headerlink" title="查看手机分辨率"></a>查看手机分辨率</h3><p>adb shell wm size</p>
<h3 id="查看屏幕密度"><a href="#查看屏幕密度" class="headerlink" title="查看屏幕密度"></a>查看屏幕密度</h3><p>adb shell wm density<br><strong>修改屏幕密度</strong><br>adb shell wm density 160<br><strong>恢复原屏幕密度</strong><br>adb shell wm density reset</p>
<h3 id="查看手机的mac地址"><a href="#查看手机的mac地址" class="headerlink" title="查看手机的mac地址"></a>查看手机的mac地址</h3><p>adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address</p>
<h3 id="查看电池信息"><a href="#查看电池信息" class="headerlink" title="查看电池信息"></a>查看电池信息</h3><p>adb shell dumpsys battery</p>
<h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>adb shell ps</p>
<h3 id="查看CPU使用情况"><a href="#查看CPU使用情况" class="headerlink" title="查看CPU使用情况"></a>查看CPU使用情况</h3><p>adb shell top</p>
<h3 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h3><p>adb shell cat &#x2F;proc&#x2F;cpuinfo</p>
<h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>adb shell cat &#x2F;proc&#x2F;meminfo</p>
<h3 id="查看手机上所有安装的app包名"><a href="#查看手机上所有安装的app包名" class="headerlink" title="查看手机上所有安装的app包名"></a>查看手机上所有安装的app包名</h3><p>adb shell pm list packages</p>
<blockquote>
<p>adb shell pm list packages -s 查看所有系统app的包名<br>adb shell pm list packages -3 查看所有第三方app的包名<br>adb shell pm list packages | grep [包名] 使用grep筛选所有满足要求的app包名</p>
</blockquote>
<h3 id="清除应用数据"><a href="#清除应用数据" class="headerlink" title="清除应用数据"></a>清除应用数据</h3><p>adb shell pm clear [<packagename>]</p>
<blockquote>
<p>当你只是想要清除一个apk的某些数据来复现某些操作的时候，这个命令就显得额外重要。它可以避免我们重装apk来完成这个操作。</p>
</blockquote>
<h3 id="获取某个应用包名的启动入口"><a href="#获取某个应用包名的启动入口" class="headerlink" title="获取某个应用包名的启动入口"></a>获取某个应用包名的启动入口</h3><ul>
<li>adb shell dumpsys package com.ss.android.ugc.aweme|findstr activity</li>
<li>com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity 这个就是抖音的入口<blockquote>
<p>adb shell dumpsys package com.ss.android29111 com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity</p>
</blockquote>
</li>
</ul>
<h3 id="屏幕截屏"><a href="#屏幕截屏" class="headerlink" title="屏幕截屏"></a>屏幕截屏</h3><p>adb shell screencap [保存路径]</p>
<blockquote>
<p>adb shell screencap &#x2F;sdcard&#x2F;screen.png</p>
</blockquote>
<h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><p>adb shell screenrecord [保存路径]</p>
<p>也可以使用（adb版本太老的话，需要更新adb）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">exec</span><span class="operator">-</span><span class="keyword">out</span> screencap  <span class="operator">&gt;</span> sc.png</span><br></pre></td></tr></table></figure>

<h3 id="上传文件到手机"><a href="#上传文件到手机" class="headerlink" title="上传文件到手机"></a>上传文件到手机</h3><p>adb push [电脑文件路径] [手机文件保存路径]</p>
<blockquote>
<p>adb push douyin.apk sdcard&#x2F;douyin.apk</p>
</blockquote>
<h3 id="从手机端下载文件"><a href="#从手机端下载文件" class="headerlink" title="从手机端下载文件"></a>从手机端下载文件</h3><p>adb pull [手机上文件路径]<br><strong>注意：</strong>此时没有指定上传到电脑的路径，会默认上传到adb程序所在的路径</p>
<blockquote>
<p>adb pull sdcard&#x2F;douyin.apk</p>
</blockquote>
<p>指定上传路径：adb pull [手机上文件的路径] [电脑文件的路径]</p>
<blockquote>
<p>adb pull &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;app&#x2F;txt.mp4 D:&#x2F;ADB&#x2F;tet.mp4</p>
</blockquote>
<h3 id="模拟屏幕点击事件"><a href="#模拟屏幕点击事件" class="headerlink" title="模拟屏幕点击事件"></a>模拟屏幕点击事件</h3><p>adb shell input tap x坐标轴 y坐标轴</p>
<blockquote>
<p>adb shell input tap 500 1450</p>
</blockquote>
<h3 id="模拟手势滑动事件"><a href="#模拟手势滑动事件" class="headerlink" title="模拟手势滑动事件"></a>模拟手势滑动事件</h3><p>adb shell input swipe 开始x轴 开始y轴 结束x轴 结束y轴 过程持续时间</p>
<blockquote>
<p>adb shell input swipe 100 500 100 1450 100</p>
</blockquote>
<h3 id="模拟点击键盘按钮"><a href="#模拟点击键盘按钮" class="headerlink" title="模拟点击键盘按钮"></a>模拟点击键盘按钮</h3><p>adb shell input keyevent [key值]</p>
<blockquote>
<p>adb shell input keyevent 25</p>
</blockquote>
<p>一些常用的keyevent键值信息</p>
<table>
<thead>
<tr>
<th>keyevent</th>
<th align="left">效果</th>
</tr>
</thead>
<tbody><tr>
<td>3</td>
<td align="left">Home键</td>
</tr>
<tr>
<td>5</td>
<td align="left">拨号键</td>
</tr>
<tr>
<td>6</td>
<td align="left">挂机键</td>
</tr>
<tr>
<td>19</td>
<td align="left">向上</td>
</tr>
<tr>
<td>20</td>
<td align="left">向下</td>
</tr>
<tr>
<td>21</td>
<td align="left">向左</td>
</tr>
<tr>
<td>22</td>
<td align="left">向右</td>
</tr>
<tr>
<td>24</td>
<td align="left">音量加</td>
</tr>
<tr>
<td>25</td>
<td align="left">音量减</td>
</tr>
<tr>
<td>26</td>
<td align="left">电源</td>
</tr>
<tr>
<td>27</td>
<td align="left">拍照键</td>
</tr>
<tr>
<td>66</td>
<td align="left">回车键</td>
</tr>
<tr>
<td>67</td>
<td align="left">退格键</td>
</tr>
<tr>
<td>82</td>
<td align="left">菜单键</td>
</tr>
<tr>
<td>83</td>
<td align="left">通知键</td>
</tr>
<tr>
<td>84</td>
<td align="left">搜索键</td>
</tr>
<tr>
<td>92</td>
<td align="left">向上翻页</td>
</tr>
<tr>
<td>93</td>
<td align="left">向下翻页</td>
</tr>
<tr>
<td>111</td>
<td align="left">esc键</td>
</tr>
<tr>
<td>112</td>
<td align="left">删除键</td>
</tr>
<tr>
<td>115</td>
<td align="left">大写锁定键</td>
</tr>
<tr>
<td>122</td>
<td align="left">光标移动到开始键</td>
</tr>
<tr>
<td>123</td>
<td align="left">光标移动到末尾键</td>
</tr>
<tr>
<td>143</td>
<td align="left">小键盘锁</td>
</tr>
<tr>
<td>168</td>
<td align="left">放大键</td>
</tr>
<tr>
<td>169</td>
<td align="left">缩小键</td>
</tr>
</tbody></table>
<h3 id="向屏幕输入一些信息"><a href="#向屏幕输入一些信息" class="headerlink" title="向屏幕输入一些信息"></a>向屏幕输入一些信息</h3><ul>
<li>db shell input text [字符串信息]</li>
<li>%s是空格<blockquote>
<p>db shell input text “insert%stext%shere”</p>
</blockquote>
</li>
</ul>
<h3 id="查看前台Activity"><a href="#查看前台Activity" class="headerlink" title="查看前台Activity"></a>查看前台Activity</h3><p>同时小编也是通过这种方式获取到应用包的入口<br>adb shell dumpsys activity activities | findstr mResumedActivity<br>获取到了QQ的启动入口<br><img src="https://upload-images.jianshu.io/upload_images/20123021-1584e1eac4dde441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h3 id="启动某个app"><a href="#启动某个app" class="headerlink" title="启动某个app"></a>启动某个app</h3><p>adb shell am start -n [包名]&#x2F;[启动入口]</p>
<blockquote>
<p>adb shel am start -n com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity<br>Strating:Intent{cmp&#x3D;com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity}</p>
</blockquote>
<p>启动qq</p>
<blockquote>
<p>adb shell am start -n com.tencent.mobileqq&#x2F;.activity.SplashActivity</p>
</blockquote>
<p>启动有道词典<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-307c3a0c81650606.png" alt="image.png"></p>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>adb shell am broadcast -a “broadcastactionfilter”</p>
<blockquote>
<p>adb shell am broadcast -a “broadcastactionfilter”</p>
</blockquote>
<h3 id="使用自带浏览器打开网页"><a href="#使用自带浏览器打开网页" class="headerlink" title="使用自带浏览器打开网页"></a>使用自带浏览器打开网页</h3><p>adb shell am start -a [浏览器包名] -d [网址]</p>
<blockquote>
<p>adb shell am start -a “android.intent.action.VIEW” -d <a href="https://www.google.com/">https://www.google.com</a></p>
</blockquote>
<h3 id="获取手机内部存储信息"><a href="#获取手机内部存储信息" class="headerlink" title="获取手机内部存储信息"></a>获取手机内部存储信息</h3><p>adb shell df &#x2F;data</p>
<h2 id="关于ADB-IDEA"><a href="#关于ADB-IDEA" class="headerlink" title="关于ADB IDEA"></a>关于ADB IDEA</h2><p>AS插件ADB IDEA，装了这款插件可以直接在AS中快速操作一些ADB命令</p>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>1、双击shift -&gt; 点击action -&gt;搜索adb<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-5f962d67d5267c67.png" alt="image.png"></p>
<p>2、Ctrl + Shift + A，快捷键直接调用<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-0cb20333cd5ab9ca.png" alt="image.png"></p>
<h2 id="一些琐碎小问题"><a href="#一些琐碎小问题" class="headerlink" title="一些琐碎小问题"></a>一些琐碎小问题</h2><h4 id="不知应用包的入口Activity如何启动应用包"><a href="#不知应用包的入口Activity如何启动应用包" class="headerlink" title="不知应用包的入口Activity如何启动应用包"></a>不知应用包的入口Activity如何启动应用包</h4><p>1.通过category</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell monkey -<span class="selector-tag">p</span> &lt;packagename&gt; -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li><a href="https://www.jianshu.com/p/150139c8295a">adb获取应用包入口的方案</a></li>
</ol>
<h4 id="adb-shell-input-text无法响应中文输入的问题"><a href="#adb-shell-input-text无法响应中文输入的问题" class="headerlink" title="adb shell input text无法响应中文输入的问题"></a>adb shell input text无法响应中文输入的问题</h4><p><a href="http://banmaman.com/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">adb shell input text不能输入中文的解决方案</a></p>
<h2 id="adb部分总结"><a href="#adb部分总结" class="headerlink" title="adb部分总结"></a>adb部分总结</h2><p><a href="https://www.jianshu.com/p/f6fa6759e747">adb小结</a></p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>adb小结</title>
    <url>/2022/07/26/adb%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><a href="http://banmaman.com/2022/07/19/adb%E5%91%BD%E4%BB%A4/">adb常用命令</a></p>
<h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用am<command>命令，常用的<command>如下</p>
<table>
<thead>
<tr>
<th>command</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td>start [options] <INTENT></td>
<td align="left">启动 <INTENT> 指定的 Activity</td>
</tr>
<tr>
<td>startservice [options] <INTENT></td>
<td align="left">启动 <INTENT> 指定的 Service</td>
</tr>
<tr>
<td>broadcast [options] <INTENT></td>
<td align="left">发送 <INTENT> 指定的广播</td>
</tr>
<tr>
<td>force-stop <packagename></td>
<td align="left">停止 <packagename> 相关的进程</td>
</tr>
<tr>
<td><INTENT> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</td>
<td align="left"></td>
</tr>
<tr>
<td>用于决定intent对象的选项如下：</td>
<td align="left"></td>
</tr>
<tr>
<td>参数</td>
<td align="left">含义</td>
</tr>
<tr>
<td>—-</td>
<td align="left">:—-</td>
</tr>
<tr>
<td>-a <ACTION></td>
<td align="left">指定 action，比如 android.intent.action.VIEW</td>
</tr>
<tr>
<td>-c <CATEGORY></td>
<td align="left">指定 category，比如 android.intent.category.APP_CONTACTS</td>
</tr>
<tr>
<td>-n <COMPONENT></td>
<td align="left">指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app&#x2F;.ExampleActivity</td>
</tr>
</tbody></table>
<p><INTENT> 里还能带数据，就像写代码时的 Bundle 一样：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>–esn <EXTRA_KEY></td>
<td align="left">null 值（只有 key 名）</td>
</tr>
<tr>
<td>–es <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE></td>
<td align="left">string 值</td>
</tr>
<tr>
<td>–ez <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE></td>
<td align="left">boolean 值</td>
</tr>
<tr>
<td>–ei <EXTRA_KEY> <EXTRA_INT_VALUE></td>
<td align="left">integer 值</td>
</tr>
<tr>
<td>–el <EXTRA_KEY> <EXTRA_LONG_VALUE></td>
<td align="left">long 值</td>
</tr>
<tr>
<td>–ef <EXTRA_KEY> <EXTRA_FLOAT_VALUE></td>
<td align="left">float 值</td>
</tr>
<tr>
<td>–eu <EXTRA_KEY> <EXTRA_URI_VALUE></td>
<td align="left">URI</td>
</tr>
<tr>
<td>–ecn <EXTRA_KEY> <EXTRA_COMPONENT_NAME_VALUE></td>
<td align="left">component name</td>
</tr>
<tr>
<td>–eia <EXTRA_KEY> <EXTRA_INT_VALUE>[,&lt;EXTRA_INT_VALUE…]</td>
<td align="left">integer 数组</td>
</tr>
<tr>
<td>–ela <EXTRA_KEY> <EXTRA_LONG_VALUE>[,&lt;EXTRA_LONG_VALUE…]</td>
<td align="left">long 数组</td>
</tr>
</tbody></table>
<h3 id="启动应用-x2F-调起Activity"><a href="#启动应用-x2F-调起Activity" class="headerlink" title="启动应用&#x2F;调起Activity"></a>启动应用&#x2F;调起Activity</h3><h4 id="指定Activity名称启动"><a href="#指定Activity名称启动" class="headerlink" title="指定Activity名称启动"></a>指定Activity名称启动</h4><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> start [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<p>调起微信并传给它 string 数据键值对 <code>toast - hello, world</code>。<br><img src="https://upload-images.jianshu.io/upload_images/20123021-e42736fb5ede5c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="不指定Activity名称启动-启动主Activity"><a href="#不指定Activity名称启动-启动主Activity" class="headerlink" title="不指定Activity名称启动(启动主Activity)"></a>不指定Activity名称启动(启动主Activity)</h4><p>命令格式：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell monkey -<span class="selector-tag">p</span> &lt;packagename&gt; -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>启动QQ<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-a315569b2b8ab380.png" alt="image.png"></p>
<h3 id="调起Service"><a href="#调起Service" class="headerlink" title="调起Service"></a>调起Service</h3><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> startservice [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如：<br>调起微信的某Service</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com<span class="selector-class">.tencent</span>.mm/<span class="selector-class">.plugin</span><span class="selector-class">.accountsync</span><span class="selector-class">.model</span>.AccountAuthenticatorService</span><br></pre></td></tr></table></figure>
<p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> startservice -n <span class="keyword">com</span>.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure>
<h3 id="停止Service"><a href="#停止Service" class="headerlink" title="停止Service"></a>停止Service</h3><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> stopservice [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> broadcast [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以向所有组件广播，也可以向指定组件广播<br>例如，向所有组件广播：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -<span class="selector-tag">a</span> android<span class="selector-class">.intent</span><span class="selector-class">.action</span>.BOOT_COMPLETED</span><br></pre></td></tr></table></figure>
<p>又例如，只向<code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code>广播</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -<span class="selector-tag">a</span> android<span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.BOOT_COMPLETED</span> -n org<span class="selector-class">.mazhuang</span>.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure>
<p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。<br>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：<br>（均可使用adb触发）</p>
<table>
<thead>
<tr>
<th>action</th>
<th align="left">触发时机</th>
</tr>
</thead>
<tbody><tr>
<td>android.net.conn.CONNECTIVITY_CHANGE</td>
<td align="left">网络连接发生变化</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_ON</td>
<td align="left">屏幕点亮</td>
</tr>
<tr>
<td>android.intent.action.SCREEN_OFF</td>
<td align="left">屏幕熄灭</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_LOW</td>
<td align="left">电量低，会弹出电量低提示框</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_OKAY</td>
<td align="left">电量恢复了</td>
</tr>
<tr>
<td>android.intent.action.BOOT_COMPLETED</td>
<td align="left">设备启动完毕</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_LOW</td>
<td align="left">存储空间过低</td>
</tr>
<tr>
<td>android.intent.action.DEVICE_STORAGE_OK</td>
<td align="left">存储空间恢复</td>
</tr>
<tr>
<td>android.intent.action.PACKAGE_ADDED</td>
<td align="left">安装了新的应用</td>
</tr>
<tr>
<td>android.net.wifi.STATE_CHANGE</td>
<td align="left">WiFi 连接状态发生变化</td>
</tr>
<tr>
<td>android.net.wifi.WIFI_STATE_CHANGED</td>
<td align="left">WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td>
</tr>
<tr>
<td>android.intent.action.BATTERY_CHANGED</td>
<td align="left">电池电量发生变化</td>
</tr>
<tr>
<td>android.intent.action.INPUT_METHOD_CHANGED</td>
<td align="left">系统输入法发生变化</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_CONNECTED</td>
<td align="left">外部电源连接</td>
</tr>
<tr>
<td>android.intent.action.ACTION_POWER_DISCONNECTED</td>
<td align="left">外部电源断开连接</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STARTED</td>
<td align="left">系统开始休眠</td>
</tr>
<tr>
<td>android.intent.action.DREAMING_STOPPED</td>
<td align="left">系统停止休眠</td>
</tr>
<tr>
<td>android.intent.action.HEADSET_PLUG</td>
<td align="left">插入耳机</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_UNMOUNTED</td>
<td align="left">卸载外部介质</td>
</tr>
<tr>
<td>android.intent.action.MEDIA_MOUNTED</td>
<td align="left">挂载外部介质</td>
</tr>
<tr>
<td>android.os.action.POWER_SAVE_MODE_CHANGED</td>
<td align="left">省电模式开启</td>
</tr>
</tbody></table>
<h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> force-<span class="keyword">stop</span> <span class="symbol">&lt;packagename&gt;</span></span><br></pre></td></tr></table></figure>
<p>命令示例：<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f509618cec978dc1.png" alt="image.png"></p>
<h3 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span>  <span class="keyword">am</span> send-trim-memory <span class="symbol">&lt;pid&gt;</span> <span class="symbol">&lt;level&gt;</span></span><br></pre></td></tr></table></figure>
<p>pid: 进程 ID level: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE<br>命令示例：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> am send-<span class="keyword">trim</span>-<span class="keyword">memory</span> 12345 RUNNING_LOW</span><br></pre></td></tr></table></figure>
<p>表示向 pid&#x3D;12345 的进程，发出 level&#x3D;RUNNING_LOW 的收紧内存命令。 </p>
<h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。<br>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p>
<h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm size <span class="number">480</span>x1024</span><br></pre></td></tr></table></figure>
<p>表示将分辨率修改为 480px * 1024px。<br>恢复：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure>
<h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm density <span class="number">160</span></span><br></pre></td></tr></table></figure>
<p>表示将屏幕密度修改为 160dpi。<br>恢复：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> wm density reset</span></span><br></pre></td></tr></table></figure>
<h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm overscan <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span></span><br></pre></td></tr></table></figure>
<p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。<br>恢复：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> wm overscan reset</span></span><br></pre></td></tr></table></figure>
<h3 id="关闭USB调试"><a href="#关闭USB调试" class="headerlink" title="关闭USB调试"></a>关闭USB调试</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> adb_enabled <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>恢复：<br>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。<br>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p>
<h3 id="允许-x2F-禁止访问非-SDK-API："><a href="#允许-x2F-禁止访问非-SDK-API：" class="headerlink" title="允许&#x2F;禁止访问非 SDK API："></a>允许&#x2F;禁止访问非 SDK API：</h3><p>不需要设备获得Root权限。<br>允许访问非 SDK API：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> hidden_api_policy_pre_p_apps <span class="number">1</span></span><br><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> hidden_api_policy_p_apps <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>禁止访问非 SDK API</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">delete</span> <span class="built_in">global</span> hidden_api_policy_pre_p_apps</span><br><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">delete</span> <span class="built_in">global</span> hidden_api_policy_p_apps</span><br></pre></td></tr></table></figure>
<p>命令最后的数字的含义：</p>
<table>
<thead>
<tr>
<th>值</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="left">禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td>
</tr>
<tr>
<td>1</td>
<td align="left">仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td>
</tr>
<tr>
<td>2</td>
<td align="left">禁止调用深灰名单和黑名单中的接口。</td>
</tr>
<tr>
<td>3</td>
<td align="left">禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td>
</tr>
</tbody></table>
<h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p><strong>注：</strong>未指定路径则，默认为adb所在的文件夹<br>截图保存到电脑：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">exec</span><span class="operator">-</span><span class="keyword">out</span> screencap <span class="operator">-</span>p <span class="operator">&gt;</span> sc.png</span><br></pre></td></tr></table></figure>
<p>如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：<br>先截图保存到设备里：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p <span class="regexp">/sdcard/</span>sc.png</span><br></pre></td></tr></table></figure>
<p>然后将 png 文件导出到电脑：<br>adb pull &#x2F;sdcard&#x2F;sc.png<br>可以使用<code>adb shell screencap -h</code> 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>-p</td>
<td align="left">指定保存文件为 png 格式（如果指定文件后缀png，则可省略）</td>
</tr>
<tr>
<td>-d display-id</td>
<td align="left">指定截图的显示屏编号（有多显示屏的情况下）</td>
</tr>
</tbody></table>
<h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以mp4格式保存到 &#x2F;sdcard：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord <span class="regexp">/sdcard/</span>filename.mp4</span><br></pre></td></tr></table></figure>
<p>需要停止时按 <code>Ctrl-C</code>，默认录制时间和最长录制时间都是 180 秒。<br>如果需要导出到电脑：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb pull <span class="regexp">/sdcard/</span>filename.mp4</span><br></pre></td></tr></table></figure>
<p>可以使用 <code>adb shell screenrecord --help</code> 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>–size WIDTHxHEIGHT</td>
<td align="left">视频的尺寸，比如 1280x720，默认是屏幕分辨率。</td>
</tr>
<tr>
<td>–bit-rate RATE</td>
<td align="left">视频的比特率，默认是 4Mbps。</td>
</tr>
<tr>
<td>–time-limit TIME</td>
<td align="left">录制时长，单位秒。</td>
</tr>
<tr>
<td>–verbose</td>
<td align="left">输出更多信息。</td>
</tr>
</tbody></table>
<h3 id="开启-x2F-关闭wifi"><a href="#开启-x2F-关闭wifi" class="headerlink" title="开启&#x2F;关闭wifi"></a>开启&#x2F;关闭wifi</h3><p>开启</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> svc wifi <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure>
<p>关闭</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> svc wifi <span class="built_in">disable</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用Monkey进行压力测试"><a href="#使用Monkey进行压力测试" class="headerlink" title="使用Monkey进行压力测试"></a>使用Monkey进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。<br>简单用法：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> monkey -<span class="keyword">p</span> <span class="symbol">&lt;packagename&gt;</span> -v <span class="number">500</span></span><br></pre></td></tr></table></figure>
<p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。<br>更多内容可见<a href="https://developer.android.google.cn/studio/test/monkey.html">monkey官网</a></p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>Android性能优化：APK瘦身</title>
    <url>/2022/09/15/apk%E7%98%A6%E8%BA%AB/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>随着业务迭代，APK体积逐渐变大。项目中积累的无用资源，未压缩的图片资源等，都为apk带来了不必要的体积增加，而APK的大小会影响应用加载速度、使用的内存量以及消耗的电量。</p>
</blockquote>
<h2 id="了解APK结构"><a href="#了解APK结构" class="headerlink" title="了解APK结构"></a>了解APK结构</h2><p>在讨论如何缩减应用的大小之前，有必要了解下应用APK的结构。APK文件由一个Zip压缩文件组成，其中包含构成应用的所有文件，这些文件包括Java类文件、资源文件和包含已编译资源的文件。</p>
<p>APK包含以下目录：</p>
<ul>
<li><p><code>META-INF/</code>：包含<code>CERT.SF</code>和<code>CERT.RSA</code>签名文件，以及<code>MANIFEST.MF</code>清单文件。</p>
</li>
<li><p><code>assets/</code>：包含应用的资源；应用可以使用AssetManager对象检索这些资源。</p>
</li>
<li><p><code>res/</code>：包含未编译到<code>resources.arsc</code>中的资源（图片、音视频等）。</p>
</li>
<li><p><code>lib/</code>：包含特定于处理器软件层的已编译代码。此目录包含每种平台类型的子目录，如<code>armeabi、armeabi-v7a、arm64-v8a、x86、x86_64</code>和<code>mips</code>。</p>
</li>
</ul>
<p>APK还包含以下文件。在这些文件中，只有AndroidMainfest.xml是必须的。</p>
<ul>
<li><p><code>resources.arsc</code>：包含已编译的资源。此文件包含<code>res/values/</code> 文件夹的所有配置中的XML内容、打包工具会提取此XML内容，将其编译为二进制文件格式，并压缩内容、此内容包括语言字符串和格式，以及为直接包括在<code>resources.arsc</code>文件中的内容（例如布局文件和图片）的路径。</p>
</li>
<li><p><code>classes.dex</code>：包含以Dalvik&#x2F;ART虚拟机可理解的DEX文件格式编译的类。</p>
</li>
<li><p><code>AndroidManifest.xml</code>：包括核心Android清单文件、此文件列出了应用的名称、版本、访问权限和引用的库文件。该文件使用Android的二进制XML格式。</p>
</li>
</ul>
<h2 id="Android-Size-Analyzer（已弃用）"><a href="#Android-Size-Analyzer（已弃用）" class="headerlink" title="Android Size Analyzer（已弃用）"></a>Android Size Analyzer（已弃用）</h2><p>虽然已弃用，不过其提供的缩减策略还是很值得学习的,其实也就是后续介绍的一些方法。</p>
<p>Android Size Analyzer 工具可轻松地发现和实施多种缩减应用发小的策略。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172318943.png" alt="image-20220915172318943"></p>
<p>首先在 Android Studio中的插件市场下载安装Android Size Analyzer插件。安装插件后，从菜单栏中依次选择Analyze &gt; Analyze App Size，对当前项目运行应用大小分析。分析了项目后，系统会显示一个工具窗口，其中包含有关如何缩减应用大小的建议。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172348018.png" alt="image-20220915172348018"></p>
<p>如image转webp的建议</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172447629.png" alt="image-20220915172447629"></p>
<p>也可以用以下方式转webp</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172459940.png" alt="image-20220915172459940"></p>
<h2 id="移除未使用资源"><a href="#移除未使用资源" class="headerlink" title="移除未使用资源"></a>移除未使用资源</h2><p>APK瘦身关键就在一个字：删！没用的就删了。</p>
<h3 id="启用资源缩减"><a href="#启用资源缩减" class="headerlink" title="启用资源缩减"></a>启用资源缩减</h3><p>如果在应用的build.gradle文件中启用了资源缩减：shrinkResources，则Gradle在打包APK时可以自动忽略未使用资源。资源缩减只有在与代码缩减：minifyEnabled配合使用时才能发挥作用。在代码缩减器移除所有不使用的代码后，资源缩减器便可确定应用仍要使用的资源，从而在打包时优化这些资源。</p>
<p>优化后，并没有将不用的资源文件删除掉，而是将文件内容给优化掉。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172611565.png" alt="image-20220915172611565"></p>
<p><strong>注意</strong>：开启优化，混淆也在其中，也就是说混淆也会被开启，那么就需要注意一些不能被混淆的资源，比如一些三方库的包</p>
<p><strong>添加keep：</strong></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172644031.png" alt="image-20220915172644031"></p>
<p>也可以使用@Keep修饰不混淆的类——哪里不对@Keep哪里</p>
<h4 id="混淆规则"><a href="#混淆规则" class="headerlink" title="混淆规则"></a>混淆规则</h4><ul>
<li><p>jni方法不可混淆，因为需要与native方法保持一致；</p>
</li>
<li><p>反射用到的类不能混淆（否则反射可能出现问题）；</p>
</li>
<li><p>AndroidMainfest中的类不混淆，四大组件和Application的子类和FrameWork层下所有的类默认不会进行混淆；</p>
</li>
<li><p>Parceable的子类和Creator静态成员变量不混淆，否则产生Android.os.BadParceableException异常；</p>
</li>
<li><p>使用GSON、fastjson等框架时，所写的JSON对象类不混淆，否则无法将JSON解析成对应的对象；</p>
</li>
<li><p>使用第三方开源库或者引用其他第三方的SDK包时，需要在混淆文件中加入对应的混淆规则；</p>
</li>
<li><p>有用到WebView的JS调用也需要保证写的接口方法不混淆；</p>
</li>
<li><p>使用enum类型时需要注意避免以下两个方法混淆，因为enum类的特殊性，以下两个方法会被反射调用</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172907262.png" alt="image-20220915172907262"></p>
</li>
</ul>
<h4 id="关于混淆的语法"><a href="#关于混淆的语法" class="headerlink" title="关于混淆的语法"></a>关于混淆的语法</h4><p><strong>Proguard关键字：</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>keep</td>
<td>保留类和类中的成员，防止被混淆或移除</td>
</tr>
<tr>
<td>keepnames</td>
<td>保留类和类中的成员，防止被混淆，成员没有被引用会被移除</td>
</tr>
<tr>
<td>keepclassmembers</td>
<td>只保留类中的成员，防止被混淆或移除</td>
</tr>
<tr>
<td>keepclassmembernames</td>
<td>只保留类中的成员，防止被混淆，成员没有被引用会被移除</td>
</tr>
<tr>
<td>keepclasseswithmembers</td>
<td>保留类和类中的成员，防止被混淆或移除，保留指名的成员</td>
</tr>
<tr>
<td>keepclasseswithmembernames</td>
<td>保留类和类中的成员，防止被混淆，保留指名的成员，成员没有引用会被移除</td>
</tr>
</tbody></table>
<p><strong>Proguard通配符</strong></p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><field></td>
<td>匹配类中的所有字段</td>
</tr>
<tr>
<td><method></td>
<td>匹配类中的所有方法</td>
</tr>
<tr>
<td><init></td>
<td>匹配类中的所有构造函数</td>
</tr>
<tr>
<td>*</td>
<td>匹配任意长度字符，不包含包名分隔符”.”</td>
</tr>
<tr>
<td>**</td>
<td>匹配任意长度字符，包含包名分隔符”.”</td>
</tr>
<tr>
<td>***</td>
<td>匹配任意参数类型</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>如果既想保持类名，又想保持里面的内容不被混淆，使用：</strong></p>
<p>-keep class com.XX.test.* {*;}</p>
<p><strong>在此基础上，我们也可以使用Java的基本规则来保护特定类不被混淆，比如我们可以用extends，implements等这些Java规则。如下例子就避免所有继承Activity的类被混淆</strong></p>
<p>-keep public class * extends android.app.Activity</p>
<p> <strong>如果我们要保留一个类中的内部类不被混淆则需要用$符号，如下例子表示保持XxFragment内部类JavaScriptInterface中的所有public内容不被混淆。</strong></p>
<p>-keepclassmembers class com.XX.ui.fragment.XxFragment$JavaScriptInterface {</p>
<p>  public *;</p>
<p>}</p>
<p><strong>如果一个类中你不希望保持全部内容不被混淆，而只是希望保护类下的特定内容，可以使用</strong></p>
<p><init>;   &#x2F;&#x2F;匹配所有构造器</p>
<p><fields>;  &#x2F;&#x2F;匹配所有域</p>
<p><methods>;  &#x2F;&#x2F;匹配所有方法方法</p>
<p><strong>还可以在<fields>或<methods>前面加上private 、public、</strong><a href="https://so.csdn.net/so/search?q=native&spm=1001.2101.3001.7020"><strong>native</strong></a><strong>等来进一步指定不被混淆的内容，比如下面代码，表示名为Demo的类下的所有Public方法都不会被混淆</strong></p>
<p>-keep class com.XX.test.Demo {</p>
<p>  public <methods>;</p>
<p>}</p>
<p><strong>比如下面代码表示用JSONObject作为入参的构造函数不会被混淆</strong></p>
<p>-keep class com.XX.test.Demo {</p>
<p>  public <init>(org.json.JSONObject);</p>
<p>}</p>
<p><strong>5分钟快速完成混淆配置：</strong></p>
<p><a href="https://blog.csdn.net/qq_34317125/article/details/81127744"><strong>https://blog.csdn.net/qq_34317125&#x2F;article&#x2F;details&#x2F;81127744</strong></a></p>
</blockquote>
<h3 id="使用Lint分析器（物理删除）"><a href="#使用Lint分析器（物理删除）" class="headerlink" title="使用Lint分析器（物理删除）"></a>使用Lint分析器（物理删除）</h3><p>lint工具是Android Studio中附带的静态代码分析器，可检测到res&#x2F;文件夹中未被代码引用的资源。</p>
<p>从菜单栏中依次选择Analyze &gt; Run Inspection By Name</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173612451.png" alt="image-20220915173612451"></p>
<p>分析完成后会出现以下弹窗</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173625037.png" alt="image-20220915173625037"></p>
<p><strong>注意</strong>：lint工具不会扫描assets&#x2F;文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。与资源缩减不同，这里点击删除，那就是把文件删了。所以，使用lint时谨慎删除文件，最好不要使用Remove All Unused Resources。</p>
<blockquote>
<p>反射引用资源：getResources().getIdentifier(“layout_main”,”layout”,getPackageName());</p>
</blockquote>
<h3 id="自定义要保留的资源"><a href="#自定义要保留的资源" class="headerlink" title="自定义要保留的资源"></a>自定义要保留的资源</h3><p>如果有想要特别声明需要保留或舍弃的特定资源，在项目中创建一个包含<resources>标记的XML文件，并在tools:keep属性中指定每个要保留的资源，在tools:discard属性中指定每个要舍弃的资源。这两个属性都接受以逗号分隔的资源名称列表。还可以将星号字符用作通配符。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173716035.png" alt="image-20220915173716035"></p>
<p>将该文件保存在项目资源中，例如，保存在res&#x2F;raw&#x2F;keep.xml中。构建系统不会将此文件打包到APK中。</p>
<h3 id="一键删除无用资源"><a href="#一键删除无用资源" class="headerlink" title="一键删除无用资源"></a>一键删除无用资源</h3><p>Android Studio给我们提供了一键移除所有无用的资源。从菜单栏中依次选择Refactor &gt; Remove UnusedResources，但是这种方式不建议使用，因为如果某资源仅存在动态获取资源id的方式，那么这个资源会被认为没有使用过，从而会直接被删除。</p>
<h3 id="移除未使用的备用资源"><a href="#移除未使用的备用资源" class="headerlink" title="移除未使用的备用资源"></a>移除未使用的备用资源</h3><p>Gradle资源缩减器只会移除未由应用代码引用的资源，这意味着，它不会移除用于不同设备配置的备用资源。可以使用Android Gradle插件的resConfigs属性移除应用不需要的备用资源文件。</p>
<p>例如，如果使用的是包含语言资源的库（如AppCompat），那么APK中将包含这些库中所有已翻译语言的字符串。如果只想保留应用正式支持的语言，则可以使用resConfig属性指定这些语言。系统会移除未指定语言的所有资源。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173818290.png" alt="image-20220915173818290"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173833863.png" alt="image-20220915173833863"></p>
<p>配置resConfigs只打包默认与简体中文资源。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps1.jpg" alt="img"></p>
<h2 id="动态打包配置"><a href="#动态打包配置" class="headerlink" title="动态打包配置"></a>动态打包配置</h2><p>so文件是由ndk编译出来的动态库，是c&#x2F;c++写的，所以不是跨平台的。ABI是应用程序二进制接口简称（Application Binary Interface），定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统中，每一个CPU架构对应一个ABI，目前支持的有：armeabi-v7a，arm64- v8a，x86，x86_64。目前市面上手机设备基本上都是arm架构，armeabi-v7a几乎能兼容所有设备。因此可以配置：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps2.jpg" alt="img"></p>
<p>对于第三方服务，如百度地图、Bugly等会提供全平台的cpu架构。进行了上面的配置之后，表示只会把armeabiv7a打包进入Apk。从而减少APK大小。</p>
<p>对于arm64架构的设备，如果使用armeabi-v7a也能够兼容，但是不如使用arm64的so性能。因此现在部分应用市场会根据设备提供不同架构的Apk安装。此时我们需要打包出针对arm64的apk与armv7a的apk，可以使用productFlavor。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps3.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915174015302.png" alt="image-20220915174015302"> </p>
<p>也可以使用：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps5.jpg" alt="img"> </p>
<h2 id="使用矢量图与webp"><a href="#使用矢量图与webp" class="headerlink" title="使用矢量图与webp"></a>使用矢量图与webp</h2><p>Apk中图片应该算是占用空间最多的资源。我们可以使用webp减少png、jpg图片占用空间的大小。对于小图标也可以使用矢量图。</p>
<p><img src="C:\Users\15786\AppData\Local\Temp\ksohtml20268\wps6.jpg" alt="img"> </p>
<p>矢量图可以创建与分辨率无关的图标和其他可伸缩媒体。使用这些图形可以极大地减少APK占用的空间。矢量图片在Android中以VectorDrawable对象的形式表示。借助VectorDrawable对象，100字节的文件可以生成与屏幕大小相同的清晰图片</p>
<p>不过，系统渲染每个VectorDrawable对象需要花费大量时间，而较大的图片则需要更长的时间才能显示在屏幕上。因此，建议仅在显示小图片时使用这些矢量图。</p>
<blockquote>
<p>新工程默认Icon就是矢量图</p>
</blockquote>
<h3 id="重复使用资源"><a href="#重复使用资源" class="headerlink" title="重复使用资源"></a>重复使用资源</h3><p>现在我们有一个矢量图：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps7.jpg" alt="img"> </p>
<p>它的显示效果：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps8.jpg" alt="img"> </p>
<p>如果我们需要让矢量图显示红色怎么办？这种情况，我们不需要再去创建一个新的矢量图。可以直接给ImageView设置android:tint属性来完成颜色的修改。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps9.jpg" alt="img"> </p>
<p>如果需要让矢量图实现触摸变色。只需要创建selector，设置给tint即可</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps10.jpg" alt="img"> </p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps10.jpg" alt="img"> </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>主动移除无用代码（开启R8&#x2F;Progurad自动移除）</p>
</li>
<li><p>避免使用枚举，使用@IntDef代替</p>
</li>
<li><p>开启资源混淆：<a href="https://gitee.com/ahr6e170zl/AndResGuard?_from=gitee_search%E6%88%96https://github.com/shwenzhang/AndResGuard">https://gitee.com/ahr6e170zl/AndResGuard?_from=gitee_search或https://github.com/shwenzhang/AndResGuard</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>adb shell input text不能输入中文的解决方案</title>
    <url>/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>adb默认是不支持Unicode编码的，无法通过adb shell input text 命令输入中文到手机或者模拟器。</p>
<h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ul>
<li>1、安装ADBKeyBoard.apk文件(直接搜索就能找到)<br>打开手机或模拟器，adb install ADBKeyBoard.apk安装该输入法<br>在手机上直接安装也可</li>
<li>2、设置默认输入法<br>打开手机设置 -&gt; 点击语法与输入法 -&gt; 点击输入法管理 -&gt; 启用ADBKeyboard<br>重启手机后即可使用该输入法</li>
<li>3、输入adb命令测试中文输入<br>adb shell am broadcast -a ADB_INPUT_TEXT –es msg ‘这是一段adb中文测试’</li>
</ul>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>adb获取应用包入口的方案</title>
    <url>/2022/07/24/adb%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E5%8C%85%E5%85%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>小编最近在入手adb调试，刚开始还是挺顺利的，不过后面就遇到了一些小插曲，其中一个就是获取应用包的入口，开启一个应用。<br>这个问题在网上可以找到很多解决方案，但不都是有用，并且有些方法有一点麻烦。<br>这里，小编介绍一下意外摸索到的解决方案。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、点开需要打开的应用，使用获取前台Activity命令</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities <span class="string">| findstr mResumedActivity</span></span><br></pre></td></tr></table></figure>
<p>这样便能获得应用包的启动入口<br>比如，获取有道词典的启动入口<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-2420606065b22c18.png" alt="image.png"></p>
<p>2、使用adb启动应用包</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">adb shell am start -n <span class="selector-attr">[应用包名]</span> /<span class="selector-attr">[入口]</span></span><br></pre></td></tr></table></figure>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-444cb9956734d120.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title>京东淘宝首页二级联动</title>
    <url>/2022/07/18/%E4%BA%AC%E4%B8%9C%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/</url>
    <content><![CDATA[<p><strong>说明：</strong>这篇文章主要用于作者临时观看，因为涉及版权问题，所以短时间内会删除</p>
<h2 id="京东淘宝首页二级联动"><a href="#京东淘宝首页二级联动" class="headerlink" title="京东淘宝首页二级联动"></a>京东淘宝首页二级联动</h2><h3 id="单点触摸与多点触摸"><a href="#单点触摸与多点触摸" class="headerlink" title="单点触摸与多点触摸"></a>单点触摸与多点触摸</h3><p>####单点触摸</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212127652.png" alt="image-20220718212127652"></p>
<p>####多点触摸</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212142549.png" alt="image-20220718212142549"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212203113.png" alt="image-20220718212203113"></p>
<blockquote>
<p>面试题</p>
<p>一个move事件 中间有多少个手指的信息-&gt;有多少个手指就有多少个手指信息-&gt;最多32个</p>
</blockquote>
<h3 id="Touch事件源码"><a href="#Touch事件源码" class="headerlink" title="Touch事件源码"></a>Touch事件源码</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212217242.png" alt="image-20220718212217242"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212232559.png" alt="image-20220718212232559"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212254074.png" alt="image-20220718212254074"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212316235.png" alt="image-20220718212316235"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212335895.png" alt="image-20220718212335895"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212349700.png" alt="image-20220718212349700"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212414454.png" alt="image-20220718212414454"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212432841.png" alt="image-20220718212432841"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212452115.png" alt="image-20220718212452115"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212515213.png" alt="image-20220718212515213"></p>
<p>上述的disallowIntercept及相关内容就是所谓的“尚方宝剑”</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212536424.png" alt="image-20220718212536424"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212555410.png" alt="image-20220718212555410"></p>
<p> <img src="C:\Users\15786\AppData\Roaming\Typora\typora-user-images\image-20220718212609465.png" alt="image-20220718212609465"></p>
<h3 id="嵌套滑动"><a href="#嵌套滑动" class="headerlink" title="嵌套滑动"></a>嵌套滑动</h3><blockquote>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212649556.png" alt="image-20220718212649556"></p>
</blockquote>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212704210.png" alt="image-20220718212704210"></p>
<p>并且从上面可以看出NestedScrollView既可以做“父亲”，也可以做“孩子”</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212718655.png" alt="image-20220718212718655"></p>
<p>“孩子”有三个版本</p>
<p>三个版本之间是的关系  同样“父亲”也是一样</p>
<blockquote>
<p>版本2与版本1相比  增加了type 如惯性滑动效果</p>
</blockquote>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212737829.png" alt="image-20220718212737829"></p>
<h4 id="吸顶效果"><a href="#吸顶效果" class="headerlink" title="吸顶效果"></a>吸顶效果</h4><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212758009.png" alt="image-20220718212758009"></p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212818443.png" alt="image-20220718212818443"></p>
<p>onFinishInflate()中获取第一个孩子的第二个孩子，从下图可以看出也就是是第二个LinearLayout</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212839006.png" alt="image-20220718212839006"></p>
<h4 id="继续嵌套滑动"><a href="#继续嵌套滑动" class="headerlink" title="继续嵌套滑动"></a>继续嵌套滑动</h4><p>嵌套滑动-&gt;是由孩子主动的   触发的</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212906775.png" alt="image-20220718212906775"></p>
<p>google为了方便我们处理嵌套滑动，所以提供了这个帮助类 -&gt; getScrollingChildHelper()</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212928635.png" alt="image-20220718212928635"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212942972.png" alt="image-20220718212942972"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213001121.png" alt="image-20220718213001121"></p>
<p>while(p!&#x3D;null)一直找，直到找到支持嵌套滑动</p>
<p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213017801.png" alt="image-20220718213017801"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213043191.png" alt="image-20220718213043191"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213058717.png" alt="image-20220718213058717"></p>
<p>所以它没有滑，“父亲”划不动的时候，它(NestedScrollView)才动</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213122243.png" alt="image-20220718213122243"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213138627.png" alt="image-20220718213138627"></p>
<p>问题描述：需求是整个页面滑动，当父View滑不动的时候，子View才动。问题出现的原因就是上面的文字描述，要想解决</p>
<p>问题的解决：重写onNestedPreScroll()方法，做一些设置，如果自己还能滑，那么就自己滑，并且需要记录一下（consumed[1]，0记录的x，1记录的y）</p>
<ul>
<li><p>注意：NetestScrollLayout是自定义继承NetestScrollView的</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213208543.png" alt="image-20220718213208543"></p>
</li>
</ul>
<h3 id="惯性滑动"><a href="#惯性滑动" class="headerlink" title="惯性滑动"></a>惯性滑动</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213227462.png" alt="image-20220718213227462"></p>
<p>记录下速度 velocityY</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213246067.png" alt="image-20220718213246067"></p>
<blockquote>
<ul>
<li>1、记下来速度 velocity</li>
<li>2、转化成 距离</li>
<li>3、自己滑了多少距离 根据速度转换后的距离 -&gt; 我自己的滑动距离 &#x3D; 孩子应该滑的距离</li>
<li>4、孩子应该滑的距离又要转化成速度</li>
</ul>
</blockquote>
<ul>
<li>google提供的速度转距离的工具</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213300370.png" alt="image-20220718213300370"></p>
<p>孩子 -&gt;如recyclerView又会将距离转换成速度(因为RecyclerView只支持fling，所以需要转化成速度再转成距离)</p>
<p>下面两个方法分别对应上述步骤中的第3步和第4步</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213317734.png" alt="image-20220718213317734"></p>
<p><strong>关于totalDy</strong></p>
<p>下面注解一处错误：第一个，其实是Viewpager2，不是RecyclerView，通过前面有一张布局截图可以看出最后下面那个是ViewPager2</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213340340.png" alt="image-20220718213340340"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213358954.png" alt="image-20220718213358954"></p>
<h3 id="关于内部拦截"><a href="#关于内部拦截" class="headerlink" title="关于内部拦截"></a>关于内部拦截</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213415057.png" alt="image-20220718213415057"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213428785.png" alt="image-20220718213428785"></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>开发技巧（一）</title>
    <url>/2022/12/04/%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>本章，小编来介绍一些省时省力的开发技巧，都是从前辈那学来的。平时做些小demo还感觉不到这些技巧的实用性，当遇到大项目时就感觉真香。</p>
</blockquote>
<h3 id="全局获取Context的技巧"><a href="#全局获取Context的技巧" class="headerlink" title="全局获取Context的技巧"></a>全局获取Context的技巧</h3><blockquote>
<p>我们在Android开发中难免会用到context，到底传哪个context呢？在Activity这样的类中可以传this（Activity自己就是个context），在自己创建的类中通过外部传入context，那这个context是谁？是Activity？最好不要这样，除非是涉及到跳转（这种情况只能用Activity），为什么呢？先看代码技巧，我再娓娓道来。</p>
</blockquote>
<p>Android提供了一个Application类，每当程序启动的时候，系统就会自动将这个类进行初始化。而我们可以定制一个自己的Application类，以便于管理程序内一些全局的状态信息，比如全局Context。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinApplication</span>: <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="string">&quot;StaticFieldLeak&quot;</span>)</span></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> context:Context</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        context = applicationContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，将context设置成静态变量很容易导致内存泄漏，所以这是一种有风险的做法，因此Android Studio会给出警告。</p>
<p>但是！由于这里获取的不是Activity或Service中的context，而是Application中的context，它在全局只会存在一份实例，并且在整个应用程序的声明周期内都不会回收，因此是不存在内存泄漏风险的。所以我上面加了个注解<code>@SuppressLint(&quot;StaticFieldLeak&quot;)</code>让Android Studio忽略上述的警告提示。前面提到最好不要使用Activity的context，现在知道为什么了吧！</p>
<p>当然，别忘了在<code>AndroidManifest.xml</code>中注册创建的Application。</p>
<h3 id="定制日志工具"><a href="#定制日志工具" class="headerlink" title="定制日志工具"></a>定制日志工具</h3><blockquote>
<p>Android Studio自带的日志工具非常好用，但也存在一些缺点。</p>
<p>我们在做大型项目时肯定会用到不少打印信息，但是当我们完成项目后，之前用于调试的那些日志，在项目上线后仍然会照常打印，这样不仅会降低程序的运行效率，还有可能将一些机密的数据泄漏出去。怎么办？</p>
</blockquote>
<p>我们就需要定制日志工具，使我们能够自由控制日志的打印。其实很简单，如下：</p>
<p>创建一个LogUtil单例类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> PC</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@QQ</span> 1578684787</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">object</span> LogUtil &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> VERBOSE = <span class="number">1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> DEBUG = <span class="number">2</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> INFO = <span class="number">3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> WARN = <span class="number">4</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ERROR = <span class="number">5</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> level = VERBOSE</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">v</span><span class="params">(tag:<span class="type">String</span>,msg:<span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= VERBOSE)&#123;</span><br><span class="line">            Log.v(tag,msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">d</span><span class="params">(tag: <span class="type">String</span>,msg: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= DEBUG)&#123;</span><br><span class="line">            Log.d(tag, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">i</span><span class="params">(tag: <span class="type">String</span>,msg: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= DEBUG)&#123;</span><br><span class="line">            Log.i(tag, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">w</span><span class="params">(tag: <span class="type">String</span>,msg: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= DEBUG)&#123;</span><br><span class="line">            Log.w(tag, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">e</span><span class="params">(tag: <span class="type">String</span>,msg: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level &lt;= DEBUG)&#123;</span><br><span class="line">            Log.e(tag, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要通过修改level变量的值，就可以自由地控制日志的打印行为。比如让level等于VERBOSE就可以把所有的日志都打印出来，让level等于ERROR就可以只打印程序的错误日志。</p>
<p>使用这种方法之后，刚才所说的那个问题就不复存在了，你只需要在开发阶段将level指定成VERBOSE，当项目正式上线的时候将level指定成ERROE就可以了。</p>
<h3 id="使用Intent传递对象"><a href="#使用Intent传递对象" class="headerlink" title="使用Intent传递对象"></a>使用Intent传递对象</h3><blockquote>
<p>Intent 的用法相信大家都很熟悉，我们可以借助它来启动Activity、Service、发送广播等。在进行上述操作的时候，我们还可以在Intent中添加一些附加数据，以达到传值的效果，比如：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = <span class="constructor">Intent(<span class="params">this</span>,SecondActivity::<span class="params">class</span>.<span class="params">java</span>)</span>.apply &#123; </span><br><span class="line">            put<span class="constructor">Extra(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;hello&quot;</span>)</span></span><br><span class="line">            put<span class="constructor">Extra(<span class="string">&quot;second_data&quot;</span>,<span class="string">&quot;kotlin&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">        start<span class="constructor">Activity(<span class="params">intent</span>)</span></span><br></pre></td></tr></table></figure>

<p>SecondActivity中接收数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">intent.getStringExtra(<span class="string">&quot;data&quot;</span>)</span><br><span class="line">intent.getIntExtra(<span class="string">&quot;second_data&quot;</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>但是，不知道你发现没有，putExtra方法支持的数据类型是有限的，虽然常用的一些数据类型是受支持的，但是当你想去传递一些自定义对象的时候，就会发现无从下手。下面我们就来看看如何下手。</p>
<h4 id="Serializable方式"><a href="#Serializable方式" class="headerlink" title="Serializable方式"></a>Serializable方式</h4><blockquote>
<p>使用Intent来传递对象通常有两种实现方式：Serializable和Parcelable。</p>
<p>Serializable是序列化的意思，表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。至于序列化的方法，非常简单！只需要让一个类去实现Serializable这个接口就可以了。</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> :<span class="type">Serializable&#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">val</span> student = Student().apply &#123;</span><br><span class="line">            id = <span class="number">1</span></span><br><span class="line">            name = <span class="string">&quot;joker&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,SecondActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">            putExtra(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;kotlin&quot;</span>)</span><br><span class="line">            putExtra(<span class="string">&quot;second_data&quot;</span>,<span class="number">200</span>)</span><br><span class="line">            putExtra(<span class="string">&quot;student_1&quot;</span>,student)</span><br><span class="line">        &#125;</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>可以看到，这里我们创建了一个Student的实例，并将它直接传入了Intent的<code>putExtra()</code>方法中 。由于Student类实现了<code>Serializable</code>接口，所以才可以这样写。</p>
<p>SecondActivity中接收数据</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> student = intent.get<span class="constructor">SerializableExtra(<span class="string">&quot;student_1&quot;</span>)</span> <span class="keyword">as</span> Student</span><br></pre></td></tr></table></figure>

<p>这里调用了Intent的<code>getSerializableExtra()</code>方法来获取通过参数传递过来的序列化对象，接着再将它向下转型成Student对象，这样我们就成功实现了使用Intent传递对象的功能。</p>
<blockquote>
<p>需要注意的是，这种传递对象的工作原理是将一个对象序列化成可存储或可传输的状态，传递给另外一个Activity后再将其反序列化成<strong>一个新的对象</strong>。<strong>虽然这两个对象中存储的数据完全一致，但是它们实际上是不同的对象。</strong></p>
</blockquote>
<h4 id="Parcelable方式"><a href="#Parcelable方式" class="headerlink" title="Parcelable方式"></a>Parcelable方式</h4><blockquote>
<p>除了Serializable之外，使用Percelable也可以实现相同的效果，不过不同于将对象进行序列化，Parcelable方式的实现原理是<strong>将一个完成的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型</strong>，这样就能实现传递对象的功能了。</p>
<p>接下来我们来看一下Parcelable的实现方式：</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *<span class="doctag">@Author</span> PC</span></span><br><span class="line"><span class="comment"> *<span class="doctag">@QQ</span> 1578684787</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :<span class="type">Parcelable&#123;</span></span></span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">writeToParcel</span><span class="params">(parcel: <span class="type">Parcel</span>, flags: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        parcel.writeInt(id)<span class="comment">//写出name</span></span><br><span class="line">        parcel.writeString(name)<span class="comment">//写出age</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">describeContents</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> CREATOR : Parcelable.Creator&lt;Student&gt; &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">createFromParcel</span><span class="params">(parcel: <span class="type">Parcel</span>)</span></span>: Student &#123;</span><br><span class="line">            <span class="keyword">val</span> student = Student()</span><br><span class="line">            student.id = parcel.readInt()<span class="comment">//读取id</span></span><br><span class="line">            student.name = parcel.readString()?:<span class="string">&quot;&quot;</span><span class="comment">//读取name</span></span><br><span class="line">            <span class="keyword">return</span> student</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">newArray</span><span class="params">(size: <span class="type">Int</span>)</span></span>: Array&lt;Student?&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> arrayOfNulls(size)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Parcelable的实现方式要稍微复杂一些。可以看到，首先我们让Student类实现了Parcelable接口，这样就必须重写<code>describeContents()</code>和<code>writeToParcel()</code>方法。其中<code>describeContents()</code>方法直接返回0就可以了，而在<code>writeToParcel()</code>方法中，我们需要调用Parcel的<code>writeXxx()</code>方法，将Student类中的字段一一写出。注意，字符串型数据就调用writeString()方法，整型数据就调用<code>writeInt()</code>方法，以此类推。</p>
<p>除此之外，我们还必须在Student类中提供一个名为CREATOR的匿名类实现。这里创建了<code>Parcelable.Creator</code>接口的一个实现。并将泛型指定为Student。接着需要重写<code>createFromParcel()</code>和<code>newArray()</code>这两个方法，在<code>createFromParcel()</code>方法中，我们要创建一个Student对象进行返回，并读取刚才写出的id和name字段。其中id和name都是调用Parcel的<code>readXxx()</code>方法读取到的，注意这里读取的顺序一定要和刚才写出的顺序完全相同。而<code>newArray()</code>方法中的实现就简单多了，只需要调用<code>arrayOfNulls()</code>方法，并使用参数中传入的size作为数组大小，创建一个空的Student数组即可。</p>
<p>发送数据的方式相同，我们来看接收数据：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> student = intent.getParcelableExtra&lt;Student&gt;(<span class="string">&quot;student_1&quot;</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>有没有觉得上面这种方式太复杂了，这不像kotlin开发Android的风格。为此Kotlin给我们提供了另外一种更加简便的用法，但前提是传递的所有数据都必须封装在对象的主构造函数中才行。</p>
</blockquote>
<p>修改一下Student类的代码：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Parcelize</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>(<span class="keyword">var</span> id:<span class="built_in">Int</span>,<span class="keyword">var</span> name:String) : Parcelable </span><br></pre></td></tr></table></figure>

<p>就是这么简单！将id和name这两个字段移动到主构造函数中，然后给Student类添加一个<code>@Parcelize</code>注解即可，是不是比之前的用法简——单——多——了——。</p>
<p>这样我们就把使用Intent传递对象的两种实现方式都学习完了。对比一下，Serializable方式更简单，但由于会把整个对象进行序列化，因此效率会比Parcelable方式低一些（其中还涉及反射产生很多临时变量），所以在通常情况下，还是更加推荐使用Parcelable的方式来实现Intent传递对象的功能。</p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
      <tags>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>删除有序链表中重复的元素</title>
    <url>/2022/09/25/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>今天，小编来分享一道热门的面试算法题——删除有序链表中重复的元素。</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给出一个升序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。</p>
<p>例如：</p>
<p>给出的链表为1 -&gt; 2 -&gt; 3 -&gt;3 -&gt; 4 -&gt; 4 -&gt; 5，返回1-&gt; 2 -&gt; 5.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><p>输入：{1,2,3}</p>
<p>返回值：{1}</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>输入：{}</p>
<p>返回值：{}</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>给链表加上表头，因为可能会出现第一个节点就需要删除</li>
<li>遍历链表，每次比较相邻两个节点，如果遇到了两个相邻节点相同，则新开内循环将这一段所有的相同都遍历过去。</li>
<li>在第2步中这一连串相同的节点前的节点直接连上后续第一个不相同值的节点。</li>
<li>返回时去掉添加的表头。</li>
</ol>
<p><strong>注意：</strong></p>
<ul>
<li>这道题删除的是所有重复的元素，也就是说凡是有重复出现的任何数就全部删除，并不是删除至只留下一个。</li>
<li>外层循环的条件<code>cur.next != null &amp;&amp; cur.next.next != null</code></li>
<li>内层循环的条件<code>cur.next != null &amp;&amp; cur.next.val == temp</code>，其实内层循环条件很简单，但是一定要细心，小编第一次遇到这道题的时候就在这入了坑</li>
</ul>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span> <span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//空链表</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//在链表前加一个表头</span></span><br><span class="line">        res.next = head; </span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> res;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != <span class="literal">null</span> &amp;&amp; cur.next.next != <span class="literal">null</span>)&#123; </span><br><span class="line">            <span class="comment">//遇到相邻两个节点值相同</span></span><br><span class="line">            <span class="keyword">if</span>(cur.next.val == cur.next.next.val)&#123; </span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next.val;</span><br><span class="line">                <span class="comment">//将所有相同的都跳过</span></span><br><span class="line">                <span class="keyword">while</span> (cur.next != <span class="literal">null</span> &amp;&amp; cur.next.val == temp) </span><br><span class="line">                    cur.next = cur.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回时去掉表头</span></span><br><span class="line">        <span class="keyword">return</span> res.next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次上传测试</title>
    <url>/2022/07/09/%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>括号问题</title>
    <url>/2022/07/13/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p>
<p>例如，给出n&#x3D;3，解集为：</p>
<p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p>
<p>数据范围：0&lt;&#x3D;n&lt;&#x3D;10</p>
<p>要求：空间复杂度O(n)，时间复杂度O(2^n)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote>
<p>输入：1</p>
<p>返回值：[“()”]</p>
</blockquote>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><blockquote>
<p>输入：2</p>
<p>返回值：[“(())”，”()()”]</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相当于一共n个左括号和n个右括号，可以给我们使用，我们需要依次组装这些括号。每当我们使用一个左括号之后，就剩下n-1个左括号和n个右括号给我们使用，结果拼在使用的左括号之后就行了，因此后者就是一个子问题，可以使用递归：</p>
<ul>
<li>终止条件：左右括号都使用了n个，将结果加入数组。</li>
<li>返回值：每一级向上一级返回后续组装后的字符串，即子问题中搭配出来的括号序列。</li>
<li>本级任务：每一级就是保证左括号还有剩余的情况下，使用一次左括号进入子问题，或者右括号还有剩余且右括号使用次数少于左括号的情况下使用一次右括号进入子问题。</li>
<li><strong>注意：</strong>我们需要保证左括号出现的次数比右括号多时我们再使用右括号就一定能保证括号合法了，因此每次需要检查左括号和右括号的使用次数。</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @return string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span>(<span class="type">int</span> left,<span class="type">int</span> right,<span class="built_in">String</span> temp,<span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; res,<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="comment">//左右括号都用完了，就加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(left==n&amp;&amp;right==n)&#123;</span><br><span class="line">            res.<span class="property">add</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;n)&#123;</span><br><span class="line">            <span class="title function_">recursion</span>(left+<span class="number">1</span>,right,temp + <span class="string">&quot;（&quot;</span>,res,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次有括号</span></span><br><span class="line">        <span class="keyword">if</span>(right&lt;n&amp;&amp;right&lt;left)&#123;</span><br><span class="line">            <span class="title function_">recursion</span>(left,right+<span class="number">1</span>,temp + <span class="string">&quot;）&quot;</span>,res,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; <span class="title function_">generateParenthesis</span> (<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; res = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="title function_">recursion</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,res,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解并发编程和归纳总结</title>
    <url>/2022/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AbstractQueueSynchronizer（抽象队列同步器）</p>
<blockquote>
<p>是用来构建锁和其他同步组件的基础架构，比如ReentrantLock、ReetrantReadWriteLock和CountDownLatch就是基于<strong>AQS</strong>实现的。它使用一个<strong>int成员变量state</strong>标识同步状态，通过<strong>内置的FIFO（队列）</strong>来完成获取资源线程的排队工作。它是<strong>CLH队列锁</strong>的一种变体实现。它可以实现两种同步方式：<strong>独占式、共享式</strong>。<br>AQS的主要使用方式是<strong>继承</strong>，子类通过继承AQS并实现它的抽象方式来管理同步状态，同步器的设计基于<strong>模板方法模式</strong>，所以如果要实现我们自己的同步工具类就需要其中几个可重写的方法，如tryAcquire、tryRelease、tryReleaseShared等等。<br>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者和同步组件交互的接口（比如可以允许两个线程并访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者锁需关注的领域。<br>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node节点组成，每个Node节点维护一个pre引用和next引用，分别指向自己的前序和后继，构成一个双端双向链表。同时与Condition相关的等待队列，节点类型也是Node，构成了一个单向链表。</p>
</blockquote>
<h3 id="AQS两种资源共享方式"><a href="#AQS两种资源共享方式" class="headerlink" title="AQS两种资源共享方式"></a>AQS两种资源共享方式</h3><blockquote>
<p>1.Exclusive-&gt;独占，只有一个线程能执行，如ReentrantLock<br>2.Share-&gt;共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch</p>
</blockquote>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取和释放方式即可。<br>同步器实现时主要实现以下几种方法：</p>
<ul>
<li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true。</li>
<li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true。</li>
<li>tryAcquireShared(int)：共享方式。尝试获取资源；负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false。</li>
<li>isHeldExclusively：该线程是否正在独占资源。只有用到condition才需要去实现它。</li>
</ul>
<h3 id="AQS重要源码预览"><a href="#AQS重要源码预览" class="headerlink" title="AQS重要源码预览"></a>AQS重要源码预览</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-da79f4c3871c7ae2.png" alt="image.png"><br>重要的参数state<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-7190ae966401c75e.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-03623aff31014070.png"></p>
<h3 id="Lock源码"><a href="#Lock源码" class="headerlink" title="Lock源码"></a>Lock源码</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-3e3ff9955721d761.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-1be98e4491920a17.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-e9d62d55bb74cbb1.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f7e7517cfb30bedd.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-11784af71e5884ab.png" alt="image.png"><br>独占式的<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-640b8294babb722a.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-1b58a042fb32d5f4.png" alt="image.png"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-770b3ddbb30dadc6.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-18298cccb10b1a98.png" alt="image.png"></p>
<h3 id="AQS的基本思想CLH队列锁"><a href="#AQS的基本思想CLH队列锁" class="headerlink" title="AQS的基本思想CLH队列锁"></a>AQS的基本思想CLH队列锁</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f140f50743caa711.png" alt="image.png"><br>CLH队列锁<br>1.基于链表的自旋锁<br>2.想要获得锁，通过CAS操作将QNode挂在链表的尾部<br>3.每个QNode都在自旋检查（有自旋次数限制，超过后当前线程将进入阻塞状态）myPred是否释放锁<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-7e4d05b64b6da0fc.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-8bd85142d512b8e4.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-132f27aec922be32.png" alt="image.png"></p>
<h3 id="公平锁和非公平锁的介绍"><a href="#公平锁和非公平锁的介绍" class="headerlink" title="公平锁和非公平锁的介绍"></a>公平锁和非公平锁的介绍</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-e2c897782e4989c2.png" alt="image.png"><br><strong>唯一的区别</strong><br>公平锁中会判断队列中是都有线程在等待<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c3a61725c039fbaf.png" alt="image.png"></p>
<h3 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h3><p>我们再回头看看Lock的实现<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-951a38ede7375e8c.png" alt="image.png"><br>什么时候需要锁的可重入？</p>
<blockquote>
<p>当我们需要再次进入该方法时</p>
</blockquote>
<p>实现锁的可重入，否则会自己锁住自己<br>获取锁的时候state+1，释放锁的时候state-1<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-4275dadf72404056.png" alt="image.png"></p>
<h2 id="浅谈JMM"><a href="#浅谈JMM" class="headerlink" title="浅谈JMM"></a>浅谈JMM</h2><p>计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-b6a863238dfba07d.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-8540ad83e80cd995.png" alt="image.png"><br>线程不允许直接访问主内存，工作内存之间相互独立（类似于ThreadLocal），工作内存中存主内存变量的副本。<br>但是如此构建会带来数据同步方面的问题。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c039220a121a78ba.png" alt="image.png"></p>
<p>其实，JMM具可见性、原子性、有序性，那么这是怎么实现的呢？</p>
<ul>
<li>volatile关键字 使变量保持可见性</li>
<li>synchronized关键字 为操作加锁（只是用synchronized同样能保证安全）</li>
<li>一个线程写，多个线程读，使用volatile是OK的。</li>
</ul>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><ul>
<li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似count++这种复合操作不具有原子性。</li>
<li>volatile还能防止指令重排序 关于流水线和重排序 intel十级流水线 比如下例可以先算t&#x3D;b再执行if，提高性能。 但是在多线程中可能会引发多线程安全问题，所以volatile的抑制重排序就有了作用，<strong>如在DCL （双重检测锁定）中的作用？-&gt;防止指令重排序</strong><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-47b7059195083d75.png" alt="image.png"></li>
</ul>
<h4 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h4><p><strong>有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令</strong></p>
<ul>
<li>将当前处理器缓存行的数据写回系统内存</li>
<li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li>
</ul>
<h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><blockquote>
<p>相信大家都用过synchronized，特别是单例设计模式中很常见</p>
</blockquote>
<p>原理：使用monitorenter和monitorexit指令实现的</p>
<ul>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处</li>
<li>每个monitorenter必须有对应的monitorexit与之匹配</li>
<li>任何对象都有一个monitor与之关联<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-d1cb75d005ce1c3c.png" alt="image.png"></li>
</ul>
<h3 id="synchronized做了哪些优化"><a href="#synchronized做了哪些优化" class="headerlink" title="synchronized做了哪些优化"></a>synchronized做了哪些优化</h3><p><strong>锁消除：</strong>和逃逸分析比较紧密，如果在编译过程中发现某个代码块不会发生共享数据竞争，那么就会取消锁。<br><strong>锁粗化：</strong>如下图所示，未被加锁的代码块会被包裹进synchronized，减少线程上下文切换带来的开销。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-a7e0b1c2cdb2ed9a.png" alt="image.png"><br><strong>逃逸分析：</strong>发现加锁的对象只在某个方法内部，对变量做一些相关优化</p>
<p><strong>主要部分：</strong><br>我们来了解锁的四种状态</p>
<ul>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ul>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不存在多线程竞争，而且总是由同一线程多次获得，为了让锁的代价更低而引入了偏向锁。无锁竞争时不需要进行CAS操作来加锁和释放锁。<br>第一次还是需要CAS完成Mark Word的替换 替换如下信息<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-beb559b4194aa99a.png" alt="image.png"></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-fea657efece4ab97.png" alt="image.png"><br>如果发生锁的竞争，线程2会先stop the world，然后更改线程1的信息（由偏向锁升级为轻量级锁），这就导致性能降低。这就需要禁止偏向锁。<br>轻量级锁会自旋，当自旋到一定次数后就会发生膨胀，膨胀为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><table>
<thead>
<tr>
<th>锁</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td align="left">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td align="left">如果线程间存在竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td align="left">竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td align="left">如果始终得不到锁竞争的线程使用自旋会消耗CPU 追求响应时间。</td>
<td>同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级</td>
<td align="left">线程竞争不使用自旋，不会消耗CPU。</td>
<td align="left">线程阻塞，响应时间满。</td>
<td>追求吞吐量。同步块执行速度较快。</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="synchronized修饰普通方法和静态方法的区别？什么是可见性？"><a href="#synchronized修饰普通方法和静态方法的区别？什么是可见性？" class="headerlink" title="synchronized修饰普通方法和静态方法的区别？什么是可见性？"></a>synchronized修饰普通方法和静态方法的区别？什么是可见性？</h3><ul>
<li>锁的对象实例<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-dcaa4928eb8e2b28.png" alt="image.png"></li>
<li>锁的当前类唯一的.class对象 -&gt;类锁<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654312536892.png" alt="1654312536892"></li>
<li>假如有两个线程分别执行上面各个方法，可以同时执行，拿的不是同一个对象锁。</li>
<li>注意：加锁加的是对象锁，只要不是同一个对象锁，并行执行就不会有问题。</li>
</ul>
<h3 id="单例模式中的懒汉式-延迟初始化占位类模式"><a href="#单例模式中的懒汉式-延迟初始化占位类模式" class="headerlink" title="单例模式中的懒汉式-延迟初始化占位类模式"></a>单例模式中的懒汉式-延迟初始化占位类模式</h3><p>为什么饿汉式与延迟占位类模式是线程安全的？</p>
<blockquote>
<p>这是由类加载机制所保证的，一个类加载只会在虚拟机中执行一次，所以虚拟机为了保证执行性一次在类加载过程中已经实现了线程安全。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-03623aff31014070.png" alt="image.png"></p>
</blockquote>
<h3 id="Lock和synchronized的区别？"><a href="#Lock和synchronized的区别？" class="headerlink" title="Lock和synchronized的区别？"></a>Lock和synchronized的区别？</h3><p>1、lock是一个接口，而synchronized是java的一个关键字。</p>
<p>2、synchronized在发生异常时会自动释放占有的锁，因此不会出现死锁；而lock发生异常时，不会主动释放占有的锁，必须手动来释放锁，可能引起死锁的发生。</p>
<h3 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h3><p>守护（Daemon）线程是一种支持性线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c9bb6c9482992aac.png" alt="image.png"><br>线程的停止：</p>
<ul>
<li>run方法执行完成</li>
<li>执行过程中出现异常，终止</li>
<li>不建议使用stop方法，不安全（不考虑线程当前的执行状态直接结束）</li>
<li>interrupt，协议机制 ，被中断的线程内部方法isInterrupted()或Thread.interrupted()判断线程是否进行中断。</li>
</ul>
<h3 id="sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）"><a href="#sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）" class="headerlink" title="sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）"></a>sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）</h3><ul>
<li><p>yield方法让出CPU的执行权，什么时候拿回来由操作系统决定，使当前线程进入就绪状态（注意：yield()方法只会给优先级相同，或优先级更高的线程执行机会）。（让出CPU的执行权）</p>
</li>
<li><p>sleep让当前线程 进行休眠，使当前线程进入阻塞状态，直到经过阻塞时间才会转入就绪状态（通常用于暂停线程的执行）</p>
</li>
<li><p>wait让当前线程等待，这三者只有wait方法会释放锁，唤醒后重新竞争锁。（主要用于线程之间的交互）</p>
<blockquote>
<p>wait()的作用是让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。“直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法”，当前线程被唤醒(进入“就绪状态”)</p>
</blockquote>
</li>
</ul>
<h3 id="sleep是可中断的吗？"><a href="#sleep是可中断的吗？" class="headerlink" title="sleep是可中断的吗？"></a>sleep是可中断的吗？</h3><p>是，调用Thread.sleep()会抛出一个中断异常，说明是可以中断的。</p>
<h3 id="有三个线程T1、T2、T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1、T2、T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1、T2、T3，怎么确保它们按顺序执行？"></a>有三个线程T1、T2、T3，怎么确保它们按顺序执行？</h3><p>加入执行顺序：T1-&gt;T2-&gt;T3<br>T3方法中T2.join()<br>T2方法中T1.join()</p>
<h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><ul>
<li>sleep和wait都可设置时间</li>
<li>只有synchronized才会使线程进入阻塞态</li>
<li>Lock进入等待或超时等待态</li>
</ul>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-77d154ac11d5e97c.png" alt="image.png"></p>
<h3 id="手写死锁"><a href="#手写死锁" class="headerlink" title="手写死锁"></a>手写死锁</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-836114f93d4bea42.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>Java筑基</category>
      </categories>
  </entry>
  <entry>
    <title>模板</title>
    <url>/2022/07/12/%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h3 id="关于Hexo搭建遇到的小问题"><a href="#关于Hexo搭建遇到的小问题" class="headerlink" title="关于Hexo搭建遇到的小问题"></a>关于Hexo搭建遇到的小问题</h3><p><img src="/%E6%B5%8B%E8%AF%95.assets/1657615742531.png" alt="1657615742531"></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>按Z字形顺序打印二叉树</title>
    <url>/2022/07/17/%E6%8C%89Z%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br>数据范围：0≤n≤1500,树上每个节点的val满足∣val∣≤1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717104011278.png" alt="image-20220717104011278"></p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote>
<p>输入：{1,2,3,#,#,4,5}<br>输出： [[1],[3,2],[4,5]]<br>说明：如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。</p>
</blockquote>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这其实就是一个升级版的层序遍历.<br>观察其特点,无非就是奇数层和偶数层的输出顺序不一样. 这样就有了初步的解题思路,设置标识符flag(可以为整数型,也可以为boolean类型,整数类型无非就是对奇偶数的判断).<br>其余的思路就是层序遍历的思路,在每遍历新的一层之前,改变flag的值!flag(这里以boolean类型为例),然后就是利用Collections.reverse(list)对链表进行翻转.<br>详情可看代码</p>
<blockquote>
<p>这里,小编再提一下我初次遇到这道题的思路,前面的几乎一样,就是在实现链表反转这里,小编不熟悉Java库,没想到还有Colection.reverse这个方法可以用.<br>所以,小编在想反转的时候首先就想到了咱们的栈,也就是根据flag的值判断,从队列出来的值是否需要进一次栈实现反转</p>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        temp.offer(head);</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> temp.size();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">                p = temp.poll();</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    temp.offer(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    temp.offer(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(p.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这次是小编完善Hexo搭建后的第一篇博客，前面的都是在没完全搭建好的时候测试发送的。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义PhotoView手势处理</title>
    <url>/2022/08/13/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p> 前面介绍了前面介绍了嵌套滑动、自定义Behavior等高级UI实现原理，今天介绍一种比较简单的高级UI用法——手势处理。</p>
<p> 你可以点开自己的手机相册，点开任意一张图片，双击图片会有放大效果，再次双击会缩小为原来大小。并且双指操作可以放大缩小图片。今天，小编就来实现一下这样的PhotoView效果。但是我的效果处理肯定不是很完美，毕竟追求代码简洁。</p>
</blockquote>
<p>效果展示图：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_13_16_02_16_954.gif" alt="录制_2022_08_13_16_02_16_954"></p>
<h2 id="手势处理API"><a href="#手势处理API" class="headerlink" title="手势处理API"></a>手势处理API</h2><p>首先，先介绍一个Android处理单指手势的API <code>GestureDetector</code>，在创建一个GestureDetector对象时需要传入一个监听者<code>OnGestureListener</code>，所以我们需要实现OnGestureListener，通常实现SimpleOnGestureListener这个接口里面的功能就足够我们使用了，所以实现它即可。</p>
<p><strong>SimpleOnGestureListener的方法介绍</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoScaleGestureDetector</span> <span class="keyword">extends</span> <span class="title class_">GestureDetector</span>.SimpleOnGestureListener&#123;</span><br><span class="line">        <span class="comment">//在ACTION_DOWN时触发，必定触发</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDown</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onDown(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//延时100ms，处理点击效果</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onShowPress</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onShowPress(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//up时触发，单击或双击的第一次，不是双击和长按</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onSingleTapUp</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onSingleTapUp(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e1 手指按下</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e2 当前的事件</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> distanceX oldX - newX</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> distanceY oldY - newY -&gt;向右滑得到的是负数，所以需要取与distance相反的值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onScroll</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e1, <span class="meta">@NonNull</span> MotionEvent e2, <span class="type">float</span> distanceX, <span class="type">float</span> distanceY)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onScroll(e1, e2, distanceX, distanceY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长按触发，默认达到300ms就会触发</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLongPress</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onLongPress(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手指松开后，惯性滑动，大于50dp/s</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onFling</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e1, <span class="meta">@NonNull</span> MotionEvent e2, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onFling(e1, e2, velocityX, velocityY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单击按下时触发，双击不触发，up和down都有可能触发</span></span><br><span class="line">        <span class="comment">// 延时300ms触发TAP事件</span></span><br><span class="line">        <span class="comment">// 300ms以内抬手才会触发TAP</span></span><br><span class="line">        <span class="comment">// 300ms以后抬手，不是双击，不是长按就触发</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onSingleTapConfirmed</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onSingleTapConfirmed(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双击，在ACTION_DWON中处理，触发时间 40-300ms</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDoubleTap</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onDoubleTap(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双击的第二次Down、move、up都会触发这个</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDoubleTapEvent</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onDoubleTapEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>下图是三个类或接口的时序关系，PhotoView为小编的自定义View。</p>
<blockquote>
<p>从时序图可以看出，我们只需要实例化SimpleOnGestureListener并且在对应的方法中做自己的处理，在onTouchEvent触摸事件中回调gestureDetector.onTouchEvent(event)就能将自定义的触摸事件设置完成。</p>
<p><strong>注：</strong>onDown必须返回true，否则就不会处理点击事件了。</p>
<p>另外需要注意的一个点是，如果GestureDetector是在子线程中创建的，还必须得调用Looper.prepare()，因为如果我们不手动传入一个handler实例，系统就会帮我们new一个，而Handler是会和所在线程进行一个绑定，必须进行prepare，而这个handler就是来处理触摸事件的，下面通过一张图来进行描述它们之间的关系</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813160810620.png" alt="image-20220813160810620"></p>
<p><strong>ScaleGestureDetector.OnScaleGestureListener的方法</strong></p>
<p>下面的代码是小编demo中的</p>
<p>scaleGestureDetector.getScaleFactor()为缩放因子</p>
<ul>
<li>onScaleBegin：scale变化前的处理</li>
<li>onScale：scale变化时，也就是双指缩放图片scale处理的位置</li>
<li>onScaleEnd：scale变化后的处理</li>
</ul>
<p><strong>注：</strong>onScaleBegin方法中必须返回true，否则双指操作无效</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoScaleGestureDetector</span> <span class="keyword">implements</span> <span class="title class_">ScaleGestureDetector</span>.<span class="property">OnScaleGestureListener</span> &#123;</span><br><span class="line"></span><br><span class="line">        float initScale;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">onScale</span>(<span class="params"><span class="meta">@NonNull</span> ScaleGestureDetector scaleGestureDetector</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((currentScale&gt;smallScale &amp;&amp; !isEnlarge)||(currentScale==smallScale &amp;&amp; !isEnlarge))&#123;</span><br><span class="line">                isEnlarge = !isEnlarge;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缩放因子</span></span><br><span class="line">            currentScale = initScale * scaleGestureDetector.<span class="title function_">getScaleFactor</span>();</span><br><span class="line">            <span class="comment">//注意：一定要刷新，否则放大缩小效果就很生硬</span></span><br><span class="line">            <span class="title function_">invalidate</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">onScaleBegin</span>(<span class="params"><span class="meta">@NonNull</span> ScaleGestureDetector scaleGestureDetector</span>) &#123;</span><br><span class="line">            initScale = currentScale;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onScaleEnd</span>(<span class="params"><span class="meta">@NonNull</span> ScaleGestureDetector scaleGestureDetector</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="图片缩放效果的实现"><a href="#图片缩放效果的实现" class="headerlink" title="图片缩放效果的实现"></a>图片缩放效果的实现</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PhotoGestureDetector extends GestureDetector.SimpleOnGestureListener &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">Down(@NonNull MotionEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">DoubleTap(@NonNull MotionEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">            isEnlarge = !isEnlarge;</span><br><span class="line">            <span class="keyword">if</span> (isEnlarge)&#123;</span><br><span class="line">                <span class="comment">//经过一次放大后缩小后点击新的位置，从该位置为中心放大，所以需要重置offset</span></span><br><span class="line">                offsetX = (e.get<span class="constructor">X()</span>-get<span class="constructor">Width()</span>/<span class="number">2</span>f)-(e.get<span class="constructor">X()</span>-get<span class="constructor">Width()</span>/<span class="number">2</span>f)<span class="operator"> * </span>(bigScale/smallScale);</span><br><span class="line">                offsetY = (e.get<span class="constructor">Y()</span>-get<span class="constructor">Height()</span>/<span class="number">2</span>f)-(e.get<span class="constructor">Y()</span>-get<span class="constructor">Height()</span>/<span class="number">2</span>f)* (bigScale/smallScale);</span><br><span class="line">                fix<span class="constructor">Offsets()</span>;</span><br><span class="line">                currentScale = bigScale;</span><br><span class="line">                get<span class="constructor">ScaleAnim(<span class="params">smallScale</span>,<span class="params">bigScale</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                currentScale = smallScale;</span><br><span class="line">                get<span class="constructor">ScaleAnim(<span class="params">smallScale</span>,<span class="params">bigScale</span>)</span>.reverse<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.on<span class="constructor">DoubleTap(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param e1 手指按下</span></span><br><span class="line"><span class="comment">         * @param e2 当前的事件</span></span><br><span class="line"><span class="comment">         * @param distanceX oldX - newX</span></span><br><span class="line"><span class="comment">         * @param distanceY oldY - newY -&gt;向右滑得到的是负数，所以需要取与distance相反的值</span></span><br><span class="line"><span class="comment">         * @return</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">Scroll(@NonNull MotionEvent <span class="params">e1</span>, @NonNull MotionEvent <span class="params">e2</span>, <span class="params">float</span> <span class="params">distanceX</span>, <span class="params">float</span> <span class="params">distanceY</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEnlarge)&#123;</span><br><span class="line">                offsetX -= distanceX;</span><br><span class="line">                offsetY -= distanceY;</span><br><span class="line">                fix<span class="constructor">Offsets()</span>;</span><br><span class="line">                invalidate<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.on<span class="constructor">Scroll(<span class="params">e1</span>, <span class="params">e2</span>, <span class="params">distanceX</span>, <span class="params">distanceY</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">Fling(@NonNull MotionEvent <span class="params">e1</span>, @NonNull MotionEvent <span class="params">e2</span>, <span class="params">float</span> <span class="params">velocityX</span>, <span class="params">float</span> <span class="params">velocityY</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEnlarge)&#123;</span><br><span class="line">                overScroller.fling(</span><br><span class="line">                        (<span class="built_in">int</span>)offsetX,</span><br><span class="line">                        (<span class="built_in">int</span>)offsetY,</span><br><span class="line">                        (<span class="built_in">int</span>) velocityX,</span><br><span class="line">                        (<span class="built_in">int</span>) velocityY,</span><br><span class="line">                        -(<span class="built_in">int</span>) (bitmap.get<span class="constructor">Width()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Width()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        (<span class="built_in">int</span>) (bitmap.get<span class="constructor">Width()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Width()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        -(<span class="built_in">int</span>) (bitmap.get<span class="constructor">Height()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Height()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        (<span class="built_in">int</span>) (bitmap.get<span class="constructor">Height()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Height()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        <span class="number">300</span>,</span><br><span class="line">                        <span class="number">300</span></span><br><span class="line">                );</span><br><span class="line">                post<span class="constructor">OnAnimation(<span class="params">new</span> FlingRunner()</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return super.on<span class="constructor">Fling(<span class="params">e1</span>, <span class="params">e2</span>, <span class="params">velocityX</span>, <span class="params">velocityY</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个算法用于限制图片偏移的范围</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164000778.png" alt="image-20220813164000778"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813170526346.png" alt="image-20220813170526346"></p>
<blockquote>
<p>惯性事件处理</p>
<p>其他重要参数截图中都有介绍，下面主要介绍一下postAnimation，一次只能移动一小段距离（一帧），需要多次调度动画直到完成滑动偏移，这里采用递归的方式，实例化一个Runnable放入postOnAnimation()中</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164706784.png"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164828771.png" alt="image-20220813164828771"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164423762.png" alt="image-20220813164423762"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void on<span class="constructor">SizeChanged(<span class="params">int</span> <span class="params">w</span>, <span class="params">int</span> <span class="params">h</span>, <span class="params">int</span> <span class="params">oldw</span>, <span class="params">int</span> <span class="params">oldh</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">SizeChanged(<span class="params">w</span>, <span class="params">h</span>, <span class="params">oldw</span>, <span class="params">oldh</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了避免图片展示的边上有空隙，最好使用float</span></span><br><span class="line">        originalOffsetX = (get<span class="constructor">Width()</span> - bitmap.get<span class="constructor">Width()</span>)<span class="operator"> / </span><span class="number">2</span>f;</span><br><span class="line">        originalOffsetY = (get<span class="constructor">Height()</span> - bitmap.get<span class="constructor">Height()</span>)<span class="operator"> / </span><span class="number">2</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是高度全屏还是宽度全屏</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">float</span>)bitmap.get<span class="constructor">Width()</span>/bitmap.get<span class="constructor">Height()</span>&gt;(<span class="built_in">float</span>) get<span class="constructor">Width()</span>/get<span class="constructor">Height()</span>)&#123;</span><br><span class="line">            smallScale = (<span class="built_in">float</span>) get<span class="constructor">Width()</span>/ bitmap.get<span class="constructor">Width()</span>;</span><br><span class="line">            bigScale = (<span class="built_in">float</span>) get<span class="constructor">Height()</span>/bitmap.get<span class="constructor">Height()</span>*OVER_SCALE_FACTOR;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            smallScale = (<span class="built_in">float</span>) get<span class="constructor">Height()</span>/bitmap.get<span class="constructor">Height()</span>;</span><br><span class="line">            bigScale = (<span class="built_in">float</span>) get<span class="constructor">Width()</span>/bitmap.get<span class="constructor">Width()</span>*OVER_SCALE_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        currentScale = smallScale;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void on<span class="constructor">Draw(Canvas <span class="params">canvas</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Draw(<span class="params">canvas</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据放大比例，设置一次滑动时偏移的尺寸，视觉上来看就是滑动速度</span></span><br><span class="line">        <span class="built_in">float</span> scaleFaction = (currentScale-smallScale)/(bigScale-smallScale);</span><br><span class="line">        canvas.translate(offsetX<span class="operator"> * </span>scaleFaction,offsetY<span class="operator"> * </span>scaleFaction);</span><br><span class="line"></span><br><span class="line">        canvas.scale(currentScale,currentScale,get<span class="constructor">Width()</span>/<span class="number">2</span>f,get<span class="constructor">Height()</span>/<span class="number">2</span>f);</span><br><span class="line">        canvas.draw<span class="constructor">Bitmap(<span class="params">bitmap</span>,<span class="params">originalOffsetX</span>,<span class="params">originalOffsetY</span>,<span class="params">paint</span>)</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>判断是单指处理还是双指处理</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">       boolean result = scaleGestureDetector.on<span class="constructor">TouchEvent(<span class="params">event</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span>(!scaleGestureDetector.is<span class="constructor">InProgress()</span>)&#123;</span><br><span class="line">           result = gestureDetector.on<span class="constructor">TouchEvent(<span class="params">event</span>)</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h2 id="关于多指触摸事件"><a href="#关于多指触摸事件" class="headerlink" title="关于多指触摸事件"></a>关于多指触摸事件</h2><ul>
<li><p><strong>注意：</strong>多指处理需要<code>event.getActionMasked()</code></p>
</li>
<li><p>一次触摸事件中Down和Up都只触发一次</p>
</li>
<li><p>多指触摸事件是存储在一个键值（&lt;id，index&gt;）对数组中，从0开始，可以理解为一个SpareArray，需要一个currentPointId记录当前正在处理事件的手指。</p>
<p>该数组的规则：</p>
<ul>
<li>当手指Up，对应的id和index会从数组中移除，移除后数组会偏移补全，比如0-4移除3，4会补全3的位置，并且index变为3，而id不变</li>
<li>再有新的手指点击，如果前面的id不连续，会补全，比如接着上方的例子原来的index3会变为index4，而新的点击事件为id3、index3，也就是说id不会变，index会变</li>
</ul>
</li>
<li><p>lastOffsetX、lastOffsetY记录上一次的偏移值，否则有新的手指点击的话会出现图片“闪现”效果</p>
</li>
<li><p><code>event.findPointerIndex(Id)</code>通过Id获取Index</p>
</li>
<li><p><code>event.getActionIndex()</code>获取当前触摸手指的index，<code>event.getPointerId(actionIndex)</code>通过index获取id</p>
</li>
<li><p>抬起的手指是活跃手指并且是最后一个按下的手指，那么活跃手指更新为抬起手指的前一个-&gt;upIndex &#x3D; event.getPointerCount() -2</p>
</li>
<li><p>如果抬起手指是中间的并且是活跃手指，那么活跃手指更新为下一个-&gt;upIndex++</p>
</li>
<li><p>以上两点都是根据多指触摸事件数组规则做出的判断</p>
</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">        switch (event.get<span class="constructor">ActionMasked()</span>)&#123;</span><br><span class="line">            <span class="comment">//Down和Up都只触发一次</span></span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                downX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                downY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                lastOffsetX = offsetX;</span><br><span class="line">                lastOffsetY = offsetY;</span><br><span class="line"></span><br><span class="line">                currentPointId = <span class="number">0</span>;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">// 通过id 拿index</span></span><br><span class="line">                <span class="keyword">if</span> (event.get<span class="constructor">PointerCount()</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">int</span> index = event.find<span class="constructor">PointerIndex(<span class="params">currentPointId</span>)</span>;</span><br><span class="line">                    <span class="comment">// event.getX()默认 index = 0的坐标 --- move操作的是后按下的手指</span></span><br><span class="line">                    offsetX = lastOffsetX + event.get<span class="constructor">X(<span class="params">index</span>)</span> - downX;</span><br><span class="line">                    offsetY = lastOffsetY + event.get<span class="constructor">Y(<span class="params">index</span>)</span> - downY;</span><br><span class="line">                    invalidate<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">                <span class="comment">//获取当前（最后一次）按下的index</span></span><br><span class="line">                <span class="keyword">if</span> (event.get<span class="constructor">PointerCount()</span>&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">int</span> actionIndex = event.get<span class="constructor">ActionIndex()</span>;</span><br><span class="line">                    currentPointId = event.get<span class="constructor">PointerId(<span class="params">actionIndex</span>)</span>;</span><br><span class="line"></span><br><span class="line">                    downX = event.get<span class="constructor">X(<span class="params">actionIndex</span>)</span>;</span><br><span class="line">                    downY = event.get<span class="constructor">Y(<span class="params">actionIndex</span>)</span>;</span><br><span class="line">                    lastOffsetX = offsetX;</span><br><span class="line">                    lastOffsetY = offsetY;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="built_in">int</span> upIndex = event.get<span class="constructor">ActionIndex()</span>;</span><br><span class="line">                    <span class="built_in">int</span> pointId = event.get<span class="constructor">PointerId(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                    <span class="comment">//非活跃的手指不用处理</span></span><br><span class="line">                    <span class="keyword">if</span> (pointId==currentPointId)&#123;</span><br><span class="line">                        <span class="comment">//更新活跃手指</span></span><br><span class="line">                        <span class="keyword">if</span> (upIndex<span class="operator"> == </span>event.get<span class="constructor">PointerCount()</span>-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">//抬起的手指是活跃手指并且是最后一个按下的手指，那么活跃手指更新为抬起手指的前一个</span></span><br><span class="line">                            upIndex = event.get<span class="constructor">PointerCount()</span> -<span class="number">2</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//如果抬起手指是中间的并且是活跃手指，那么活跃手指更新为下一个</span></span><br><span class="line">                            upIndex++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        currentPointId = event.get<span class="constructor">PointerId(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                        downX = event.get<span class="constructor">X(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                        downY = event.get<span class="constructor">Y(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                        lastOffsetX = offsetX;</span><br><span class="line">                        lastOffsetY = offsetY;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，多指触摸事件很少使用，不过应用起来还是有很不错的效果。</p>
<p>实现PhotoView的效果重点就是<code>GestureDetector.SimpleOnGestureListener</code>、<code>ScaleGestureDetector.OnScaleGestureListener</code>这两个API的使用，其实自定义View这一块，只要把尺寸、偏移等这些处理好了实现想要的效果还是很容易的。</p>
<p>最后附上源码：</p>
<p><a href="https://github.com/gun-ctrl/PhotoView">源码地址</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>自定义View</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义LayoutManager实现卡片滑动</title>
    <url>/2022/07/23/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%E5%AE%9E%E7%8E%B0%E5%8D%A1%E7%89%87%E6%BB%91%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>前面介绍了利用自定义ItemDecoration实现RecyclerView吸顶效果，重点就在onDraw -&gt; ItemView -&gt; onDrawOver的绘制流程，同时注意预留空间的利用。</p>
<p>今天介绍一个新的知识点与demo，利用自定义LayoutManager的方式实现卡片滑动。有时候系统提供的LayoutManager已经不能够满足我们的需求，这个时候我们就需要自定义LayoutManager。</p>
</blockquote>
<h2 id="卡片滑动效果介绍"><a href="#卡片滑动效果介绍" class="headerlink" title="卡片滑动效果介绍"></a>卡片滑动效果介绍</h2><p>卡片滑动的效果如下图所示。</p>
<p>分析一下卡片效果，顶部的卡片是正常摆放，接着的后面两张会随着位置变化缩小、下移，产生视觉上的叠层效果，再然后的卡片就与第三张重叠摆放。可以滑动移除图片，下面的卡片会自动补全。</p>
<ul>
<li>实现这样的效果突破点在于两点：</li>
</ul>
<ol>
<li>要实现这样重叠式布局的效果，我们就需要自定义LayoutManager，就像系统自带的<code>LinearLayoutManager</code>、<code>GridLayoutManager</code>一样。</li>
<li>滑动移除效果的实现，没有重写<code>scrollVerticallyBy</code>以及<code>scrollHorizontallyBy</code>，这就需要一个重要的帮助类<code>ItemTouchHelper</code></li>
</ol>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/SlideCard.gif" alt="SlideCard"></p>
<h2 id="卡片滑动实现"><a href="#卡片滑动实现" class="headerlink" title="卡片滑动实现"></a>卡片滑动实现</h2><ul>
<li><p>实现思路</p>
<blockquote>
<ol>
<li>摆放策略交给LayoutManager-&gt;具体怎么摆，每一个卡片布局策略和数据绑定由Adapter负责</li>
<li>LayoutManager必须重写<code>onLayoutChildren</code>方法，当数据发生改变时，会重新布局，detachAndScrapAttachedViews处理回收，recycler.getViewForPosition(i)获取对应位置的View。</li>
<li>测量view，摆放时需要考虑通过ItemDecoration预留的间距<code>layoutDecoratedWithMargins</code></li>
<li>卡片采用的是倒序摆放，即从第8张到第一张的顺序摆放</li>
<li>利用<code>ItemTouchHelper</code>实现滑动移除，并且需要重写onChildDraw，实现滑动动画开始时，下方图片缩放效果。TouchHelper是ItemDecoration的子类，在onDraw时根据滑动距离来影响后面view的大小</li>
</ol>
</blockquote>
</li>
<li><p>关键代码块：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlideCardLayoutManager</span>:RecyclerView.LayoutManager() &#123;</span><br><span class="line">    override fun <span class="title function_">generateDefaultLayoutParams</span><span class="params">()</span>: RecyclerView.LayoutParams &#123;</span><br><span class="line">        <span class="keyword">return</span> RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        ViewGroup.LayoutParams.WRAP_CONTENT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onLayoutChildren</span><span class="params">(recycler: RecyclerView.Recycler?, state: RecyclerView.State?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onLayoutChildren(recycler, state)</span><br><span class="line">        detachAndScrapAttachedViews(recycler!!)</span><br><span class="line">        <span class="type">val</span> <span class="variable">itemCount</span> <span class="operator">=</span> itemCount</span><br><span class="line">        <span class="type">var</span> <span class="variable">bottomPosition</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount&lt;CardConfig.MAX_SHOW_COUNT)&#123;</span><br><span class="line">            bottomPosition = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            bottomPosition = itemCount - CardConfig.MAX_SHOW_COUNT</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i in bottomPosition until  itemCount)&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recycler.getViewForPosition(i)</span><br><span class="line">            addView(view)</span><br><span class="line">            <span class="comment">//测量</span></span><br><span class="line">            measureChildWithMargins(view,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="type">val</span> <span class="variable">widthSpace</span> <span class="operator">=</span> width - getDecoratedMeasuredHeight(view)</span><br><span class="line">            <span class="type">val</span> <span class="variable">heightSpace</span> <span class="operator">=</span> height - getDecoratedMeasuredHeight(view)</span><br><span class="line">            <span class="comment">//布局</span></span><br><span class="line">            layoutDecoratedWithMargins(view,</span><br><span class="line">            widthSpace/<span class="number">2</span>,</span><br><span class="line">            heightSpace/<span class="number">2</span>,</span><br><span class="line">            widthSpace/<span class="number">2</span>+getDecoratedMeasuredWidth(view),</span><br><span class="line">            heightSpace/<span class="number">2</span>+getDecoratedMeasuredHeight(view))</span><br><span class="line">            <span class="type">var</span> <span class="variable">level</span> <span class="operator">=</span> itemCount -i -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (level&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (level&lt;CardConfig.MAX_SHOW_COUNT-<span class="number">1</span>)&#123;<span class="comment">//提示，这里CardConfig.MAX_SHOW_COUNT=4，可见小编所有代码</span></span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * level</span><br><span class="line">                    view.scaleX = <span class="number">1</span>-CardConfig.SCALE_GAP*level</span><br><span class="line">                    view.scaleY = <span class="number">1</span>-CardConfig.SCALE_GAP*level</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * (level-<span class="number">1</span>)</span><br><span class="line">                    view.scaleX = <span class="number">1</span>-CardConfig.SCALE_GAP*(level-<span class="number">1</span>)</span><br><span class="line">                    view.scaleY = <span class="number">1</span>-CardConfig.SCALE_GAP*(level-<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：这里继承的是<code>ItemTouchHelper.SimpleCallback</code>，<code>ItemTouchHelper.Callback</code>需要重写的方法太多。</li>
<li>重写onChildDraw，因为notifyDataSetChanged()会走onDraw流程，而onDraw又会调用onChildDraw。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlideCallBack</span>(</span><br><span class="line">    <span class="keyword">private</span> val adapter:SlideCardAdapter,</span><br><span class="line">    <span class="keyword">private</span> val mData:MutableList&lt;SlideCardBean&gt;</span><br><span class="line">):ItemTouchHelper.SimpleCallback(<span class="number">0</span>,<span class="number">15</span>) &#123;</span><br><span class="line">    override fun <span class="title function_">onMove</span><span class="params">(</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        viewHolder: RecyclerView.ViewHolder,</span></span><br><span class="line"><span class="params">        target: RecyclerView.ViewHolder</span></span><br><span class="line"><span class="params">    )</span>: Boolean &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NotifyDataSetChanged&quot;)</span></span><br><span class="line">    override fun <span class="title function_">onSwiped</span><span class="params">(viewHolder: RecyclerView.ViewHolder, direction: Int)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">remove</span> <span class="operator">=</span> mData.removeAt(viewHolder.layoutPosition)</span><br><span class="line">        mData.add(<span class="number">0</span>,remove)</span><br><span class="line">        adapter.notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onChildDraw</span><span class="params">(</span></span><br><span class="line"><span class="params">        c: Canvas,</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        viewHolder: RecyclerView.ViewHolder,</span></span><br><span class="line"><span class="params">        dX: Float,</span></span><br><span class="line"><span class="params">        dY: Float,</span></span><br><span class="line"><span class="params">        actionState: Int,</span></span><br><span class="line"><span class="params">        isCurrentlyActive: Boolean</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive)</span><br><span class="line">        <span class="type">val</span> <span class="variable">maxDistance</span> <span class="operator">=</span> recyclerView.width * <span class="number">0.5f</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">distance</span> <span class="operator">=</span> sqrt((dX*dX+dY*dY).toDouble())</span><br><span class="line">        <span class="type">var</span> <span class="variable">fraction</span> <span class="operator">=</span> distance/maxDistance</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(fraction&gt;<span class="number">1</span>)</span>&#123;</span><br><span class="line">            fraction= <span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">val</span> <span class="variable">itemCount</span> <span class="operator">=</span> recyclerView.childCount</span><br><span class="line">        Log.v(<span class="string">&quot;ppp&quot;</span>,<span class="string">&quot;itemCount: $itemCount&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(i in <span class="number">0</span> until itemCount)&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recyclerView.getChildAt(i)</span><br><span class="line">            <span class="type">val</span> <span class="variable">level</span> <span class="operator">=</span> itemCount - i - <span class="number">1</span></span><br><span class="line">            Log.v(<span class="string">&quot;pc&quot;</span>,<span class="string">&quot;level: $level&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (level&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//重绘level=1，2 -&gt;也就是i=5,6</span></span><br><span class="line">                <span class="keyword">if</span> (level&lt;CardConfig.MAX_SHOW_COUNT-<span class="number">1</span>)&#123;</span><br><span class="line">                    view.translationY = (CardConfig.TRANS_Y_GAP * (level-fraction)).toFloat()</span><br><span class="line">                    view.scaleX = (<span class="number">1</span>-CardConfig.SCALE_GAP*level+fraction*CardConfig.SCALE_GAP).toFloat()</span><br><span class="line">                    view.scaleY = (<span class="number">1</span>-CardConfig.SCALE_GAP*level+fraction*CardConfig.SCALE_GAP).toFloat()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s时间</span></span><br><span class="line">    override fun <span class="title function_">getAnimationDuration</span><span class="params">(</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        animationType: Int,</span></span><br><span class="line"><span class="params">        animateDx: Float,</span></span><br><span class="line"><span class="params">        animateDy: Float</span></span><br><span class="line"><span class="params">    )</span>: Long &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前为止，小编已经介绍了RecyclerView自定义用法的两种，自定义ItemDecoration和自定义LayoutManager。这里有一个逻辑上的坑点：顶部的卡片是正常摆放，我们自定义LayoutManager中不用管它，所以在上方两个代码块中都有<code>level&gt;0</code>和<code>level&lt;CardConfig.MAX_SHOW_COUNT-1</code>，也就是重绘索引值<code>i=5,6</code>即第6和7个，在<code>SlideCardLayoutManager</code>中，第5张卡片即一下的重叠在第6张的下面。这个点烦恼了小编好久，刚开始一直不明白顶部的摆放去哪了，从这点可以看出了解原理看源码的重要性。下一章，我们将对RecyclerView源码机制进行解读，再结合这一章的内容，将会对RecyclerView的原理有个更深层次的理解。</p>
<p><a href="https://github.com/gun-ctrl/SlideCard">全部代码地址</a></p>
]]></content>
      <categories>
        <category>高级UI</category>
      </categories>
      <tags>
        <tag>高级UI</tag>
      </tags>
  </entry>
  <entry>
    <title>组件化开发</title>
    <url>/2022/12/12/%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h3 id="什么是组件化？"><a href="#什么是组件化？" class="headerlink" title="什么是组件化？"></a>什么是组件化？</h3><blockquote>
<p>在项目开发中往往根据功能的不同划分多个模块，在小型项目中大家往往会把各模块放置到对应的包当中，这样是很方便，小编也喜欢这样干。但是，划重点！是“小”项目中，要是大项目还是按包来划分后期改动的时候会不会牵一发而动全身呢？会的。所以组件化登场了，将每个功能分成独立模块，模块之间独立性强却有些许联系。如此，我们在更改代码时就不会遇到前面所说的困扰了。下面，我上一份图来帮助大家理解。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212180059339.png" alt="image-20221212180059339"></p>
<ul>
<li>app壳工程<ul>
<li>模块之间相互独立，那就需要一个“主子”来统筹全局，那就是app壳工程</li>
</ul>
</li>
<li>业务组件化<ul>
<li>这就是各个功能模块，比如用户注册登录、首页、个人等等</li>
</ul>
</li>
<li>公共基础库<ul>
<li>这里集成着项目中每个或多个模块需要的基础功能，也就是共享库。比如基本数据、网络访问框架、Application（的context）、工具类Utils。</li>
</ul>
</li>
</ul>
<h4 id="组件化优势"><a href="#组件化优势" class="headerlink" title="组件化优势"></a>组件化优势</h4><ul>
<li>层次分明，即使是另一个人接手项目也能清晰项目框架，很快入手项目</li>
<li>拆卸方便，某个模块不想要了或者要替换成另一个模块，直接拆卸即可，只需要做很小的改动</li>
<li>不相互依赖，前面提到过，依赖性太强会导致改动太大</li>
<li>重复利用</li>
</ul>
<h3 id="集成环境-x2F-组件环境部署配置"><a href="#集成环境-x2F-组件环境部署配置" class="headerlink" title="集成环境&#x2F;组件环境部署配置"></a>集成环境&#x2F;组件环境部署配置</h3><h4 id="创建新模块"><a href="#创建新模块" class="headerlink" title="创建新模块"></a>创建新模块</h4><p>在Android Studio中创建一个项目，在左上角app处右键new一个module出来，见下图，这就将作为业务组件层。当然，一个项目中的业务组件层有很多module，再new就好</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212181551729.png" alt="image-20221212181551729"></p>
<h4 id="创建公共基础库"><a href="#创建公共基础库" class="headerlink" title="创建公共基础库"></a>创建公共基础库</h4><p>几乎同样的步骤和注意事项，但是请注意：这里创建的是Android Library依赖库，也就是没有UI的代码仓库。</p>
<p>并且，公共依赖库最好只有这一个。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212181931950.png" alt="image-20221212181931950"></p>
<p>见下图可以看到，小编创建了两个业务组件以及一个公共依赖库。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212182206688.png" alt="image-20221212182206688"></p>
<h4 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h4><blockquote>
<p>这个要麻烦一点，主要是细心。我们先来看看项目中gradle的组成</p>
<p>1、这是gradle的根文件，咱们用不到</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212182459708.png"></p>
<p>2、这是整个项目的build.gradle文件，后面我将在这做一点操作，相信大家也看出来，就那一行代码，后面再说。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212182727574.png" alt="image-20221212182727574"></p>
<p>3、这是每个模块的build.gradle，这里展示app的，app壳咱也能当做一个模块，只是它是“老大哥”，和每个组件有联系。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212182906438.png" alt="image-20221212182906438"></p>
</blockquote>
<p>下面，我们来部署环境。</p>
<p><strong>为什么要环境部署呢？</strong>下图大家都熟悉，是build.gradle里的配置，我们需要保证各模块的版本配置相同，才能保证在相同的环境运行。</p>
<blockquote>
<p>观察下面的这些变量都有一个共同点——&gt;以键值对的形式存在，所以我们要想办法造一个公共库，直接调取里面的变量。</p>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212195515443.png" alt="image-20221212195515443"></p>
<ol>
<li><p>new一个gradle扩展块,这是groovy语法，不过对于学过面向对象的大家也不是问题；</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212183111198.png" alt="image-20221212183111198"></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展块</span></span><br><span class="line">ext&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//区分测试环境和正式环境</span></span><br><span class="line">    isRelease = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟正式环境和测试环境的服务器地址</span></span><br><span class="line">    url = [</span><br><span class="line">            <span class="string">&quot;debug&quot;</span>   :<span class="string">&quot;https://192.188.22.99/debug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;release&quot;</span> :<span class="string">&quot;https://192.188.22.99/release&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立Map存储，key和value  都是自定义的</span></span><br><span class="line">    androidID = [</span><br><span class="line">            <span class="attr">compileSdk       :</span><span class="number">32</span>,</span><br><span class="line">            <span class="attr">applicationId    :</span><span class="string">&quot;com.example.skindemo&quot;</span>,</span><br><span class="line">            <span class="attr">minSdk           :</span><span class="number">28</span>,</span><br><span class="line">            <span class="attr">targetSdk        :</span><span class="number">32</span>,</span><br><span class="line">            <span class="attr">versionCode      :</span><span class="number">1</span>,</span><br><span class="line">            <span class="attr">versionName      :</span><span class="string">&quot;1.0&quot;</span>,</span><br><span class="line">            <span class="attr">testInstrumentationRunner :</span><span class="string">&quot;androidx.test.runner.AndroidJUnitRunner&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    appID = [</span><br><span class="line">            <span class="attr">app :</span> <span class="string">&quot;com.example.skindemo&quot;</span>,</span><br><span class="line">            <span class="symbol">home:</span> <span class="string">&quot;com.example.home&quot;</span>,</span><br><span class="line">            <span class="symbol">login:</span> <span class="string">&quot;com.example.login&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dependenciesID = [</span><br><span class="line">            <span class="string">&quot;core-ktx&quot;</span>     :<span class="string">&#x27;androidx.core:core-ktx:1.7.0&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;appcompat&quot;</span>    :<span class="string">&#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;material&quot;</span>     :<span class="string">&#x27;com.google.android.material:material:1.4.0&#x27;</span>,</span><br><span class="line">            <span class="attr">implementation :</span><span class="string">&#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;navigation-fragment-ktx&quot;</span> :<span class="string">&#x27;androidx.navigation:navigation-fragment-ktx:2.3.5&#x27;</span>,</span><br><span class="line">            <span class="string">&quot;navigation-ui-ktx&quot;</span> :<span class="string">&#x27;androidx.navigation:navigation-ui-ktx:2.3.5&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>isRelease：用来判断是否是正式环境，如果是测试环境，那么功能子模块就能独立运行，否则就只能寄存与app壳运行。什么意思呢？看到下方的叉叉没有，那就是不能独立运行，也就是我们把isRelease设置为true的情况。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212194830481.png" alt="image-20221212194830481"></p>
</li>
<li><p>url：这个不用管，是模拟的两种服务器地址，这是虚拟的，没有用，读者可不敲。</p>
</li>
<li><p>androidID：这是个键值对存储，就和Map一样，里面存储的value信息就是前面提到的版本信息。</p>
</li>
<li><p>appID：不同模块的路径</p>
</li>
<li><p>dependenciesID：看名字就知道是模块中各种依赖的键值对，但注意只有implementation相关的才提到扩展gralde中</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212195722179.png" alt="image-20221212195722179"></p>
</li>
</ul>
</li>
<li><p>在<strong>整个项目的build.gradle</strong>（注意不是root.gradle）中引入我们刚创建的扩展块，这样就能在模块的build.gradle访问扩展块里的数据了。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221212195937100.png" alt="image-20221212195937100"></p>
</li>
<li><p>修改模块的build.gradle的代码，我以home为例。</p>
<p>注意：最开始的<code>isRelease</code>这部分判断是业务组件（功能模块）的独有部分，前面已经对这个字段作用解说过了。</p>
<p><code>def androidID = rootProject.ext.androidID</code>这段代码不要也行，只不过有了这段代码相当于持有缓存，下次访问就直接访问缓存，相当于一种优化。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isRelease)&#123;</span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.library&#x27;</span><span class="comment">//正式环境 不能独立运行</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    apply <span class="attr">plugin:</span> <span class="string">&#x27;com.android.application&#x27;</span><span class="comment">//测试环境</span></span><br><span class="line">&#125;</span><br><span class="line">apply <span class="attr">plugin:</span> <span class="string">&#x27;org.jetbrains.kotlin.android&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> androidID = rootProject.ext.androidID</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdk androidID.compileSdk</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRelease)&#123;</span><br><span class="line">            applicationId appID.home</span><br><span class="line">        &#125;</span><br><span class="line">        minSdk androidID.minSdk</span><br><span class="line">        targetSdk androidID.targetSdk</span><br><span class="line">        versionCode androidID.versionCode</span><br><span class="line">        versionName androidID.versionName</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner androidID.testInstrumentationRunner</span><br><span class="line">        viewBinding&#123;</span><br><span class="line">            enabled = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里的代码看着是不是很舒服？因为groovy语法属于Java子语言的一种，所以看着非常好理解，这里用到了foreach。另外，<code>implementation project(&#39;:common&#39;)</code>这是依赖其他模块的操作，common是所有模块的公共依赖库，所以都会对其依赖。依赖后，就能使用里面的类和方法。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line">    dependenciesID.each&#123;k,v -&gt; implementation v&#125;</span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line"></span><br><span class="line">    implementation project(<span class="string">&#x27;:common&#x27;</span>) <span class="comment">//公共基础库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再展现一下common的build.gradle，因为其不同的多一点。（plugins和dependencies处的不同）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.library&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;org.jetbrains.kotlin.android&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> androidID = rootProject.ext.androidID</span><br><span class="line">android &#123;</span><br><span class="line">    compileSdk androidID.compileSdk</span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdk androidID.minSdk</span><br><span class="line">        targetSdk androidID.targetSdk</span><br><span class="line"></span><br><span class="line">        testInstrumentationRunner androidID.testInstrumentationRunner</span><br><span class="line">        consumerProguardFiles <span class="string">&quot;consumer-rules.pro&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="string">&#x27;proguard-rules.pro&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    kotlinOptions &#123;</span><br><span class="line">        jvmTarget = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.core:core-ktx:1.7.0&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span></span><br><span class="line">    dependenciesID.each&#123;k,v -&gt;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="string">&quot;core-ktx&quot;</span>)&#123;</span><br><span class="line">            implementation v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="string">&quot;appcompat&quot;</span>)&#123;</span><br><span class="line">            implementation v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="string">&quot;material&quot;</span>)&#123;</span><br><span class="line">            implementation v</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app壳作为“老大”，则需要对所有模块进行依赖。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.core:core-ktx:1.7.0&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.appcompat:appcompat:1.3.0&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;com.google.android.material:material:1.4.0&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.constraintlayout:constraintlayout:2.0.4&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.navigation:navigation-fragment-ktx:2.3.5&#x27;</span></span><br><span class="line"><span class="comment">//    implementation &#x27;androidx.navigation:navigation-ui-ktx:2.3.5&#x27;</span></span><br><span class="line"></span><br><span class="line">    dependenciesID.each&#123;k,v -&gt; implementation v&#125;</span><br><span class="line"></span><br><span class="line">    testImplementation <span class="string">&#x27;junit:junit:4.13.2&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">    androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    implementation project(<span class="string">&#x27;:common&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isRelease)&#123;</span><br><span class="line">        <span class="comment">//依附于app壳</span></span><br><span class="line">        implementation project(<span class="string">&#x27;:login&#x27;</span>)</span><br><span class="line">        implementation project(<span class="string">&#x27;:home&#x27;</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不能依附app壳，因为login home都能独立运行，依附不了，否则报错</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="组件化中子模块交互方式"><a href="#组件化中子模块交互方式" class="headerlink" title="组件化中子模块交互方式"></a>组件化中子模块交互方式</h3><h4 id="类加载的方式"><a href="#类加载的方式" class="headerlink" title="类加载的方式"></a>类加载的方式</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> targetClass = Class.forName(<span class="string">&quot;com.example.login.LoginActivity&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,targetClass).apply &#123;</span><br><span class="line">           putExtra(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;joker&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>为什么这种方式可以呢？当我们buildAPK的时候可以发现，这工程中创建的所有的类都在一个文件夹下。</p>
<h4 id="全局Map"><a href="#全局Map" class="headerlink" title="全局Map"></a>全局Map</h4><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221213182001925.png" alt="image-20221213182001925"></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">PathBean</span></span>(<span class="keyword">var</span> path: String?, <span class="keyword">var</span> clazz: Class&lt;*&gt;?)</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> RecordPathManager &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> maps: MutableMap&lt;String, MutableList&lt;PathBean&gt;&gt; = HashMap()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> groupName 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pathName 路径名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz 跳转目标class对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addGroupInfo</span><span class="params">(groupName: <span class="type">String</span>, pathName: <span class="type">String</span>?, clazz: <span class="type">Class</span>&lt;*&gt;?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">var</span> list = maps[groupName]</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">null</span> == list) &#123;</span><br><span class="line">            list = ArrayList()</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(PathBean(pathName, clazz))</span><br><span class="line">        <span class="comment">//存入仓库</span></span><br><span class="line">        maps[groupName] = list</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">startTargetActivity</span><span class="params">(groupName: <span class="type">String</span>, pathName: <span class="type">String</span>)</span></span>: Class&lt;*&gt;? &#123;</span><br><span class="line">        <span class="keyword">val</span> list = maps[groupName]</span><br><span class="line">            ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">        <span class="comment">//遍历寻找“PathBean”对象</span></span><br><span class="line">        <span class="keyword">for</span> (pathBean <span class="keyword">in</span> list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pathName.equals(pathBean.path, ignoreCase = <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> pathBean.clazz</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后需要在app壳的Application中注册Activity：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">override <span class="keyword">fun</span> on<span class="constructor">Create()</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Create()</span></span><br><span class="line">        <span class="comment">//在注册表中注册Activity</span></span><br><span class="line">        mContext = context</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">RecordPathManager</span>.</span></span>add<span class="constructor">GroupInfo(<span class="string">&quot;app&quot;</span>,<span class="string">&quot;MainActivity&quot;</span>,MainActivity::<span class="params">class</span>.<span class="params">java</span>)</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">RecordPathManager</span>.</span></span>add<span class="constructor">GroupInfo(<span class="string">&quot;home&quot;</span>,<span class="string">&quot;HomeActivity&quot;</span>,HomeActivity::<span class="params">class</span>.<span class="params">java</span>)</span></span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">RecordPathManager</span>.</span></span>add<span class="constructor">GroupInfo(<span class="string">&quot;login&quot;</span>,<span class="string">&quot;LoginActivity&quot;</span>,LoginActivity::<span class="params">class</span>.<span class="params">java</span>)</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用1：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> clazz = RecordPathManager.startTargetActivity(<span class="string">&quot;home&quot;</span>,<span class="string">&quot;HomeActivity&quot;</span>)</span><br><span class="line">Intent(<span class="keyword">this</span>,clazz).apply &#123;</span><br><span class="line">      startActivity(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用2：</strong></p>
<p>也就是添加了携带数据和跳转动画</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> clazz = RecordPathManager.startTargetActivity(<span class="string">&quot;home&quot;</span>,<span class="string">&quot;HomeActivity&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,clazz).apply &#123;</span><br><span class="line">        putExtra(<span class="string">&quot;data&quot;</span>,<span class="string">&quot;kotlin&quot;</span>)</span><br><span class="line">        putExtra(<span class="string">&quot;second_data&quot;</span>,<span class="number">200</span>)</span><br><span class="line">&#125;</span><br><span class="line">binding.moveToHome.setOnClickListener &#123;</span><br><span class="line">        startActivity(intent)</span><br><span class="line">        overridePendingTransition(R.anim.translate_in,R.anim.translate_out)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ARouter"><a href="#ARouter" class="headerlink" title="ARouter"></a>ARouter</h4><p>使用阿里的开源框架，详情可见：<a href="https://links.jianshu.com/go?to=https://github.com/alibaba/ARouter">https://github.com/alibaba/ARouter</a></p>
<h3 id="我遇到的一些坑"><a href="#我遇到的一些坑" class="headerlink" title="我遇到的一些坑"></a>我遇到的一些坑</h3><h4 id="运行时产生多个“软件”"><a href="#运行时产生多个“软件”" class="headerlink" title="运行时产生多个“软件”"></a>运行时产生多个“软件”</h4><p>运行后手机桌面怎么有其他模块的图标？</p>
<p>对各个功能模块的<code>AndroidManifest.xml</code>进行如下操作：</p>
<p>将我注释的部分注释或删除，开发工具会自动将<code>AndroidManifest.xml</code>合并，一个App只能有一个自启动的Activity。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">&quot;com.example.home&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">&quot;@mipmap/ic_launcher&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">&quot;@mipmap/ic_launcher_round&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme.SkinDemo&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">&quot;.HomeActivity&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;intent-filter&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--            &lt;/intent-filter&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="跳转后还是在原来的activity中"><a href="#跳转后还是在原来的activity中" class="headerlink" title="跳转后还是在原来的activity中"></a>跳转后还是在原来的activity中</h4><p>将不同模块的activity改名即可，因为创建新模块时系统默认是main_activity</p>
<h4 id="关于Application"><a href="#关于Application" class="headerlink" title="关于Application"></a>关于Application</h4><p>我在前面的开发技巧中提过在Application中初始化全局的context，但是在组件化中却出了点问题，最终只有一个Application会生效，但是我们又不能让app壳被其他模块依赖，否则将出现循环依赖的问题。嗯？！公共依赖库中的代码不是其他模块都可以访问嘛，可以直接只创建公共基础库的Application吗？可以，但是如果使用前面的Map方式跳转怎么办，公共基础库没有依赖其他模块，肯定注册不了啊。那么怎么办，可以让公共依赖库创建一个BaseApplication，创建context，然后让app的Application继承BaseApplication，再初始化context。</p>
<p>BaseApplication</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseApplication</span>: <span class="type">Application</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="string">&quot;StaticFieldLeak&quot;</span>)</span></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> context: Context</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        context = applicationContext</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app的Application</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkinApplication</span>: <span class="type">BaseApplication</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="meta">@SuppressLint(<span class="string">&quot;StaticFieldLeak&quot;</span>)</span></span><br><span class="line">        <span class="keyword">lateinit</span> <span class="keyword">var</span> mContext: Context</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="comment">//在注册表中注册Activity</span></span><br><span class="line">        mContext = context</span><br><span class="line">        RecordPathManager.addGroupInfo(<span class="string">&quot;app&quot;</span>,<span class="string">&quot;MainActivity&quot;</span>,MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        RecordPathManager.addGroupInfo(<span class="string">&quot;home&quot;</span>,<span class="string">&quot;HomeActivity&quot;</span>,HomeActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        RecordPathManager.addGroupInfo(<span class="string">&quot;login&quot;</span>,<span class="string">&quot;LoginActivity&quot;</span>,LoginActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>小提醒：别忘了在<code>AndroidManifest.xml</code>中注册app的Application。</p>
<h3 id="小扩展"><a href="#小扩展" class="headerlink" title="小扩展"></a>小扩展</h3><p>可不可以通过Java&#x2F;kotlin代码层改变gradle定义的变量值呢？就比如我不想切到gradle而想改变isRelease的值，以达到改变项目是否发布的状态。</p>
<p>漏普吧不冷啊。</p>
<p>且看下面的操作：</p>
<p>这是我在app的gradle中添加的一行代码，其他模块也可以。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221214185156341.png" alt="image-20221214185156341"></p>
<p>看到没有，我能在MainActivity中获取isRelease了</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221214185349505.png" alt="image-20221214185349505"></p>
<p>这种应用还有很多，就比如前面小提了一下关于正式发布与测试的服务器地址的切换也可以这样操作。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221214185638066.png" alt="image-20221214185638066"></p>
<p>看见没有，很简单。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>之前在简书中作的那篇组件化文章太乱了，当时小编自己都没捋清楚前因后果。好在小编没有放弃，现在发现很简单嘛！于是就作了这篇文章，前后逻辑很清晰。</p>
</blockquote>
]]></content>
      <categories>
        <category>Android组件化</category>
      </categories>
      <tags>
        <tag>Android组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>阻塞队列与线程池机制</title>
    <url>/2022/07/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ul>
<li>1.Thread</li>
<li>2.Runnable（实例化接口，重新run方法，放入Thread中执行）</li>
</ul>
<p>为什么Callable方式不算?</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148325145.png" alt="1654148325145"></p>
<blockquote>
<p>首先，我们都知道创建线程都需要通过Thread，那么我们来看一下Thread的构造函数</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148402777.png" alt="1654148402777"></p>
<p>可以看到，Thread构造函数中压根就没有Callable类型的参数</p>
<p>接着，我们再来看看Callable，Callable是继承自FutureTask</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148426071.png" alt="1654148426071"></p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148455965.png" alt="1654148455965"></p>
<p>通过上面的源码截图，我们可以看出来Callable本质上还是Runnable的一种实现</p>
</blockquote>
<h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><strong>Compare And Swap</strong></p>
<blockquote>
<p>提及CAS之前，我们先来提一下原子操作，原子操作就是一气呵成，中间不能被打断，学过操作系统的朋友应该和熟悉，没错，就类似于操作系统中的中断原语。</p>
</blockquote>
<h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止。</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220730211300257.png" alt="image-20220730211300257"></p>
<blockquote>
<p>会有两个重要的属性变量，旧值与新值（需要更改的值），每次进入前都会用旧值与内存中的变量值进行比较，如果相同，就会用新值替换内存中的变量值，否则将再次循环上述过程。</p>
</blockquote>
<h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>什么是ABA问题呢？</strong></p>
<blockquote>
<p>就是旧值为A，被替换为新值B，后面的线程又替换为新值A。再后面的线程对比其存储的旧值与内存中的值相等，但是它并不知道中间有个A-&gt;B-&gt;A的过程。</p>
</blockquote>
<p><strong>解决方案</strong></p>
<p>通过打标识的方式标记：</p>
<p>1.AtomicMarkableReference-&gt;仅仅标识发生了ABA现象</p>
<p>2.AtomicStampedReference-&gt;可以知道发生了几次ABA现象</p>
<h4 id="开销问题"><a href="#开销问题" class="headerlink" title="开销问题"></a>开销问题</h4><blockquote>
<p>CAS是一个不断循环检测的过程，毫无疑问，这将带来一定的开销。</p>
</blockquote>
<h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><ul>
<li>jdk中相关原子操作类的使用<ul>
<li>更新基本类型：AtomicBoolean，AtomicInteger，AtomicLong</li>
<li>更新数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li>
<li>更新引用类型：AtomicReference，AtomicMarkableReference（只关心该没改过），AtomicStampedReference（还关心改过几次）</li>
</ul>
</li>
</ul>
<p>有些时候对于某些简单的操作采用加锁的话未免有些过重了，可以采用原子类型如果你需要改变多个变量，可以进行封装，通过AtomicReference来管理。</p>
<h2 id="线程池机制"><a href="#线程池机制" class="headerlink" title="线程池机制"></a>线程池机制</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><blockquote>
<p>线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。ThreadLocal可以让每个线程拥有属于自己的变量的副本，不会和其他线程的变量副本冲突，实现了线程的数据隔离</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-867510bb5ec6c143.png" alt="threadLocal"></p>
</blockquote>
<h3 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h3><p><strong>什么是线程池？为什么要用线程池？</strong></p>
<blockquote>
<ul>
<li>Thread线程属于操作系统的资源，消耗CPU、内存 -&gt;降低资源消耗</li>
<li>线程有创建、执行、销毁的时间，所以为什么不事先准备好呢？-&gt;提高响应度</li>
<li>所以需要一个策略机制来管理线程-&gt;提高线程的可管理性</li>
</ul>
</blockquote>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220731114721901.png" alt="image-20220731114721901"></p>
<h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a><strong>线程池的参数</strong></h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579455105.png" alt="1654140925994"></p>
<ul>
<li><p>keepAliveSize和TimeUnit这俩参数控制空闲线程存活的时间</p>
</li>
<li><p>ThreadFactory对创建线程时做这些微调工作</p>
</li>
<li><p>RejectedExecutionHandler 拒绝策略（阻塞队列满，任务数超过了最大线程数，那么就会拒绝）</p>
<ul>
<li>DiscardOldestPolicy 抛弃最老的，也就是队列队首的任务</li>
<li>AbortPolicy 直接抛出异常</li>
<li>CallerRunsPolicy  谁调用谁执行</li>
<li>DiscardPolicy 丢弃最新提交的任务</li>
</ul>
<p>当然也可以自己实现接口自定义拒绝策略</p>
</li>
<li><p>阻塞队列BlockingQueue</p>
</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li>
</ul>
<p>这里以okhttp中的实用场景对其中几种做简介：</p>
<p>在OkHttp的分发器中的线程池定义如上，其实就和 Executors.newCachedThreadPool()创建的线程一样。首先核心线程为0，表示线程池不会一直为我们缓存线程，线程池中所有线程都是在60s内没有工作就会被回收。而最大线程Integer .MAX_VALUE与等待队列synchronousQueue的组合能够得到最大的吞吐量。即当需要线程池执行任务时，如果不存在空闲线程不需要等待，马上新建线程执行任务!等待队列的不同指定了线程池的不同排队机制。一般来说，等待队列BlockingQueue有: (ArrayBlockingQueue 、LinkedBlockingQueue 与synchronousQueue 。</p>
<p>假设向线程池提交任务时，核心线程都被占用的情况下:</p>
<p>ArrayBlockingQueue :基于数组的阻塞队列，初始化需要指定固定大小</p>
<p>当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p>
<p>LinkedBlockingQueue :基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p>
<p>当指定大小后，行为就和ArrayBlockingQueue一致。而如果未指定大小，则会使用默认的Integer.MAX_VALUE作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p>
<p>SynchronousQueue :无容量的队列。</p>
<p>使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合Integer.MAX_VALUE就实现了真正的无等待。</p>
<p>但是需要注意的时，我们都知道，进程的内存是存在限制的，而每一个线程都需要分配一定的内存。所以线程并不能无限个数。那么当设置最大线程数为Integer.MAX_VALUE时，OkHttp同时还有最大请求任务执行个数: 64的限制。这样即解决了这个问题同时也能获得最大吞吐。</p>
<h3 id="两种线程池的提交任务的方法"><a href="#两种线程池的提交任务的方法" class="headerlink" title="两种线程池的提交任务的方法"></a>两种线程池的提交任务的方法</h3><ul>
<li><p>execute(不关心有无返回结果)</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579682668.png" alt="1654142332347"></p>
</li>
<li><p>submit</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579624953.png" alt="1654142400705"></p>
</li>
</ul>
<h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><ul>
<li><p>shutdown 尝试关闭一个线程，把当前没有执行任务的线程中断</p>
</li>
<li><p>shutdownNow 不管有没有执行任务的线程，都尝试中断</p>
<p>但是不一定成功  所谓线程的中断是一个协作机制  看任务执行方</p>
</li>
</ul>
<h3 id="合理配置线程池资源"><a href="#合理配置线程池资源" class="headerlink" title="合理配置线程池资源"></a>合理配置线程池资源</h3><p><strong>任务特性</strong></p>
<ul>
<li><p>CPU密集型  纯计算</p>
<p>配置最大线程数不要超过机器的CPU核心数（Runtime.getRuntime()）顶多+1（保证核心线程有事做），否则切换线程带来时间浪费</p>
</li>
<li><p>IO密集型 与网络、读取磁盘等IO操作相关的</p>
<p>最大线程数：机器的CPU核心线程数*2（推荐的经验值）</p>
</li>
<li><p>混合型 兼并上面两者 </p>
<p>如果两者的执行时间相差不大，拆分成两个线程池专门处理各自类型</p>
<p>如果两者相差很大，不用拆分（谁大配置谁）。</p>
</li>
</ul>
<p>核心线程数，看业务（详情参考Okhttp）</p>
]]></content>
      <categories>
        <category>Java筑基</category>
      </categories>
  </entry>
  <entry>
    <title>通知的创建</title>
    <url>/2022/10/31/%E9%80%9A%E7%9F%A5%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>小编在前面讲Service的时候用到了通知，还记得我们用来干嘛吗？没错，为了在程序退到后台后前台依然知道该程序的存在，在音乐、地图等APP非常常见。</p>
<p>通知是啥？拿起你的智能机，下拉一下通知栏。看到了吧！</p>
<p>但是，通知的设计初衷是好的，后来却被开发者玩坏了。</p>
<p>开发者为了增加自己的应用程序的打开率，发送各种各样的通知以博取更多的展示机会。作为用户的我们对这些垃圾信息非常厌恶。</p>
<p>虽然Android系统允许我们将某个应用程序的通知完全屏蔽，以防止它一直给我们发送垃圾信息，但是在这些信息中，也可能会有我们关心的内容。比如说我希望收到某个我关注的人的微博更新的消息，但是却不想微博一天到晚给我推一些垃圾信息。再过去，用户没有办法对这些信息做区分，要么同意接受所有信息，要么屏蔽所有信息，这也是Android通知功能的痛点。后来……</p>
</blockquote>
<h2 id="通知渠道"><a href="#通知渠道" class="headerlink" title="通知渠道"></a>通知渠道</h2><p>后来，Android8.0之后引入了通知渠道。</p>
<blockquote>
<p>通知渠道就是每条通知都要属于一个对应的渠道。每个应用都可以自由地创建当前应用的通知渠道，但是这些通知渠道的控制权是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动或者是否要关闭这个渠道的通知。</p>
<p>拥有了控制权之后，用户就再也不用怕那些垃圾通知了，因为用户可以自主地选择关心那些通知。比如，微博可以创建两种通知渠道，一个关注，一个推荐。作为用户的我，就可以关闭推荐的通知渠道。</p>
</blockquote>
<h2 id="通知的创建"><a href="#通知的创建" class="headerlink" title="通知的创建"></a>通知的创建</h2><p>通知的创建步骤千篇一律，只是因为不同的需求而导致细节不一样。</p>
<p>先贴代码，咱们再逐个讲解</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class="line">    <span class="keyword">val</span> channel = NotificationChannel(<span class="string">&quot;channelId&quot;</span>,<span class="string">&quot;NAME&quot;</span>,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">    manager.createNotificationChannel(channel)</span><br><span class="line">&#125;</span><br><span class="line">binding.sendNotification.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">    <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">&quot;channelId&quot;</span>)</span><br><span class="line">        .setContentTitle(<span class="string">&quot;我是一条通知&quot;</span>)</span><br><span class="line">        .setContentText(<span class="string">&quot;10月29日，在文昌航天发射场的测试发射大厅，工作人员组织了发射前最后一次系统间全区合练。各系统完成了相关功能检查，准备就绪，等待正式发射任务。“梦天”实验舱与长征五号B遥四运载火箭组合体在10月25日转运至发射区。&quot;</span>)</span><br><span class="line">        .setSmallIcon(R.drawable.small_icon)</span><br><span class="line">        .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.large_icon))</span><br><span class="line">        .setContentIntent(pi)</span><br><span class="line">        .setAutoCancel(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line">    manager.notify(NOTIFY_ID,notification)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先需要一个<code>NotificationManager</code>对通知进行管理，可以通过调用Context的<code>getSystemService()</code>方法获取。<code>getSystemService()</code>方法接收一个字符串参数用于确定获取系统的哪个服务，这里我们传入<code>Context.NOTIFICATION_SERVICE</code>即可；</p>
</li>
<li><p>创建通知渠道<code>NotificationChannel</code>，需要至少三个参数（渠道Id，渠道名称，重要等级）</p>
<ol>
<li>渠道Id，自定义，只要全局唯一就可以；</li>
<li>渠道名称，展示给用户看的</li>
<li>重要等级：有<code>IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW，IMPORTANCE_MIN</code>这几种，对应的重要程度一次从高到低。不同的通知等级会决定通知的不同行为。比如QQ的消息通知就是高重要等级，会弹出横幅、发出声音。</li>
</ol>
<p>因为<code>NotificationChannel</code>类和<code>createNotificationChannel()</code>方法都是Android8.0系统中新增的API，所以在使用的时候还需要加上一个版本判断<code>Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O</code>。</p>
</li>
<li><p>构建通知</p>
<p>需要一个Builder构造器来构建Notification对象，但问题在于，Android系统每一个版本都会对通知进行或多或少的修改，API不稳定问题凸显的尤为严重，所以AndroidX库中提供了<code>NotificationCompat</code>类，使用这个类的构造器创建Notification对象，就可以保证我们的程序在所有Android系统版本上能够正常工作了（AndroidX中很多<code>xxxCompat</code>类都是为了版本兼容）</p>
<p>然后就是一堆set方法，大家看名字应该就能看出来是干嘛的。</p>
</li>
<li><p>以上工作都完成后，只需要调用<code>NotificationManager</code>的<code>notify()</code>方法就可以让通知显示出来了。</p>
<p><code>notify()</code>接收两个参数：第一个参数是id，要保证为每个通知指定的id都是不同的，第二个则是Notification对象，这里直接将我们刚刚创建好的Notification对象传入即可。</p>
</li>
<li><p>但是如果仅仅按上述步骤操作，我们的通知仅仅起显示的作用，那么像我们平时收到的通知都是可以点击再进入应用的，细心的你应该发现了上述代码中还有一个关键的东西没提到——<code>PendingIntent</code>。</p>
<blockquote>
<p>PendingIntent，从名字上就知道是一个特殊的Intent。它们都能指明某一个“意图”，都可以用于启动Activity、启动Service以及发送广播等。不同的是，Intent倾向于立即执行某个动作，而PendingIntent倾向于在某个合适的时机执行某个动作。所以，也可以把PendingIntent简单理解为延迟执行的Intent。</p>
</blockquote>
<p><code>PendingIntent</code>的用法同样很简单，主要提供了几个静态方法用于获取PendingIntent的实例，可以根据要求来选择是使用getActivity()、getBroadcast()，还是getService()方法。接收的参数都是相同的：</p>
<ul>
<li>第一个参数是Context</li>
<li>第二个参数一般用不到，传0即可</li>
<li>第三个参数是Intent，把我们的Intent创建传入即可</li>
<li>第四个参数用于确定PendingIntent的行为，有<code>FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT</code>这4个值可选，具体请查看官网使用文档，通常情况下传0即可。</li>
</ul>
</li>
<li><p>还有一点，我们还需要让系统状态栏的图标消失（也就是我们上方设置的smallIcon），不然的话这个小图标就一直悬挂着。</p>
<p>有两种解决方案：</p>
<ul>
<li><p>第一种：像上方代码一样<code>setAutoCancel(true)</code></p>
</li>
<li><p>第二种：调用<code>manager.cancel(ID)</code>，还记得我们在发起通知时<code>manager.notify(NOTIFY_ID,notification)</code>吗？没错，传入的ID就是这里传入的<code>NOTIFY_ID</code>，当然这个ID是自创的唯一的，看下方代码就明白了。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> NOTIFY_ID = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> binding:ActivityMainBinding</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        manager.cancel(NOTIFY_ID)</span><br><span class="line">        ...</span><br><span class="line">        binding.sendNotification.setOnClickListener &#123;</span><br><span class="line">            ...</span><br><span class="line">            manager.notify(NOTIFY_ID,notification)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>来看效果展示：</p>
<p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E9%80%9A%E7%9F%A5demo.gif" alt="通知demo"></p>
</li>
</ol>
<h2 id="通知的进阶技巧"><a href="#通知的进阶技巧" class="headerlink" title="通知的进阶技巧"></a>通知的进阶技巧</h2><p>   当然，在上面我们只讲述了基本的通知创建，<code>NotificationCompat.Builder</code>中还提供了非常丰富的API，以便我们展示更好的通知效果。我们来学习一些常用的API。</p>
<blockquote>
<p>先来看看<code>setStyle()</code>方法，这个方法允许我们构建出富文本的通知内容。也就是说，通知中不光可以有文字和图标，还可以包含很多东西。<code>setStyle()</code>方法接收一个<code>NotificationCompat.Style</code>参数，这个参数就是用来构建具体的富文本信息的，比如长文字、图片等。</p>
</blockquote>
   <figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.<span class="constructor">Builder(<span class="params">this</span>,<span class="string">&quot;channelId&quot;</span>)</span></span><br><span class="line">                .set<span class="constructor">ContentTitle(<span class="string">&quot;我是一条通知&quot;</span>)</span></span><br><span class="line">                .set<span class="constructor">Style(NotificationCompat.BigTextStyle()</span>.big<span class="constructor">Text(<span class="string">&quot;10月29日，在文昌航天发射场的测试发射大厅，工作人员组织了发射前最后一次系统间全区合练。各系统完成了相关功能检查，准备就绪，等待正式发射任务。“梦天”实验舱与长征五号B遥四运载火箭组合体在10月25日转运至发射区。&quot;</span>)</span>)</span><br><span class="line">                .set<span class="constructor">SmallIcon(R.<span class="params">drawable</span>.<span class="params">small_icon</span>)</span></span><br><span class="line">                .set<span class="constructor">LargeIcon(BitmapFactory.<span class="params">decodeResource</span>(<span class="params">resources</span>,R.<span class="params">drawable</span>.<span class="params">large_icon</span>)</span>)</span><br><span class="line">                .set<span class="constructor">ContentIntent(<span class="params">pi</span>)</span></span><br><span class="line">                .set<span class="constructor">AutoCancel(<span class="params">true</span>)</span></span><br><span class="line">                .build<span class="literal">()</span></span><br></pre></td></tr></table></figure>

<p>   看下方效果，可以明显看出与<code>setContentText</code>的区别，能够显示完全部文字，而不是以省略号结尾。</p>
<p>   <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221031213742453.png" alt="image-20221031213742453"></p>
<blockquote>
<p>还能设置大图片，通过<code>NotificationCompat.BigPictureStyle</code>对象，这个对象就是用于设置大图片的，然后调用它的<code>bigPicture()</code>方法并将图片传入。</p>
</blockquote>
   <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">&quot;channelId&quot;</span>)</span><br><span class="line">     .setContentTitle(<span class="string">&quot;我是一条通知&quot;</span>)</span><br><span class="line">     .setStyle(NotificationCompat.BigPictureStyle().bigPicture(BitmapFactory.decodeResource(resources,R.drawable.big_image)))</span><br><span class="line">     .setSmallIcon(R.drawable.small_icon)</span><br><span class="line">     .setLargeIcon(BitmapFactory.decodeResource(resources,R.drawable.large_icon))</span><br><span class="line">     .setContentIntent(pi)</span><br><span class="line">     .setAutoCancel(<span class="literal">true</span>)</span><br><span class="line">     .build()</span><br></pre></td></tr></table></figure>

<p>   <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20221031214224887.png" alt="image-20221031214224887"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，我欠的一篇关于通知的文章就完成了。其实通知的创建步骤是固定的，只是因为我们的不同需求而处理更多的细节。</p>
<p>再来回忆一下创建通知的3步：1、创建NotificationManager；2、创建通知渠道NotificationChannel；3、通过NotificationCompat.Builder创建通知实体。</p>
<p>参考：《第一行代码》</p>
]]></content>
      <categories>
        <category>Android随笔</category>
      </categories>
  </entry>
</search>
