<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搬码人’s Blog</title>
  
  <subtitle>将来的你一定会感谢现在努力拼搏的态度</subtitle>
  <link href="https://gun-ctrl.github.io/atom.xml" rel="self"/>
  
  <link href="https://gun-ctrl.github.io/"/>
  <updated>2022-09-16T10:27:51.009Z</updated>
  <id>https://gun-ctrl.github.io/</id>
  
  <author>
    <name>搬码人</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>后台默默的劳动者，Service</title>
    <link href="https://gun-ctrl.github.io/2022/09/16/Service/"/>
    <id>https://gun-ctrl.github.io/2022/09/16/Service/</id>
    <published>2022-09-16T03:37:14.530Z</published>
    <updated>2022-09-16T10:27:51.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote><p>前段时间，小编在修改bug的时候和Service打了不少交道。突然发现，已经很久没碰过Service了，有些东西记忆模糊，那么今天做一个Service总结，方便日后查看。</p></blockquote><h2 id="Service是什么？"><a href="#Service是什么？" class="headerlink" title="Service是什么？"></a>Service是什么？</h2><p>Service是Android中实现程序后台运行的解决方案，它非常适合执行哪些不需要和用户交互而且要求长期运行的任务。Service的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，Service仍然能够保持正常运行。</p><p>不过需要注意的是，Service并不是运行在一个独立的进程中，而是依赖于创建Service时所在的应用程序的进程。当某个应用程序进程被杀时，所有依赖于该进程的Service也会停止运行。</p><p>另外，也不要被Service的后台概念所迷惑，实际上Service并不会自动打开线程，所有的代码都是默认运行在主线程中。也就是说，我们需要在Service的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。</p><h2 id="Service的基本用法"><a href="#Service的基本用法" class="headerlink" title="Service的基本用法"></a>Service的基本用法</h2><h3 id="定义一个Service"><a href="#定义一个Service" class="headerlink" title="定义一个Service"></a>定义一个Service</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220916115158211.png" alt="image-20220916115158211"></p><ul><li>MyService：我们将类的名字定义为MyService</li><li>Exported：表示是否将这个Service暴露给外部其他程序访问</li><li>Enabled：表示是否启用这个Service</li></ul><p>创建好之后：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        TODO(<span class="string">&quot;Return the communication channel to the service.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，MyService继承自系统的Service类的。目前MyService中可以算是空空如也，但是有一个<code>onBind()</code>方法特别醒目。这个是Service唯一的抽象方法。后面会讲解<code>onBind</code>的使用，这里暂时不用它。</p><p>Service中同样有类似于Activity的生命周期方法，这里咱们先使用，后面会讲解Service的生命周期。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是Service最常用的三个方法，看名字也知道是什么意思，这里就不浪费时间了。</p><p>另外，每一个Service都需要在<code>AndroidManifest.xml</code>文件中注册才能生效（这也是四大组件的特点）。不过按照我上述的操作，直接右键New一个Service的话，AndroidStudio就会自动为我们注册，不用再手写，还是很方便的。</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">           android:<span class="attribute">name</span>=<span class="string">&quot;.MyService&quot;</span></span><br><span class="line">           android:<span class="attribute">enabled</span>=<span class="string">&quot;true&quot;</span></span><br><span class="line">           android:<span class="attribute">exported</span>=<span class="string">&quot;true&quot;</span>&gt;&lt;/service&gt;</span><br></pre></td></tr></table></figure><h3 id="启动和停止Service"><a href="#启动和停止Service" class="headerlink" title="启动和停止Service"></a>启动和停止Service</h3><p>下面是两个按钮触发Service</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.startServiceBtn.setOnClickListener &#123; </span><br><span class="line">           <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">           startService(intent)<span class="comment">//启动Service</span></span><br><span class="line">       &#125;</span><br><span class="line">binding.stopServiceBtn.setOnClickListener &#123; </span><br><span class="line">           <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">           stopService(intent)<span class="comment">//停止Service</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>可以看到在startServiceBtn按钮的点击事件里，我们构建了一个Intent对象，并调用<code>startService()</code>方法来启动MyService。在stopServiceBtn按钮的点击事件里，我们同样构建了一个Intent对象，并调用<code>stopService()</code>方法来停止MyService。<code>startService()</code>和<code>stopService()</code>方法都是定义在<code>Context</code>类中的，所以我们在Activity里可以直接调用这两个方法。另外，Service也可以自我停止运行，只需要在Service内调用<code>stopself()</code>方法即可。</p><blockquote><p>从Android8.0之后，应用的后台功能被大幅削减。现在只有当应用保持在前台可见状态的情况下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时可能被系统回收。这样改动，是为了防止许多恶意的应用程序长期在后台占用手机资源，从而导致手机变得越来越卡。</p></blockquote><p><strong>那么，onCreate()和onStartCommand()方法的区别是什么呢？</strong></p><ul><li>onCreate()方法是在Service第一次创建的时候调用</li><li>而onStartCommand()方法则在每次启动Service的时候都会调用</li></ul><h3 id="Activity和Service进行通信"><a href="#Activity和Service进行通信" class="headerlink" title="Activity和Service进行通信"></a>Activity和Service进行通信</h3><p>通过上述的例子，我们可以知道Activity只是起到启动Service的作用，启动完之后，二者就基本没有关系了。</p><p>那如果我们想Activity与Service有关系，或者说Activity能控制Service，能交互，又该怎么办呢？那就要用到前面被搁置的<code>onBind()</code>。</p><p>我们在MyService中模拟提供下载功能，然后在Activity中可以决定何时开始下载，以及随时查看下载进度。实现这个功能的思路是创建一个专门的Binder对象来对下载功能进行管理。修改MyService中的代码。如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> : <span class="type">Binder</span></span>()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownloader</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;startDownload executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;getProgress executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，我们新建了一个DownloadBinder类，并让它继承自Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法。</p><p>接着，在MyService中创建了DownloadBinder的实例，然后再onBinder()方法里返回了这个实例，这样MyService中准备的工作就完成了。</p></blockquote><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> downloadBinder:MyService.DownloadBinder</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> connection = <span class="keyword">object</span> :ServiceConnection&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceConnected</span><span class="params">(name: <span class="type">ComponentName</span>?, service: <span class="type">IBinder</span>?)</span></span> &#123;</span><br><span class="line">        downloadBinder = service <span class="keyword">as</span> MyService.DownloadBinder</span><br><span class="line">        downloadBinder.startDownloader()</span><br><span class="line">        downloadBinder.getProgress()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onServiceDisconnected</span><span class="params">(name: <span class="type">ComponentName</span>?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">    setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">    binding.bindServiceBtn.setOnClickListener &#123; </span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MyService::<span class="keyword">class</span>.java)</span><br><span class="line">        bindService(intent,connection,Context.BIND_AUTO_CREATE)<span class="comment">//绑定Service</span></span><br><span class="line">    &#125;</span><br><span class="line">    binding.unbindServiceBtn.setOnClickListener &#123; </span><br><span class="line">        unbindService(connection)<span class="comment">//解绑Service</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>首先，我们创建了一个<code>ServiceConnection</code>的匿名内部类实现，并在里面重写了<code>onServiceConnected()</code>方法和<code>onServiceDisconnected()</code>方法</p><ul><li>onServiceConnected()：会在Activity与Service成功绑定的时候调用</li><li>onServiceDisconnected()：只有在Service的创建进程崩溃或被杀掉的时候才会调用，这个方法不太常用</li></ul><p>在<code>onServiceConnected()</code>方法中，我们通过向下转型得到了DownloadBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。</p></li><li><p>当然，需要真正的绑定还需要<code>bindService()</code>，需要三个参数：</p><ul><li>Intent对象</li><li>ServiceConnection实例，已经创建</li><li>一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service进行绑定后自动创建Service。这会使得MyServicede onCreate()方法得到执行，但onStartCommand()方法不会执行。</li></ul></li></ul></blockquote><h2 id="Service的生命周期"><a href="#Service的生命周期" class="headerlink" title="Service的生命周期"></a>Service的生命周期</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220916163946370.png" alt="image-20220916163946370"></p><blockquote><p>一旦在项目中的任何位置调用了Context的startService()方法，相应的Service就会启动，并回调onStartCommand()方法。如果这个Service之前还没有创建过，onCreate()方法会先于onStartCommand()方法执行。Service启动之后会一直保持运行状态，直到stopService()或stopself()方法被调用，或者被系统回收。注意，虽然每调用一次startService()方法，onStartCommaned()就会执行一次，但实际上每个Service只会保存一个实例。虽然不管你调用了多少次startService()方法，只需调用一次stopService()或stopself()方法，Service就会停止。</p><p>另外，还可以调用Context的bindService()来获取一个Service的持久连接，这时就会回调Service中的onBind()方法。类似地，如果这个Service之前还没有创建过，onCreate()方法会先于onBind()方法执行。之后，调用方可以获取到onBind()方法里返回地IBinder对象的实例，这样就能自由地和Service进行通信了。只要调用方和Service之间的连接没有断开，Service就会一直保持运行状态，直到被系统回收。</p><p>当调用了startService()方法后，再去调用stopService()方法。这时，Service中的onDestroy()方法就会执行，表示Service已经销毁。类似的，当调用了bindService()方法后，再去调用unbindService()方法，onDestroy()方法也会执行，这两种情况都很好理解。但是需要注意，我们是完全有可能对一个Service既调用了startService()又调用了bindService()方法，在这种情况下该如何让Service销毁呢？根据Android系统的机制，一个Service只要被启动或绑定了之后，就会处于运行状态，必须要让以上两种条件同时不满足，Service才能被销毁。所以，这种情况下要同时调用stopService()和unbindService()方法，onDestroy()方法才会执行。</p></blockquote><h2 id="前台Service"><a href="#前台Service" class="headerlink" title="前台Service"></a>前台Service</h2><blockquote><p>前面说过，Android8.0以后，只有当应用保持在前台可见状态下，Service才能保证稳定运行，一旦应用进入后台之后，Service随时都有可能被系统回收。而你如果希望Service能够一直保持运行状态，就可以考虑使用前台Service。前台Service与后台Service最大的区别就在于，它一直会有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。比如你的音乐、导航都用到了前台Service。</p></blockquote><p>由于状态栏一直有一个正在运行的图标，相当于我们的应用以另外一种形式保持在前台可见状态，所以系统不会倾向于回收前台Service。另外，用户也可以通过下拉状态栏清楚地直到当前什么应用正在运行，因此也不存在某些应用长期在后台偷偷占用手机资源的情况。</p><p>下面来看一下如何创建前台Service。</p><p>首先，需要在<code>AndroidManifest.xml</code>中加入权限</p><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">&lt;uses-permission android:<span class="attribute">name</span>=<span class="string">&quot;android.permission.FOREGROUND_SERVICE&quot;</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyService</span> : <span class="type">Service</span></span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> mBinder = DownloadBinder();</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadBinder</span> : <span class="type">Binder</span></span>()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">startDownloader</span><span class="params">()</span></span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;startDownload executed&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getProgress</span><span class="params">()</span></span>:<span class="built_in">Int</span>&#123;</span><br><span class="line">            Log.d(<span class="string">&quot;MyService&quot;</span>,<span class="string">&quot;getProgress executed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBind</span><span class="params">(intent: <span class="type">Intent</span>)</span></span>: IBinder &#123;</span><br><span class="line">        <span class="keyword">return</span> mBinder</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate()</span><br><span class="line">        <span class="keyword">val</span> manager = getSystemService(Context.NOTIFICATION_SERVICE) <span class="keyword">as</span> NotificationManager</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class="line">            <span class="keyword">val</span> channel = NotificationChannel(<span class="string">&quot;my_service&quot;</span>,<span class="string">&quot;前台Service通知&quot;</span>,NotificationManager.IMPORTANCE_DEFAULT)</span><br><span class="line">            manager.createNotificationChannel(channel)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>,MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line">        <span class="keyword">val</span> pi = PendingIntent.getActivity(<span class="keyword">this</span>,<span class="number">0</span>,intent,<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">val</span> notification = NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">&quot;my_service&quot;</span>)</span><br><span class="line">            .setContentTitle(<span class="string">&quot;This is content title&quot;</span>)</span><br><span class="line">            .setContentText(<span class="string">&quot;This is content text&quot;</span>)</span><br><span class="line">            .setSmallIcon(R.drawable.ic_launcher_foreground)</span><br><span class="line">            .setLargeIcon(BitmapFactory.decodeResource(resources, androidx.loader.R.drawable.notification_bg))</span><br><span class="line">            .setContentIntent(pi)</span><br><span class="line">            .build()</span><br><span class="line">        startForeground(<span class="number">1</span>,notification)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStartCommand</span><span class="params">(intent: <span class="type">Intent</span>?, flags: <span class="type">Int</span>, startId: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，这里只是修改了onCreate()方法中的代码，相信大家对这部分代码都比较熟悉——没错，就是创建通知（后续，小编会加一章关于通知的文章）。</p><ul><li>创建通知渠道<code>channel</code></li><li><code>PendingIntent</code>用于让通知实现可点击进入应用</li><li>然后是通知的创建<code>notification</code></li></ul><p>调用startForeground()方法，两个参数：</p><ul><li>通知的id</li><li>构建的Notification对象</li></ul></blockquote><p>看一下效果：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_09_16_17_53_49_838.gif" alt="录制_2022_09_16_17_53_49_838"></p><h2 id="使用IntentService"><a href="#使用IntentService" class="headerlink" title="使用IntentService"></a>使用IntentService</h2><p>Service中的代码都是默认运行在主线程，如果直接在Service里处理一些耗时任务，同样很容易出现ANR。</p><p>解决方法是开启一个子线程，并且还要记得线程执行完后主动<code>stopself()</code>或调用<code>stopService()</code>。</p><p><strong>是不是很麻烦？！</strong>因为程序要很可能会忘记开线程，或者忘记调用<code>stopself()</code>。</p><p>这个时候，我们的主角IntentService就诞生了！！！一个集Service、HandlerThread、Handler一身的“天才”（感兴趣的读者可以查一下它的原理，或者如果有需要可以联系小编出一期关于Handler和HandlerThread的文章，小编可以尝试聊聊它们的原理）</p><p>使用那就很简单了，不然我们怎么会用它呢，直接上代码：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyIntentService</span> : <span class="type">IntentService</span></span>(<span class="string">&quot;MyIntentService&quot;</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onHandleIntent</span><span class="params">(intent: <span class="type">Intent</span>?)</span></span> &#123;</span><br><span class="line">        <span class="comment">//用于处理耗时任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建方式也是与Service一样，可以右键直接new一个，亦或创建个类继承IntentService，同样的使用后者这种方式别忘了注册。</p><p>这里就不介绍使用了，因为IntentService和Service的使用一摸一样，而且大家分别打印Activity和IntentService中的当前线程<code>Thread.currentThread().name</code>就会发现，IntentService自动为我们完成了线程切换，当然，这一切还是归功于Handler。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前段时间，小编在修改bug的时候和Service打了不少交道。突然发现，已经很久没碰过Service了，有些东西记</summary>
      
    
    
    
    <category term="Android随笔" scheme="https://gun-ctrl.github.io/categories/Android%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="Service总结" scheme="https://gun-ctrl.github.io/tags/Service%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Android性能优化：APK瘦身</title>
    <link href="https://gun-ctrl.github.io/2022/09/15/apk%E7%98%A6%E8%BA%AB/"/>
    <id>https://gun-ctrl.github.io/2022/09/15/apk%E7%98%A6%E8%BA%AB/</id>
    <published>2022-09-15T09:19:59.025Z</published>
    <updated>2022-09-15T10:04:54.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>随着业务迭代，APK体积逐渐变大。项目中积累的无用资源，未压缩的图片资源等，都为apk带来了不必要的体积增加，而APK的大小会影响应用加载速度、使用的内存量以及消耗的电量。</p></blockquote><h2 id="了解APK结构"><a href="#了解APK结构" class="headerlink" title="了解APK结构"></a>了解APK结构</h2><p>在讨论如何缩减应用的大小之前，有必要了解下应用APK的结构。APK文件由一个Zip压缩文件组成，其中包含构成应用的所有文件，这些文件包括Java类文件、资源文件和包含已编译资源的文件。</p><p>APK包含以下目录：</p><ul><li><p><code>META-INF/</code>：包含<code>CERT.SF</code>和<code>CERT.RSA</code>签名文件，以及<code>MANIFEST.MF</code>清单文件。</p></li><li><p><code>assets/</code>：包含应用的资源；应用可以使用AssetManager对象检索这些资源。</p></li><li><p><code>res/</code>：包含未编译到<code>resources.arsc</code>中的资源（图片、音视频等）。</p></li><li><p><code>lib/</code>：包含特定于处理器软件层的已编译代码。此目录包含每种平台类型的子目录，如<code>armeabi、armeabi-v7a、arm64-v8a、x86、x86_64</code>和<code>mips</code>。</p></li></ul><p>APK还包含以下文件。在这些文件中，只有AndroidMainfest.xml是必须的。</p><ul><li><p><code>resources.arsc</code>：包含已编译的资源。此文件包含<code>res/values/</code> 文件夹的所有配置中的XML内容、打包工具会提取此XML内容，将其编译为二进制文件格式，并压缩内容、此内容包括语言字符串和格式，以及为直接包括在<code>resources.arsc</code>文件中的内容（例如布局文件和图片）的路径。</p></li><li><p><code>classes.dex</code>：包含以Dalvik&#x2F;ART虚拟机可理解的DEX文件格式编译的类。</p></li><li><p><code>AndroidManifest.xml</code>：包括核心Android清单文件、此文件列出了应用的名称、版本、访问权限和引用的库文件。该文件使用Android的二进制XML格式。</p></li></ul><h2 id="Android-Size-Analyzer（已弃用）"><a href="#Android-Size-Analyzer（已弃用）" class="headerlink" title="Android Size Analyzer（已弃用）"></a>Android Size Analyzer（已弃用）</h2><p>虽然已弃用，不过其提供的缩减策略还是很值得学习的,其实也就是后续介绍的一些方法。</p><p>Android Size Analyzer 工具可轻松地发现和实施多种缩减应用发小的策略。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172318943.png" alt="image-20220915172318943"></p><p>首先在 Android Studio中的插件市场下载安装Android Size Analyzer插件。安装插件后，从菜单栏中依次选择Analyze &gt; Analyze App Size，对当前项目运行应用大小分析。分析了项目后，系统会显示一个工具窗口，其中包含有关如何缩减应用大小的建议。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172348018.png" alt="image-20220915172348018"></p><p>如image转webp的建议</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172447629.png" alt="image-20220915172447629"></p><p>也可以用以下方式转webp</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172459940.png" alt="image-20220915172459940"></p><h2 id="移除未使用资源"><a href="#移除未使用资源" class="headerlink" title="移除未使用资源"></a>移除未使用资源</h2><p>APK瘦身关键就在一个字：删！没用的就删了。</p><h3 id="启用资源缩减"><a href="#启用资源缩减" class="headerlink" title="启用资源缩减"></a>启用资源缩减</h3><p>如果在应用的build.gradle文件中启用了资源缩减：shrinkResources，则Gradle在打包APK时可以自动忽略未使用资源。资源缩减只有在与代码缩减：minifyEnabled配合使用时才能发挥作用。在代码缩减器移除所有不使用的代码后，资源缩减器便可确定应用仍要使用的资源，从而在打包时优化这些资源。</p><p>优化后，并没有将不用的资源文件删除掉，而是将文件内容给优化掉。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172611565.png" alt="image-20220915172611565"></p><p><strong>注意</strong>：开启优化，混淆也在其中，也就是说混淆也会被开启，那么就需要注意一些不能被混淆的资源，比如一些三方库的包</p><p><strong>添加keep：</strong></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172644031.png" alt="image-20220915172644031"></p><p>也可以使用@Keep修饰不混淆的类——哪里不对@Keep哪里</p><h4 id="混淆规则"><a href="#混淆规则" class="headerlink" title="混淆规则"></a>混淆规则</h4><ul><li><p>jni方法不可混淆，因为需要与native方法保持一致；</p></li><li><p>反射用到的类不能混淆（否则反射可能出现问题）；</p></li><li><p>AndroidMainfest中的类不混淆，四大组件和Application的子类和FrameWork层下所有的类默认不会进行混淆；</p></li><li><p>Parceable的子类和Creator静态成员变量不混淆，否则产生Android.os.BadParceableException异常；</p></li><li><p>使用GSON、fastjson等框架时，所写的JSON对象类不混淆，否则无法将JSON解析成对应的对象；</p></li><li><p>使用第三方开源库或者引用其他第三方的SDK包时，需要在混淆文件中加入对应的混淆规则；</p></li><li><p>有用到WebView的JS调用也需要保证写的接口方法不混淆；</p></li><li><p>使用enum类型时需要注意避免以下两个方法混淆，因为enum类的特殊性，以下两个方法会被反射调用</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915172907262.png" alt="image-20220915172907262"></p></li></ul><h4 id="关于混淆的语法"><a href="#关于混淆的语法" class="headerlink" title="关于混淆的语法"></a>关于混淆的语法</h4><p><strong>Proguard关键字：</strong></p><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>keep</td><td>保留类和类中的成员，防止被混淆或移除</td></tr><tr><td>keepnames</td><td>保留类和类中的成员，防止被混淆，成员没有被引用会被移除</td></tr><tr><td>keepclassmembers</td><td>只保留类中的成员，防止被混淆或移除</td></tr><tr><td>keepclassmembernames</td><td>只保留类中的成员，防止被混淆，成员没有被引用会被移除</td></tr><tr><td>keepclasseswithmembers</td><td>保留类和类中的成员，防止被混淆或移除，保留指名的成员</td></tr><tr><td>keepclasseswithmembernames</td><td>保留类和类中的成员，防止被混淆，保留指名的成员，成员没有引用会被移除</td></tr></tbody></table><p><strong>Proguard通配符</strong></p><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><field></td><td>匹配类中的所有字段</td></tr><tr><td><method></td><td>匹配类中的所有方法</td></tr><tr><td><init></td><td>匹配类中的所有构造函数</td></tr><tr><td>*</td><td>匹配任意长度字符，不包含包名分隔符”.”</td></tr><tr><td>**</td><td>匹配任意长度字符，包含包名分隔符”.”</td></tr><tr><td>***</td><td>匹配任意参数类型</td></tr></tbody></table><blockquote><p><strong>如果既想保持类名，又想保持里面的内容不被混淆，使用：</strong></p><p>-keep class com.XX.test.* {*;}</p><p><strong>在此基础上，我们也可以使用Java的基本规则来保护特定类不被混淆，比如我们可以用extends，implements等这些Java规则。如下例子就避免所有继承Activity的类被混淆</strong></p><p>-keep public class * extends android.app.Activity</p><p> <strong>如果我们要保留一个类中的内部类不被混淆则需要用$符号，如下例子表示保持XxFragment内部类JavaScriptInterface中的所有public内容不被混淆。</strong></p><p>-keepclassmembers class com.XX.ui.fragment.XxFragment$JavaScriptInterface {</p><p>  public *;</p><p>}</p><p><strong>如果一个类中你不希望保持全部内容不被混淆，而只是希望保护类下的特定内容，可以使用</strong></p><p><init>;   &#x2F;&#x2F;匹配所有构造器</p><p><fields>;  &#x2F;&#x2F;匹配所有域</p><p><methods>;  &#x2F;&#x2F;匹配所有方法方法</p><p><strong>还可以在<fields>或<methods>前面加上private 、public、</strong><a href="https://so.csdn.net/so/search?q=native&spm=1001.2101.3001.7020"><strong>native</strong></a><strong>等来进一步指定不被混淆的内容，比如下面代码，表示名为Demo的类下的所有Public方法都不会被混淆</strong></p><p>-keep class com.XX.test.Demo {</p><p>  public <methods>;</p><p>}</p><p><strong>比如下面代码表示用JSONObject作为入参的构造函数不会被混淆</strong></p><p>-keep class com.XX.test.Demo {</p><p>  public <init>(org.json.JSONObject);</p><p>}</p><p><strong>5分钟快速完成混淆配置：</strong></p><p><a href="https://blog.csdn.net/qq_34317125/article/details/81127744"><strong>https://blog.csdn.net/qq_34317125&#x2F;article&#x2F;details&#x2F;81127744</strong></a></p></blockquote><h3 id="使用Lint分析器（物理删除）"><a href="#使用Lint分析器（物理删除）" class="headerlink" title="使用Lint分析器（物理删除）"></a>使用Lint分析器（物理删除）</h3><p>lint工具是Android Studio中附带的静态代码分析器，可检测到res&#x2F;文件夹中未被代码引用的资源。</p><p>从菜单栏中依次选择Analyze &gt; Run Inspection By Name</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173612451.png" alt="image-20220915173612451"></p><p>分析完成后会出现以下弹窗</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173625037.png" alt="image-20220915173625037"></p><p><strong>注意</strong>：lint工具不会扫描assets&#x2F;文件夹、通过反射引用的资源或已链接至应用的库文件。此外，它也不会移除资源，只会提醒您它们的存在。与资源缩减不同，这里点击删除，那就是把文件删了。所以，使用lint时谨慎删除文件，最好不要使用Remove All Unused Resources。</p><blockquote><p>反射引用资源：getResources().getIdentifier(“layout_main”,”layout”,getPackageName());</p></blockquote><h3 id="自定义要保留的资源"><a href="#自定义要保留的资源" class="headerlink" title="自定义要保留的资源"></a>自定义要保留的资源</h3><p>如果有想要特别声明需要保留或舍弃的特定资源，在项目中创建一个包含<resources>标记的XML文件，并在tools:keep属性中指定每个要保留的资源，在tools:discard属性中指定每个要舍弃的资源。这两个属性都接受以逗号分隔的资源名称列表。还可以将星号字符用作通配符。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173716035.png" alt="image-20220915173716035"></p><p>将该文件保存在项目资源中，例如，保存在res&#x2F;raw&#x2F;keep.xml中。构建系统不会将此文件打包到APK中。</p><h3 id="一键删除无用资源"><a href="#一键删除无用资源" class="headerlink" title="一键删除无用资源"></a>一键删除无用资源</h3><p>Android Studio给我们提供了一键移除所有无用的资源。从菜单栏中依次选择Refactor &gt; Remove UnusedResources，但是这种方式不建议使用，因为如果某资源仅存在动态获取资源id的方式，那么这个资源会被认为没有使用过，从而会直接被删除。</p><h3 id="移除未使用的备用资源"><a href="#移除未使用的备用资源" class="headerlink" title="移除未使用的备用资源"></a>移除未使用的备用资源</h3><p>Gradle资源缩减器只会移除未由应用代码引用的资源，这意味着，它不会移除用于不同设备配置的备用资源。可以使用Android Gradle插件的resConfigs属性移除应用不需要的备用资源文件。</p><p>例如，如果使用的是包含语言资源的库（如AppCompat），那么APK中将包含这些库中所有已翻译语言的字符串。如果只想保留应用正式支持的语言，则可以使用resConfig属性指定这些语言。系统会移除未指定语言的所有资源。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173818290.png" alt="image-20220915173818290"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915173833863.png" alt="image-20220915173833863"></p><p>配置resConfigs只打包默认与简体中文资源。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps1.jpg" alt="img"></p><h2 id="动态打包配置"><a href="#动态打包配置" class="headerlink" title="动态打包配置"></a>动态打包配置</h2><p>so文件是由ndk编译出来的动态库，是c&#x2F;c++写的，所以不是跨平台的。ABI是应用程序二进制接口简称（Application Binary Interface），定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android系统中，每一个CPU架构对应一个ABI，目前支持的有：armeabi-v7a，arm64- v8a，x86，x86_64。目前市面上手机设备基本上都是arm架构，armeabi-v7a几乎能兼容所有设备。因此可以配置：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps2.jpg" alt="img"></p><p>对于第三方服务，如百度地图、Bugly等会提供全平台的cpu架构。进行了上面的配置之后，表示只会把armeabiv7a打包进入Apk。从而减少APK大小。</p><p>对于arm64架构的设备，如果使用armeabi-v7a也能够兼容，但是不如使用arm64的so性能。因此现在部分应用市场会根据设备提供不同架构的Apk安装。此时我们需要打包出针对arm64的apk与armv7a的apk，可以使用productFlavor。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps3.jpg" alt="img"> </p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220915174015302.png" alt="image-20220915174015302"> </p><p>也可以使用：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps5.jpg" alt="img"> </p><h2 id="使用矢量图与webp"><a href="#使用矢量图与webp" class="headerlink" title="使用矢量图与webp"></a>使用矢量图与webp</h2><p>Apk中图片应该算是占用空间最多的资源。我们可以使用webp减少png、jpg图片占用空间的大小。对于小图标也可以使用矢量图。</p><p><img src="C:\Users\15786\AppData\Local\Temp\ksohtml20268\wps6.jpg" alt="img"> </p><p>矢量图可以创建与分辨率无关的图标和其他可伸缩媒体。使用这些图形可以极大地减少APK占用的空间。矢量图片在Android中以VectorDrawable对象的形式表示。借助VectorDrawable对象，100字节的文件可以生成与屏幕大小相同的清晰图片</p><p>不过，系统渲染每个VectorDrawable对象需要花费大量时间，而较大的图片则需要更长的时间才能显示在屏幕上。因此，建议仅在显示小图片时使用这些矢量图。</p><blockquote><p>新工程默认Icon就是矢量图</p></blockquote><h3 id="重复使用资源"><a href="#重复使用资源" class="headerlink" title="重复使用资源"></a>重复使用资源</h3><p>现在我们有一个矢量图：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps7.jpg" alt="img"> </p><p>它的显示效果：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps8.jpg" alt="img"> </p><p>如果我们需要让矢量图显示红色怎么办？这种情况，我们不需要再去创建一个新的矢量图。可以直接给ImageView设置android:tint属性来完成颜色的修改。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps9.jpg" alt="img"> </p><p>如果需要让矢量图实现触摸变色。只需要创建selector，设置给tint即可</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps10.jpg" alt="img"> </p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/wps10.jpg" alt="img"> </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p>主动移除无用代码（开启R8&#x2F;Progurad自动移除）</p></li><li><p>避免使用枚举，使用@IntDef代替</p></li><li><p>开启资源混淆：<a href="https://gitee.com/ahr6e170zl/AndResGuard?_from=gitee_search%E6%88%96https://github.com/shwenzhang/AndResGuard">https://gitee.com/ahr6e170zl/AndResGuard?_from=gitee_search或https://github.com/shwenzhang/AndResGuard</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;随着业务迭代，APK体积逐渐变大。项目中积累的无用资源，未压缩的图片资源等，都为apk带来了不必要的体积增加，而A</summary>
      
    
    
    
    <category term="性能优化" scheme="https://gun-ctrl.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>Android运行时权限</title>
    <link href="https://gun-ctrl.github.io/2022/09/13/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90/"/>
    <id>https://gun-ctrl.github.io/2022/09/13/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90/</id>
    <published>2022-09-13T08:39:01.540Z</published>
    <updated>2022-09-13T10:44:44.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>我们在应用开发中如果需要联网就需要在<code>AndroidManifest.xml</code>文件中添加网络访问权限。在我们新安装应用时，往往会弹出提示框问我们是否允许系统获取定位、读取联系人、读取短信等权限。那这些权限有什么用？区别是什么？为什么会有运行时权限这一说法……下面让小编来一一梳理并解答。</p><h2 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a>运行时权限</h2><blockquote><p> Android的权限机制并不是什么新鲜事物，从系统的第一个版本开始就已经存在了。但其实之前Android的权限机制在保护安全和隐私等方面起到的作用十分有限，尤其是一些大家离不开的常用软件，非常容易“店大欺客”。为此，Android开发团队在Android6.0系统中引入了运行时权限这个功能，从而更好地保护了用户的安全和隐私。</p></blockquote><h2 id="Android权限机制详解"><a href="#Android权限机制详解" class="headerlink" title="Android权限机制详解"></a>Android权限机制详解</h2><p>如下，监听开机广播需要开启广播接收的权限：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220913165504245.png" alt="image-20220913165504245"></p><p>因为监听开机广播涉及了用户设备的安全，因此必须在<code>AndroidManifest.xml</code>文件中加入权限声明，否则我们的程序就会崩溃。</p><p>那么问题来了，加入了这句权限声明后，对于用户来说到底有什么影响呢？为什么这样就可以保护设备的安全了呢？</p><p>其实用户主要在两方面得到保护。一方面，如果用户在低于Android6.0系统的设备商安装该程序，会在安装界面弹出一连串提示。这样用户就可以知晓该程序一共申请了哪些权限，从而决定是否安装这个程序。另一方面，用户可以随时在应用程序管理界面查看任意一个程序的权限申请情况。这样该程序申请的权限就尽收眼底，什么都瞒不过用户，以此保证应用程序不会出现滥用权限的情况。</p><p>但是，很多时候我们离不开的常用软件普遍存在滥用权限的情况，不管到底有没有用得到，反正先申请了再说。</p><blockquote><p>考虑到上述问题，Android6.0以后加入了动态申请权限功能。但是，如果安装一个应用需要不停地授权很多权限，就很繁琐，用户体验极差。那么就将权限进行了划分——普通权限与危险权限。普通权限会默认开启，而危险权限需要用户进行授权。</p></blockquote><h2 id="危险权限"><a href="#危险权限" class="headerlink" title="危险权限"></a>危险权限</h2><p>下面列出Android危险权限，除了这些剩余的都是普通权限。</p><table><thead><tr><th>权限组名</th><th>权限名</th></tr></thead><tbody><tr><td>CALENDAR（日历）</td><td>READ_CALENDAR、WRITE_CALENDAR</td></tr><tr><td>CAMERA（相机）</td><td>CAMERA、READ_CONTACTS</td></tr><tr><td>CONTACTS（联系人）</td><td>WRITE_CONTACTS、GET_ACCOUNTS</td></tr><tr><td>LOCATION（位置）</td><td>ACCESS_FINE_LOCATION、ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE（麦克风）</td><td>RECORD_AUDIO、 READ_PHONE_STATE、CALL_PHONE、ERAD_CALL_LOG</td></tr><tr><td>PHONE（手机）</td><td>WRITE_CALL_LOG、ADD_VOICEMAIL、USE_SIP、PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS（传感器）</td><td>BODY_SENSORS、 SEND_SMS、RECEIVE_SMS</td></tr><tr><td>SMS（短信）</td><td>READ_SMS、RECEIVE_WAP_PUSH、RECEIVE_MMS</td></tr><tr><td>STORAGE（存储卡）</td><td>READ_EXTERNAL_STORAGE、WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><p>这张表看起来不怎么轻松，因为里面的权限不都是能接触到的。不过没有关系，你不需要了解表格中每个权限的作用，只需要把它当成一个参照表来看就行了。每当需要使用一个权限时，可以查表，如果该权限出现在这张表中，那么就需要动态申请权限。</p><p>另外注意，表格中每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名。原则上，用户一旦同意了某个权限申请之后，同组的其它权限都会被系统自动开启。</p><p><strong>特别注意</strong>：不要基于此规则来实现任何逻辑，因为Android系统随时有可能调整权限的分组。</p><h2 id="在程序运行时申请权限"><a href="#在程序运行时申请权限" class="headerlink" title="在程序运行时申请权限"></a>在程序运行时申请权限</h2><p><strong>运行效果</strong></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_09_13_17_51_50_995.gif" alt="录制_2022_09_13_17_51_50_995"></p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="type">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding:ActivityMainBinding;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">        setContentView(binding.root)</span><br><span class="line">        binding.Call.setOnClickListener &#123;</span><br><span class="line">            <span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>,Manifest.permission.CALL_PHONE)</span><br><span class="line">            != PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                ActivityCompat.requestPermissions(</span><br><span class="line">                    <span class="keyword">this</span>,</span><br><span class="line">                    arrayOf(Manifest.permission.CALL_PHONE)</span><br><span class="line">                , REQUEST_CODE)</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                call()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        permissions: <span class="type">Array</span>&lt;<span class="type">out</span> <span class="type">String</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">        grantResults: <span class="type">IntArray</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults)</span><br><span class="line">        <span class="keyword">when</span>(requestCode)&#123;</span><br><span class="line">            REQUEST_CODE -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (grantResults.isNotEmpty() &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED)&#123;</span><br><span class="line">                    call()</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Toast.makeText(<span class="keyword">this</span>,<span class="string">&quot;You denied the permission&quot;</span>,Toast.LENGTH_LONG).show()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">call</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> intent = Intent(Intent.ACTION_CALL)</span><br><span class="line">            intent.<span class="keyword">data</span> = Uri.parse(<span class="string">&quot;tel:10086&quot;</span>)</span><br><span class="line">            startActivity(intent)</span><br><span class="line">        &#125;<span class="keyword">catch</span> (e:SecurityException)&#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码覆盖了运行时权限的完整流程，下面我们来具体分析一下。</p><ul><li><p>第一步就是要先判断用户是不是已经给我们进行了授权，借助的是<code>ContextCompat.checkSelfPermission()</code>方法接收两个参数：</p><ul><li>Context</li><li>具体的权限名，比如打电话的权限名<code>Manifest.permission.CALL_PHONE</code></li></ul><p>然后我们使用方法的返回值与<code>PackageManager.PERMISSION_GRANTED</code>做比较，相等就说明用户已经授权，不等就表示用户没有权限。</p></li><li><p>如果已经授权了，直接执行拨打电话的逻辑就可以了，这里我们把拨打电话的逻辑封装到call()方法中。如果没有授权的话，则需要调用<code>ActivityCompat.requestPermissions()</code>方法向用户申请权限。<code>requestPermissions()</code>接收3个参数：</p><ul><li>第一个参数要求是Activity实例</li><li>第二个参数是String数组，我们把要申请的权限名放到数组中即可</li><li>第三个要求是请求码，只要是唯一值就可以</li></ul></li><li><p>调用完<code>requestPermissions()</code>方法之后，系统会弹出一个权限申请的对话框，用户可以选择同意我们的权限申请。无论是哪种结果，最终都会回调 <code>onRequestPermissionsResult()</code>方法中，而授权的结果则会封装在<code>grantResults</code>参数中。这里我们只需要判断一下最后的授权结果，如果用户同意的话，就调用call()方法拨打电话；如果用户拒绝的话，我们只能放弃操作，并且弹出一条失败的提示。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;我们在应用开发中如果需要联网就需要在&lt;code&gt;AndroidManifest.xml&lt;/code&gt;文件中添加网络访问权限。在我们新安装应用</summary>
      
    
    
    
    <category term="Android随笔" scheme="https://gun-ctrl.github.io/categories/Android%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="运行时权限" scheme="https://gun-ctrl.github.io/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>OOM与内存优化</title>
    <link href="https://gun-ctrl.github.io/2022/08/19/OOM%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/"/>
    <id>https://gun-ctrl.github.io/2022/08/19/OOM%E4%B8%8E%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/</id>
    <published>2022-08-19T06:51:33.540Z</published>
    <updated>2022-08-19T08:18:55.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存管理基础"><a href="#内存管理基础" class="headerlink" title="内存管理基础"></a>内存管理基础</h2><h3 id="App内存组成以及限制"><a href="#App内存组成以及限制" class="headerlink" title="App内存组成以及限制"></a>App内存组成以及限制</h3><p>Android 给每个 App 分配一个 VM ，让App运行在 dalvik 上，这样即使 App 崩溃也不会影响到系统。系统给 VM 分配了一定的内存大小， App 可以申请使用的内存大小不能超过此硬性逻辑限制，就算物理内存富余，如果应用超出 VM 最大内存，就会出现内存溢出 crash。</p><p>由程序控制操作的内存空间在 heap 上，分 java heapsize 和 native heapsize</p><ul><li>Java申请的内存在 vm heap 上，所以如果 java 申请的内存大小超过 VM 的逻辑内存限制,就会出现内存溢出的异常</li><li><strong>native层内存申请不受其限制</strong>, native 层受 native process 对内存大小的限制</li></ul><h3 id="如何查看Android设备对App的内存限制"><a href="#如何查看Android设备对App的内存限制" class="headerlink" title="如何查看Android设备对App的内存限制"></a>如何查看Android设备对App的内存限制</h3><ol><li>主要查看系统配置文件 build.prop ，我们可以通过 adb shell 在 命令行窗口查看</li></ol><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> <span class="built_in">cat</span> /system/build.prop</span></span><br></pre></td></tr></table></figure><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819150211884.png" alt="image-20220819150211884"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819150239269.png" alt="image-20220819150239269"></p><ol start="2"><li><p>通过代码获取</p><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">ActivityManager activityManager = (ActivityManager)<span class="built_in">context</span>.getSystemService(<span class="built_in">Context</span>.ACTIVITY_SERVICE) activityManager.getMemoryClass()<span class="comment">;//以m为单位</span></span><br></pre></td></tr></table></figure></li><li><p>可以修改</p><ul><li><p>修改 \frameworks\base\core\jni\AndroidRuntime.cpp</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AndroidRuntime::startVm</span><span class="params">(JavaVM** pJavaVM, JNIEnv** pEnv, <span class="type">bool</span> zygote)</span> </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    * The default starting and maximum size of the heap. Larger </span></span><br><span class="line"><span class="comment">    * values should be specified in a product property override.</span></span><br><span class="line"><span class="comment">    */</span>parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapstartsize&quot;</span>, heapstartsizeOptsBuf, <span class="string">&quot;-Xms&quot;</span>, <span class="string">&quot;4m&quot;</span>);                   parseRuntimeOption(<span class="string">&quot;dalvik.vm.heapsize&quot;</span>, heapsizeOptsBuf, <span class="string">&quot;-Xmx&quot;</span>, <span class="string">&quot;16m&quot;</span>);<span class="comment">//修改这里</span></span><br><span class="line">    * &#125;</span><br></pre></td></tr></table></figure></li><li><p>修改 platform&#x2F;dalvik&#x2F;+&#x2F;eclair-release&#x2F;vm&#x2F;Init.c</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gDvm.heapSizeStart = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Spec says 16MB; too big for us. </span></span><br><span class="line">gDvm.heapSizeMax = <span class="number">16</span> * <span class="number">1024</span> * <span class="number">1024</span>; <span class="comment">// Spec says 75% physical mem</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="内存指标概念"><a href="#内存指标概念" class="headerlink" title="内存指标概念"></a>内存指标概念</h3><table><thead><tr><th><strong>Item</strong></th><th><strong>全称</strong></th><th><strong>含义</strong></th><th><strong>等价</strong></th></tr></thead><tbody><tr><td>USS</td><td>Unique Set Size</td><td>物理内存</td><td>进程独占的内存</td></tr><tr><td>PSS</td><td>Proportional Set Size</td><td>物理内存</td><td>PSS&#x3D; USS+ 按比例包含共享库</td></tr><tr><td>RSS</td><td>Resident Set Size</td><td>物理内存</td><td>RSS&#x3D; USS+ 包含共享库</td></tr><tr><td>VSS</td><td>Virtual Set Size</td><td>虚拟内存</td><td>VSS&#x3D; RSS+ 未分配实际物理内存</td></tr></tbody></table><p>总结:VSS &gt;&#x3D; RSS &gt;&#x3D; PSS &gt;&#x3D; USS,但&#x2F;dev&#x2F;kgsl-3d0部份必须考虑VSS，一般我们只需要考虑PSS</p><h3 id="Android内存分配与回收机制"><a href="#Android内存分配与回收机制" class="headerlink" title="Android内存分配与回收机制"></a>Android内存分配与回收机制</h3><p>这部分内容小编已经在之前的章节介绍了</p><p>附上链接：<a href="http://banmaman.com/2022/08/13/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">JVM内存管理剖析</a></p><h3 id="Android低内存杀进程机制"><a href="#Android低内存杀进程机制" class="headerlink" title="Android低内存杀进程机制"></a>Android低内存杀进程机制</h3><p>Anroid基于进程中运行的组件及其状态规定了默认的五个回收优先级：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819151608768.png" alt="image-20220819151608768"></p><ul><li><p>Empty process(空进程)</p></li><li><p>Background process(后台进程)</p></li><li><p>Service process(服务进程)</p></li><li><p>Visible process(可见进程)</p></li><li><p>Foreground process(前台进程)</p></li></ul><blockquote><p>系统需要进行内存回收时最先回收空进程,然后是后台进程，以此类推最后才会回收前台进程（一般情况</p><p>下前台进程就是与用户交互的进程了,如果连前台进程都需要回收那么此时系统几乎不可用了）。</p></blockquote><p><code>ActivityManagerService</code> 会对所有进程进行评分（存放在变量adj中），然后再讲这个评分更新到内</p><p>核，由内核去完成真正的内存回收( lowmemorykiller , Oom_killer )。</p><h2 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM"></a>什么是OOM</h2><blockquote><p>OOM（OutOfMemoryError）内存溢出错误，在常见的Crash疑难排行榜上，OOM绝对可以名列前茅并且经久不衰。因为它发生时的Crash堆栈信息往往不是导致问题的根本原因，而只是压死骆驼的最后一根稻草</p></blockquote><h2 id="发生OOM的条件"><a href="#发生OOM的条件" class="headerlink" title="发生OOM的条件"></a>发生OOM的条件</h2><ul><li><p>Android 2.x系统 GC LOG中的dalvik allocated + external allocated + 新分配的大小 &gt;&#x3D;</p><p>getMemoryClass()值的时候就会发生OOM。 例如，假设有这么一段Dalvik输出的GC LOG：</p><p>GC_FOR_MALLOC free 2K, 13% free 32586K&#x2F;37455K, external 8989K&#x2F;10356K, paused 20ms，</p><p>那么32586+8989+(新分配23975)&#x3D;65550&gt;64M时，就会发生OOM。</p></li><li><p>Android 4.x系统 Android 4.x的系统废除了external的计数器，类似bitmap的分配改到dalvik的</p><p>java heap中申请，只要allocated + 新分配的内存 &gt;&#x3D; getMemoryClass()的时候就会发生OOM</p></li></ul><h2 id="OOM原因"><a href="#OOM原因" class="headerlink" title="OOM原因"></a>OOM原因</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819152424482.png" alt="image-20220819152424482"></p><p>对于应用开发来说，其实只需要关心上述第1、2点以及4即可。</p><h2 id="Android内存分析命令介绍"><a href="#Android内存分析命令介绍" class="headerlink" title="Android内存分析命令介绍"></a>Android内存分析命令介绍</h2><p>常用的内存调优分析命令：</p><ol><li>dumpsys meminfo</li><li>procrank</li><li>cat  &#x2F;proc&#x2F;meminfo</li><li>free</li><li>showmap</li><li>vmstat</li></ol><h3 id="dumpsys-meminfo"><a href="#dumpsys-meminfo" class="headerlink" title="dumpsys meminfo"></a>dumpsys meminfo</h3><p>命令：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> dumpsys meminfo [<span class="keyword">App</span>文件名]</span><br></pre></td></tr></table></figure><blockquote><p>通常可以通过比较Heap Size以及Objects数据的增加来判断发生了内存泄漏</p><p>操作方法：首先执行一次<code>dumpsys meminfo</code>，然后再App的各项Activity或者不同App之间跳转，最后再切回来，再执行一次<code>dumpsys meminfo</code>，比较数据变化。</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819154734084.png" alt="image-20220819154734084"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220819161522100.png" alt="image-20220819161522100"></p><p>虽然参数很多，但是我们主要关注Dalvik Heap与TOTAL这两行的内容即可。</p><p>相关参数的说明：</p><p>Pss Total：是一个进程实际使用的内存，该统计方法包括比例分配共享库占用的内存，即如果有三个进</p><p>程共享了一个共享库，则平摊分配该共享库占用的内存。Pss Total统计方法的一个需要注意的地方是如</p><p>果使用共享库的一个进程被杀死，则共享库的内存占用按比例分配到其他共享该库的进程中，而不是将</p><p>内存资源返回给系统，这种情况下PssTotal不能够准确代表内存返回给系统的情况。</p><p>Private Dirty：进程私有的脏页内存大小，该统计方法只包括进程私有的被修改的内存。</p><p>Private Clear：进程私有的干净页内存大小，该统计方法只包括进程私有的没有被修改的内存。</p><p>Swapped Dirty：被交换的脏页内存大小，该内存与其他进程共享。</p><p>其中private Dirty + private Clean &#x3D; Uss，该值是一个进程的使用的私有内存大小，即这些内存唯一被</p><p>该进程所有。该统计方法真正描述了运行一个进程需要的内存和杀死一个进程释放的内存情况，是怀疑</p><p>内存泄露最好的统计方法。</p><p>共享比例：sharing_proportion &#x3D; (Pss Total - private_clean - private_dirty) &#x2F; (shared_clean +</p><p>shared_dirty)</p><p>享学课堂能够被共享的内存：swappable_pss &#x3D; (sharing_proportion * shared_clean) + private_clean</p><p>Native Heap：本地堆使用的内存，包括C&#x2F;C++在堆上分配的内存</p><p><strong>Dalvik Heap：dalvik虚拟机使用的内存</strong></p><p>Dalvik other：除Dalvik和Native之外分配的内存，包括C&#x2F;C++分配的非堆内存</p><p>Cursor：数据库游标文件占用的内存</p><p>Ashmem：匿名共享内存</p><p>Stack：Dalvik栈占用的内存</p><p>Other dev：其他的dev占用的内存</p><p>.so mmap：so库占用的内存</p><p>.jar mmap：.jar文件占用的内存</p><p>.apk mmap：.apk文件占用的内存</p><p>.ttf mmap：.ttf文件占用的内存</p><p>.dex mmap：.dex文件占用的内存</p><p>image mmap：图像文件占用的内存</p><p>code mmap：代码文件占用的内存</p><p>Other mmap：其他文件占用的内存</p><p>Graphics：GPU使用图像时使用的内存</p><p>GL：GPU使用GL绘制时使用的内存</p><p>Memtrack：GPU使用多媒体、照相机时使用的内存</p><p>Unknown：不知道的内存消耗</p><p>Heap Size：堆的总内存大小</p><p>Heap Alloc：堆分配的内存大小</p><p>Heap Free：堆待分配的内存大小</p><p>Native Heap | Heap Size : 从mallinfo usmblks获的，当前进程Native堆的最大总共分配内存</p><p>Native Heap | Heap Alloc : 从mallinfo uorblks获的，当前进程navtive堆的总共分配内存 </p><p>Native Heap | Heap Free : 从mallinfo fordblks获的，当前进程Native堆的剩余内存</p><p>Native Heap Size ≈ Native Heap Alloc + Native Heap Free</p><p>mallinfo是一个C库，mallinfo()函数提供了各种各样通过malloc()函数分配的内存的统计信息。</p><p><strong>Dalvik Heap | Heap Size : 从Runtime totalMemory()获得，Dalvik Heap总共的内存大小</strong></p><p><strong>Dalvik Heap | Heap Alloc : 从Runtime totalMemory() - freeMemory()获得，Dalvik Heap分配的内存大小</strong></p><p><strong>Dalvik Heap | Heap Free : 从Runtime freeMemory()获得，Dalvik Heap剩余的内存大小</strong></p><p><strong>Dalvik Heap Size &#x3D; Dalvik Heap Alloc + Dalvik Heap Free</strong></p><p>Obejcts当前进程中的对象个数</p><p>Views:当前进程中实例化的视图View对象数量 </p><p>ViewRootImpl:当前进程中实例化的视图根ViewRootImpl对象数量</p><p>AppContexts:当前进程中实例化的应用上下文ContextImpl对象数量</p><p>Activities:当前进程中实例化的Activity对象数量</p><p>Assets:当前进程的全局资产数量</p><p>AssetManagers:当前进程的全局资产管理数量</p><p>Local Binders:当前进程有效的本地binder对象数量</p><p>Proxy Binders:当前进程中引用的远程binder对象数量</p><p>Death Recipients:当前进程到binder的无效链接数量</p><p>OpenSSL Sockets:安全套接字对象数量</p><h3 id="procrank"><a href="#procrank" class="headerlink" title="procrank"></a><strong>procrank</strong></h3><blockquote><p>功能： 获取所有进程的内存使用的排行榜，排行是以 Pss 的大小而排序。 procrank 命令比 dumpsys meminfo 命令，能输出更详细的VSS&#x2F;RSS&#x2F;PSS&#x2F;USS内存指标。</p></blockquote><h3 id="cat-x2F-proc-x2F-meminfo"><a href="#cat-x2F-proc-x2F-meminfo" class="headerlink" title="cat &#x2F;proc&#x2F;meminfo"></a><strong>cat &#x2F;proc&#x2F;meminfo</strong></h3><blockquote><p>功能：能否查看更加详细的内存信息</p></blockquote><p>指令：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> <span class="built_in">cat</span> /proc/meminfo</span></span><br></pre></td></tr></table></figure><p>输出结果如下(结果内存值不带小数点，此处添加小数点的目的是为了便于比对大小)：</p><figure class="highlight tcl"><table><tr><td class="code"><pre><span class="line">root@phone:/ # cat /<span class="keyword">proc</span>/meminfo<span class="title"> </span></span><br><span class="line"><span class="title">MemTotal:</span> 2857.032<span class="title"> kB</span> //RAM可用的总大小 (即物理总内存减去系统预留和内核二进 制代码大小)<span class="title"> </span></span><br><span class="line"><span class="title">MemFree:</span> 1020.708<span class="title"> kB</span> //RAM未使用的大小<span class="title"> </span></span><br><span class="line"><span class="title">Buffers:</span> 75.104<span class="title"> kB</span> //用于文件缓冲<span class="title"> </span></span><br><span class="line"><span class="title">Cached:</span> 448.244<span class="title"> kB</span> //用于高速缓存<span class="title"> </span></span><br><span class="line"><span class="title">SwapCached:</span> 0<span class="title"> kB</span> //用于swap缓存<span class="title"> </span></span><br><span class="line"><span class="title">Active:</span> 832.900<span class="title"> kB</span> //活跃使用状态，记录最近使用过的内存，通常不回收用于其它目的<span class="title"> </span></span><br><span class="line"><span class="title">Inactive:</span> 391.128<span class="title"> kB</span> //非活跃使用状态，记录最近并没有使用过的内存，能够被回 收用于其他目的<span class="title"> </span></span><br><span class="line"><span class="title">Active(anon):</span> 700.744<span class="title"> kB</span> //Active =<span class="title"> Active(anon)</span> +<span class="title"> Active(file)</span> <span class="title"></span></span><br><span class="line"><span class="title">Inactive(anon):</span> 228<span class="title"> kB</span> //Inactive =<span class="title"> Inactive(anon)</span> +<span class="title"> Inactive(file)</span> <span class="title"></span></span><br><span class="line"><span class="title">Active(file):</span> 132.156<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Inactive(file):</span> 390.900<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Unevictable:</span> 0<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Mlocked:</span> 0<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">SwapTotal:</span> 524.284<span class="title"> kB</span> //swap总大小<span class="title"> </span></span><br><span class="line"><span class="title">SwapFree:</span> 524.284<span class="title"> kB</span> //swap可用大小<span class="title"> </span></span><br><span class="line"><span class="title">Dirty:</span> 0<span class="title"> kB</span> //等待往磁盘回写的大小<span class="title"> </span></span><br><span class="line"><span class="title">Writeback:</span> 0<span class="title"> kB</span> //正在往磁盘回写的大小<span class="title"> </span></span><br><span class="line"><span class="title">AnonPages:</span> 700.700<span class="title"> kB</span> //匿名页，用户空间的页表，没有对应的文件<span class="title"> </span></span><br><span class="line"><span class="title">Mapped:</span> 187.096<span class="title"> kB</span> //文件通过mmap分配的内存，用于map设备、文件或者库<span class="title"> </span></span><br><span class="line"><span class="title">Shmem:</span> .312<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title">Slab:</span> 91.276<span class="title"> kB</span> //kernel数据结构的缓存大小，<span class="title"> </span></span><br><span class="line"><span class="title">Slab=SReclaimable+SUnreclaim</span> <span class="title"></span></span><br><span class="line"><span class="title">SReclaimable:</span> 32.484<span class="title"> kB</span> //可回收的slab的大小<span class="title"> </span></span><br><span class="line"><span class="title">SUnreclaim:</span> 58.792<span class="title"> kB</span> //不可回收slab的大小<span class="title"> </span></span><br><span class="line"><span class="title">KernelStack:</span> 25.024<span class="title"> kB</span> <span class="title"></span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">PageTables:</span> 23.752<span class="title"> kB</span> //以最低的页表级<span class="title"></span></span><br><span class="line"><span class="title">NFS_Unstable:</span> 0<span class="title"> kB</span> //不稳定页表的大小<span class="title"></span></span><br><span class="line"><span class="title">Bounce:</span> 0<span class="title"> kB</span></span><br><span class="line">WritebackTmp: 0<span class="title"> kB</span></span><br><span class="line">CommitLimit: 1952.800<span class="title"> kB</span></span><br><span class="line">Committed_AS: 82204.348<span class="title"> kB</span> //评估完成的工作量，代表最糟糕case下的值，该值也包含<span class="title"> swap内存</span></span><br><span class="line">VmallocTotal: 251658.176<span class="title"> kB</span> //总分配的虚拟地址空间<span class="title"></span></span><br><span class="line"><span class="title">VmallocUsed:</span> 166.648<span class="title"> kB</span> //已使用的虚拟地址空间<span class="title"></span></span><br><span class="line"><span class="title">VmallocChunk:</span> 251398.700<span class="title"> kB</span> //虚拟地址空间可用的最大连续内存块</span><br></pre></td></tr></table></figure><p>对于cache和buffer也是系统可以使用的内存。所以系统总的可用内存为 MemFree+Buffers+Cached</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a><strong>free</strong></h3><blockquote><p>主功能：查看可用内存，缺省单位KB。该命令比较简单、轻量，专注于查看剩余内存情况。数据来源于&#x2F;proc&#x2F;meminfo。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实小编使用过的就只有<code>dumpsys meminfo</code>与<code>cat /proc/meminfo</code>其他的实用情况不多</p><ol><li>dumpsys meminfo 适用场景： 查看进程的oom adj，或者dalvik&#x2F;native等区域内存情况，或者某</li></ol><p>   个进程或apk的内存情况，功能非常强大；</p><ol start="2"><li><p>procrank 适用场景： 查看进程的VSS&#x2F;RSS&#x2F;PSS&#x2F;USS各个内存指标；</p></li><li><p>cat &#x2F;proc&#x2F;meminfo 适用场景： 查看系统的详尽内存信息，包含内核情况；</p></li><li><p>free 适用场景： 只查看系统的可用内存；</p></li><li><p>showmap 适用场景： 查看进程的虚拟地址空间的内存分配情况；</p></li><li><p>vmstat 适用场景： 周期性地打印出进程运行队列、系统切换、CPU时间占比等情况；</p></li></ol><h2 id="Android内存泄漏分析工具"><a href="#Android内存泄漏分析工具" class="headerlink" title="Android内存泄漏分析工具"></a>Android内存泄漏分析工具</h2><h3 id="MAT"><a href="#MAT" class="headerlink" title="MAT"></a>MAT</h3><p>这个需要在官网下载</p><h3 id="Android-Studio-Memory-profiler"><a href="#Android-Studio-Memory-profiler" class="headerlink" title="Android Studio Memory-profiler"></a><strong>Android Studio Memory-profiler</strong></h3><p>就在Android Studio下方菜单栏中</p><p>具体用法可参考官网：</p><p><a href="https://developer.android.google.cn/studio/profile/memory-profiler#performance">https://developer.android.google.cn/studio/profile/memory-profiler#performance</a></p><h3 id="LeakCanary"><a href="#LeakCanary" class="headerlink" title="LeakCanary"></a><strong>LeakCanary</strong></h3><p>检测内存泄漏非常方便的工具</p><p>只需要导入，就可以在运行界面查看定位到的内存泄漏位置，以及依赖树</p><p><a href="https://github.com/square/leakcanary">https://github.com/square/leakcanary</a></p><h2 id="Android内存泄漏常见场景以及解决方案"><a href="#Android内存泄漏常见场景以及解决方案" class="headerlink" title="Android内存泄漏常见场景以及解决方案"></a>Android内存泄漏常见场景以及解决方案</h2><h3 id="1、资源性对象未关闭"><a href="#1、资源性对象未关闭" class="headerlink" title="1、资源性对象未关闭"></a>1、资源性对象未关闭</h3><p>对于资源性对象不再使用时，应该立即调用它的close()函数，将其关闭，然后再置为null。例如Bitmap等资源未关闭会造成内存泄漏，此时我们应该再Activity销毁时关闭。</p><h3 id="2、注册对象未销毁"><a href="#2、注册对象未销毁" class="headerlink" title="2、注册对象未销毁"></a>2、注册对象未销毁</h3><p>例如BroadcastReceiver、EventBus未注销造成的内存泄漏，我们应该在Activity销毁时及时注销。</p><h3 id="3、类的静态变量持有大数据对象"><a href="#3、类的静态变量持有大数据对象" class="headerlink" title="3、类的静态变量持有大数据对象"></a>3、类的静态变量持有大数据对象</h3><p>尽量避免使用静态变量存储数据，特别是大数据对象，建议使用数据库存储。</p><h3 id="4、单例造成的内存泄漏"><a href="#4、单例造成的内存泄漏" class="headerlink" title="4、单例造成的内存泄漏"></a>4、单例造成的内存泄漏</h3><p>优先使用Application的Context，如需使用Activity的Context，可以在传入Context时使用弱引用进行封装，然后，在使用到的地方从弱引用中获取Context，如果获取不到，则直接return即可。</p><h3 id="5、非静态内部类的静态实例"><a href="#5、非静态内部类的静态实例" class="headerlink" title="5、非静态内部类的静态实例"></a>5、非静态内部类的静态实例</h3><p>该实例的生命周期和应用一样长，这就导致该静态实例一直持有该Activity的引用，Activity的内存资源不能正常回收。此时，我们可以将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，尽量使用Application Context，如果需要使用Activity Context，就记得用完后置空让GC可以回收，否则还是会内存泄漏。</p><h3 id="Handler临时性内存泄漏"><a href="#Handler临时性内存泄漏" class="headerlink" title="Handler临时性内存泄漏"></a>Handler临时性内存泄漏</h3><p>Message发出之后存储在MessageQueue中，在Message中存在一个target，它是Handler的一个引用，Message在Queue中存在的时间过长，就会导致Handler无法回收。如果Handler是非静态的，则会导致Activity或者Service不会被回收。并且消息队列是在一个Looper线程中不断地处理消息，当这个Activity退出时，消息队列中还有未处理的消息或者正在处理的消息，并且消息队列中的Message持有Handler实例的引用，Handler持有Activity的引用，所以导致Activity的内存资源无法及时回收，引发内存泄漏。解决方案如下：</p><ul><li>1、使用一个静态Handler内部类，然后对Handler持有的对象(一般是Activity)使用弱引用，这样在回收时，也可以回收Handler持有的对象。</li><li>2、在Activity的Destroy或者Stop时，应该移除消息队列中的消息，避免Looper线程的消息队列中有待处理的消息需要处理。</li></ul><p>需要注意的是，AsyncTask内部也是Handler机制，同样存在内存泄漏风险，但其一般是临时性的。对于<br>类似AsyncTask或是线程造成的内存泄漏，我们也可以将AsyncTask和Runnable类独立出来或者使用静态内部类。</p><h3 id="7、容器中的对象没清理造成的内存泄漏"><a href="#7、容器中的对象没清理造成的内存泄漏" class="headerlink" title="7、容器中的对象没清理造成的内存泄漏"></a>7、容器中的对象没清理造成的内存泄漏</h3><p>在退出程序前，将集合里的东西clear，然后置为null，再退出程序。</p><h3 id="8、WebView"><a href="#8、WebView" class="headerlink" title="8、WebView"></a>8、WebView</h3><p>WebView都存在内存泄漏的问题，在应用中只要使用一次WebView，内存就不会被释放掉。我们可以为WebView开启一个独立的进程，使用AIDL与应用的主进程进行通信，WebView所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。</p><h3 id="9、使用ListView造成的内存泄漏"><a href="#9、使用ListView造成的内存泄漏" class="headerlink" title="9、使用ListView造成的内存泄漏"></a>9、使用ListView造成的内存泄漏</h3><p>在构造Adapter时，使用缓存的convertView。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内存管理基础&quot;&gt;&lt;a href=&quot;#内存管理基础&quot; class=&quot;headerlink&quot; title=&quot;内存管理基础&quot;&gt;&lt;/a&gt;内存管理基础&lt;/h2&gt;&lt;h3 id=&quot;App内存组成以及限制&quot;&gt;&lt;a href=&quot;#App内存组成以及限制&quot; class=&quot;header</summary>
      
    
    
    
    <category term="性能优化" scheme="https://gun-ctrl.github.io/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM内存管理深度剖析</title>
    <link href="https://gun-ctrl.github.io/2022/08/13/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://gun-ctrl.github.io/2022/08/13/JVM%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</id>
    <published>2022-08-13T12:04:47.233Z</published>
    <updated>2022-08-19T06:50:07.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM与操作系统的关系"><a href="#JVM与操作系统的关系" class="headerlink" title="JVM与操作系统的关系"></a>JVM与操作系统的关系</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813203305453.png" alt="image-20220813203305453"></p><blockquote><p>以HelloWord.java程序为例，简单介绍一下java程序的执行过程</p><ul><li>HelloWord.java通过javac编译成字节码文件HelloWorld.class</li><li>通过类加载器ClassLoader将字节码文件加载到运行时数据区（这个会在后面介绍）</li><li>通过执行引擎执行并与操作系统交互</li></ul></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813203540635.png" alt="image-20220813203540635"></p><h3 id="关于Java-SE体系结构"><a href="#关于Java-SE体系结构" class="headerlink" title="关于Java SE体系结构"></a>关于Java SE体系结构</h3><ul><li>JVM只是一个翻译工具</li><li>JRE提供了基础类库</li><li>JDK提供了工具</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813204206894.png" alt="image-20220813204206894"></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p><strong>运行时数据区</strong></p><blockquote><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域</p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li><li>Java堆</li><li>方法区（运行时常量池）</li></ul><p>线程私有的：虚拟机栈、本地方法栈、程序计数器</p><ul><li>线程共享的：堆、方法区</li></ul></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813204329860.png" alt="image-20220813204329860"></p><h3 id="程序计数器和栈"><a href="#程序计数器和栈" class="headerlink" title="程序计数器和栈"></a>程序计数器和栈</h3><ul><li><p>程序计数器是JVM内存区域中 <strong>唯一不会OOM的内存区</strong></p></li><li><p>局部变量表只能存储8大数据类型（</p><p>byte[1]、short[2]、int[4]、long[8]、float[4]、double[8]、char[2]、boolean[1]）+引用</p></li><li><p>一个线程有多个方法</p></li><li><p>一个方法一个栈帧</p></li><li><p>操作数栈：存放方法的执行和操作。</p></li><li><p>下面通过一个简单的1+2&#x3D;3的计算过程解释局部变量表与操作数栈之间的关系</p><ol><li>操作数栈将局部变量表中的1、2拷贝入操作数栈</li><li>操作数栈弹出1、2并计算得3压入操作数栈</li><li>之后又压入局部变量表</li></ol><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_14_12_11_14_245.gif" alt="录制_2022_08_14_12_11_14_245"></p></li><li><p>关于动态链接的理解：</p><p>口述不清，咱们以实例来理解</p><p>下图中Man与Woman为Person类的子类都有wc的实现方法</p><p>引用首先指向Man，执行wc方法</p><p>当引用指向新的对象调用wc方法，但是这俩wc并不一样，系统却能调用正确的方法，这就是动态链接的作用。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813210956693.png" alt="image-20220813211001482"></p></li><li><p>本地方法栈</p><ul><li>本地方法栈保存的是native方法的信息</li><li>当一个JVM创建的线程调用native方法后，JVM不再为其在虚拟机中创建栈帧，JVM只是简单地调用动态链接库并直接调用native方法。</li></ul></li></ul><h2 id="方法区和堆"><a href="#方法区和堆" class="headerlink" title="方法区和堆"></a>方法区和堆</h2><p>首先解决一个问题，<strong>为什么堆和方法区都是线程共享的，但却分成两份？</strong></p><p>​1. 堆中存放的是数组和对象，需要频繁回收。</p><p>​2. 方法区中存放的有<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong></p><h3 id="深入辨析堆和栈"><a href="#深入辨析堆和栈" class="headerlink" title="深入辨析堆和栈"></a>深入辨析堆和栈</h3><ul><li>功能<ul><li>以栈帧的方式存储方法调用的过程，并存储方法调用过程中基本数据类型的变量以及对象的引用变量，其内存分配在栈上，变量出了作用域就会自动释放；</li><li>而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中；</li></ul></li><li>线程独享还是共享<ul><li>栈内存归属于单个线程，每个线程都有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存。</li><li>堆内存中的对象对所有线程可见，堆内存中的对象可以被所有线程访问。</li></ul></li><li>存储空间<ul><li>栈的内存要远远小于堆内存，栈的深度是有限制的，可能发生StackOverFlowError问题。</li></ul></li></ul><p><strong>堆的内存模型</strong></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814102942978.png"></p><blockquote><ul><li>堆的内存空间分为Eden（新生代）、From区和To区（也可划分到新生代）、Tenured（老年代）</li><li>对象被分配到的是连续的内存空间，也就是说上述的几个区域都是连续的内存空间。</li></ul><p>这里先浅谈一下堆的内存模型，后面在讲解对象的分配存储时将深入。</p></blockquote><h2 id="虚拟机优化技术"><a href="#虚拟机优化技术" class="headerlink" title="虚拟机优化技术"></a>虚拟机优化技术</h2><ul><li><p>编译优化技术</p><ul><li><p>方法内联</p><p>比如有的场景，可以用一个表达式代替一个Boolean判断方法。</p></li></ul></li><li><p>栈帧之间的数据共享</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814103626937.png" alt="image-20220814103626937"></p></li></ul><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><strong>对象的创建过程</strong>（一般对象）</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814103830376.png" alt="image-20220814103830376"></p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>内存划分引发的并发编程问题（指针碰撞） 解决方案：</p><ul><li><p>CAS加锁</p></li><li><p>本地线程分配缓冲TLAB（Thread Local Allocation Buffer）：</p><p>给每个线程分配一块区域（一般在Eden区）</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814104057751.png" alt="image-20220814104057751"></p></li></ul><h3 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h3><p>先初始化默认值（不需要赋值就可以使用，当然程序可以越早使用对象那么效率越高）</p><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>设置对象头信息</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814105348748.png" alt="image-20220814105348748"></p><h3 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h3><ul><li>执行构造方法</li></ul><h2 id="关于对象的访问定位"><a href="#关于对象的访问定位" class="headerlink" title="关于对象的访问定位"></a>关于对象的访问定位</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814105534396.png" alt="image-20220814105534396"></p><ul><li>使用句柄<ul><li>引用reference不再存对象地址，而是存对象所对应的指针（句柄），句柄池再映射一次。</li><li>句柄池具有指针定位的开销，开销比较小。</li></ul></li><li>直接指针<ul><li>直接指向真实的地址（Hotspot以及一些主流的虚拟机就使用这种）</li></ul></li></ul><h2 id="垃圾回收机制（GC）"><a href="#垃圾回收机制（GC）" class="headerlink" title="垃圾回收机制（GC）"></a>垃圾回收机制（GC）</h2><p>GC是不会主动触发的，内存不足时触发。</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><blockquote><p>引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></blockquote><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><blockquote><p>可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p></blockquote><p>在Java中，可作为GCRoot的对象包括：</p><ol><li><p>方法区：类静态属性的对象；</p></li><li><p>方法区：常量的对象；</p></li><li><p>虚拟机栈（本地变量表）中的对象；</p></li><li><p>本地方法栈JNI（Native方法）中的对象。</p></li></ol><p>使用可达性分析算法，对象一定会被GC吗？</p><p>答案是否定的，那就要涉及到finalize这个Object万类之主中的方法</p><h3 id="finalize与try-catch-finally"><a href="#finalize与try-catch-finally" class="headerlink" title="finalize与try catch finally"></a>finalize与try catch finally</h3><ul><li><p>finalize</p><ul><li><p>finalize()只能执行一次，且优先级较低</p></li><li><p>finalize()不一定能救活对象</p></li><li><p>所以<strong>使用try finally</strong>救活对象更好。</p></li></ul></li><li><p>try catch finally</p><ul><li>不管有没有出现异常，finally块中的代码一定会执行</li><li>当try和catch中有return时，finally仍然会执行</li><li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值只在finally执行之前确定的</li><li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中包含的返回值。</li></ul></li></ul><h3 id="四种引用"><a href="#四种引用" class="headerlink" title="四种引用"></a>四种引用</h3><ul><li><p>强引用：就像我们平时使用的“&#x3D;”</p></li><li><p>软引用（SoftReference）：</p><p>当OOM时被回收</p><ul><li>软引用测试：</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654658511709.png" alt="1654658511709"></p><p>第一次测试结果：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654658638965.png" alt="1654658638965"></p><p>第二次测试结果：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654658686941.png" alt="1654658686941"></p><ul><li><strong>软引用的实际使用：图片加载</strong></li></ul></li><li><p>弱引用（WeakReference）：</p><p>只要GC就被回收</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659017602.png" alt="1654659017602"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659061704.png" alt="1654659061704"></p><ul><li>实际应用：一些不是很重要的东西，比如缓存。可以用来防止内存泄漏</li><li>实际过程中弱引用使用的更多，因为发生GC的频次肯定比OOM的频次高</li></ul></li><li><p>虚引用（PhantomReference）：</p><ul><li><p>最弱的：随时会被回收，GC时会收到一个通知</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659537857.png" alt="1654659537857"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654659543594.png" alt="1654659543594"></p></li><li><p>实际应用：监控垃圾回收器是否正常工作</p></li></ul></li></ul><h3 id="对象分配策略"><a href="#对象分配策略" class="headerlink" title="对象分配策略"></a>对象分配策略</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814111523597.png" alt="image-20220814111523597"></p><ul><li><p><strong>几乎</strong>所有的对象都在堆中分配</p><ul><li>所以不是所有的对象都是在堆中分配</li><li>首先会判断是否在栈上分配</li></ul></li><li><p>栈上分配 -&gt; 虚拟机栈</p><ul><li>栈中运行完了，不需要垃圾回收，栈是跟随线程存在。</li></ul></li><li><p>逃逸分析</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654660876349.png" alt="1654660876349"></p></li><li><p>堆中的优化技术</p><ul><li>本地线程缓冲（TLAB）</li></ul></li><li><p>如果是大对象（很长的字符串、数组）</p><ul><li>放入到老年代（Tenured）中</li></ul></li><li><p>长期存活的对象进入老年代</p><ul><li>首先进入From区，然后接下来的GC中在From和To区移动（复制回收算法，只要把复制的对象传递过去，就可以对内存区域直接处理，效率高）</li><li>age最大15，超过15将进入老年代，age也可以自定义</li><li>From区与To区等大</li><li>大数据显示，大部分的新生对象中90%以上会在第一次GC被回收，剩下的才进入From区，所以可以让我们的空间利用率达到90%以上（并且空间比例Eden：From：To&#x3D;8:1:1）。</li></ul></li><li><p><strong>空间分配担保</strong></p><ul><li><p>From区与To区空间不够用，进入老年代（Tenured区）</p></li><li><p>由JVM做担保，不用fullGC（GC在堆中分为minorGC-&gt;Eden、From、To和fullGC-&gt;Tenured），空间够用</p></li><li><p>如果担保失败（空间不够用），那么首先需要fullGC，然后再存储对象到老年代</p></li><li><p>如此处理，就不用再每次向老年代存储对象时都fullGC</p></li></ul></li></ul><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ol><li>绝大多数对象都是“朝生夕死” -&gt;新生代</li><li>对象熬过了很多次垃圾回收，越难回收 -&gt;老年代</li><li>fullGC也会回收包括方法区在内的空间，即使方法区中的内容很难回收（静态变量、常量…）</li></ol><h4 id="复制算法（即前面的复制回收算法）"><a href="#复制算法（即前面的复制回收算法）" class="headerlink" title="复制算法（即前面的复制回收算法）"></a>复制算法（即前面的复制回收算法）</h4><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122152653.png" alt="image-20220814122152653"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122206391.png" alt="image-20220814122206391"></p><ul><li><p>实现简单、运行高效</p></li><li><p>内存复制、没有内存碎片</p></li><li><p>利用率只有一半（预留一半进行复制）</p></li><li><p>Appel式回收</p><p>即前面提到的，Eden区与From、To区分配比例大致为8:1:1（理由上面提及过，第一次回收时90%以上的都会被回收，只有不到10%才能进入From区）</p><p>这样使空间利用率提高了，提升至90%。</p></li></ul><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h4><ul><li>即在回收前标记需要回收的空间</li><li>执行效率不稳定（可能有90%需要回收、可能10%需要回收）</li><li>内存碎片导致提前GC</li></ul><h4 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h4><blockquote><p>是标记清楚算法缺点的一种解决方案，但同样也存在明显缺陷。</p><ul><li>对象移动</li><li>引用更新</li><li>用户线程暂停</li><li>没有内存碎片</li></ul></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122427544.png" alt="image-20220814122427544"></p><h4 id="JVM中常见的垃圾回收器"><a href="#JVM中常见的垃圾回收器" class="headerlink" title="JVM中常见的垃圾回收器"></a>JVM中常见的垃圾回收器</h4><ul><li>单线程垃圾回收器</li><li>多线程并行垃圾回收器</li><li><strong>多线程并发垃圾回收器</strong>：支持垃圾回收线程与用户线程 同时工作。</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814122835721.png" alt="image-20220814122835721"></p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>Concurrent Mark Seep并发标记清除</p><ul><li>减少了STW（Stop The World）的时间</li><li>只针对老年代</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814123049105.png" alt="image-20220814123049105"></p><p><strong>标记阶段</strong></p><ul><li>初始标记（暂停所有用户线程）：标记GCRoots直接相连的对象，所以速度很快。</li><li>并发标记：标记GCRoots所有关联的对象。</li><li>重新标记（暂停所有用户线程）：将中间有变动的重新标记（并发收集是GC不干净的，所以需要重新标记），时间短。</li></ul><p><strong>清理阶段</strong></p><ul><li>并发清理（用户和GC同时进行）：时间长</li><li>重置线程</li></ul><p><strong>缺点</strong>：</p><ul><li>CPU敏感：用户线程、GC线程都要跑，如果CPU核心数不足，那么对用户影响会很大</li><li>浮动垃圾：并发清理时，用户线程还是会产生垃圾</li><li>内存碎片</li></ul><h2 id="常量池与String"><a href="#常量池与String" class="headerlink" title="常量池与String"></a>常量池与String</h2><p>最后再来谈一个易混淆的知识点，String，同时介绍一个常量池。</p><p><strong>静态常连池</strong></p><blockquote><p>所谓静态常量池，即*.class文件中的常量池，class文件中的常量池不仅包含字符串(数字)<strong>字面量</strong>，还包含类、方法的信息，占用class文件绝大部分空间。 </p></blockquote><p><strong>运行时常量池</strong></p><blockquote><p>而<strong>运行时常量池</strong>，则是jvm虚拟机在完成类装载操作后，将class文件中的常量池载入到内存中，并保存在方法区中，<strong>咱们常说的常量池，就是指方法区中的运行时常量池。</strong> </p></blockquote><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><blockquote><p>String str &#x3D; new String(“abc”)；</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220814153313986.png" alt="image-20220814153313986"></p></blockquote><p><strong>intern</strong></p><blockquote><p>在调用intern方法之后，会去常量池中查找是否有等于该字符串常量对象的引用，有就返回引用。</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654865473328.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;JVM与操作系统的关系&quot;&gt;&lt;a href=&quot;#JVM与操作系统的关系&quot; class=&quot;headerlink&quot; title=&quot;JVM与操作系统的关系&quot;&gt;&lt;/a&gt;JVM与操作系统的关系&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://banmaman-1312858</summary>
      
    
    
    
    <category term="Java筑基" scheme="https://gun-ctrl.github.io/categories/Java%E7%AD%91%E5%9F%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>自定义PhotoView手势处理</title>
    <link href="https://gun-ctrl.github.io/2022/08/13/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/"/>
    <id>https://gun-ctrl.github.io/2022/08/13/%E8%87%AA%E5%AE%9A%E4%B9%89PhotoView%E6%89%8B%E5%8A%BF%E5%A4%84%E7%90%86/</id>
    <published>2022-08-13T07:43:26.553Z</published>
    <updated>2022-08-13T09:57:13.214Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p> 前面介绍了前面介绍了嵌套滑动、自定义Behavior等高级UI实现原理，今天介绍一种比较简单的高级UI用法——手势处理。</p><p> 你可以点开自己的手机相册，点开任意一张图片，双击图片会有放大效果，再次双击会缩小为原来大小。并且双指操作可以放大缩小图片。今天，小编就来实现一下这样的PhotoView效果。但是我的效果处理肯定不是很完美，毕竟追求代码简洁。</p></blockquote><p>效果展示图：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_13_16_02_16_954.gif" alt="录制_2022_08_13_16_02_16_954"></p><h2 id="手势处理API"><a href="#手势处理API" class="headerlink" title="手势处理API"></a>手势处理API</h2><p>首先，先介绍一个Android处理单指手势的API <code>GestureDetector</code>，在创建一个GestureDetector对象时需要传入一个监听者<code>OnGestureListener</code>，所以我们需要实现OnGestureListener，通常实现SimpleOnGestureListener这个接口里面的功能就足够我们使用了，所以实现它即可。</p><p><strong>SimpleOnGestureListener的方法介绍</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoScaleGestureDetector</span> <span class="keyword">extends</span> <span class="title class_">GestureDetector</span>.SimpleOnGestureListener&#123;</span><br><span class="line">        <span class="comment">//在ACTION_DOWN时触发，必定触发</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDown</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onDown(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//延时100ms，处理点击效果</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onShowPress</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onShowPress(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//up时触发，单击或双击的第一次，不是双击和长按</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onSingleTapUp</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onSingleTapUp(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e1 手指按下</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e2 当前的事件</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> distanceX oldX - newX</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> distanceY oldY - newY -&gt;向右滑得到的是负数，所以需要取与distance相反的值</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onScroll</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e1, <span class="meta">@NonNull</span> MotionEvent e2, <span class="type">float</span> distanceX, <span class="type">float</span> distanceY)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onScroll(e1, e2, distanceX, distanceY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 长按触发，默认达到300ms就会触发</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onLongPress</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>.onLongPress(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 手指松开后，惯性滑动，大于50dp/s</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onFling</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e1, <span class="meta">@NonNull</span> MotionEvent e2, <span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onFling(e1, e2, velocityX, velocityY);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单击按下时触发，双击不触发，up和down都有可能触发</span></span><br><span class="line">        <span class="comment">// 延时300ms触发TAP事件</span></span><br><span class="line">        <span class="comment">// 300ms以内抬手才会触发TAP</span></span><br><span class="line">        <span class="comment">// 300ms以后抬手，不是双击，不是长按就触发</span></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onSingleTapConfirmed</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onSingleTapConfirmed(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双击，在ACTION_DWON中处理，触发时间 40-300ms</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDoubleTap</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onDoubleTap(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 双击的第二次Down、move、up都会触发这个</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">onDoubleTapEvent</span><span class="params">(<span class="meta">@NonNull</span> MotionEvent e)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.onDoubleTapEvent(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下图是三个类或接口的时序关系，PhotoView为小编的自定义View。</p><blockquote><p>从时序图可以看出，我们只需要实例化SimpleOnGestureListener并且在对应的方法中做自己的处理，在onTouchEvent触摸事件中回调gestureDetector.onTouchEvent(event)就能将自定义的触摸事件设置完成。</p><p><strong>注：</strong>onDown必须返回true，否则就不会处理点击事件了。</p><p>另外需要注意的一个点是，如果GestureDetector是在子线程中创建的，还必须得调用Looper.prepare()，因为如果我们不手动传入一个handler实例，系统就会帮我们new一个，而Handler是会和所在线程进行一个绑定，必须进行prepare，而这个handler就是来处理触摸事件的，下面通过一张图来进行描述它们之间的关系</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813160810620.png" alt="image-20220813160810620"></p><p><strong>ScaleGestureDetector.OnScaleGestureListener的方法</strong></p><p>下面的代码是小编demo中的</p><p>scaleGestureDetector.getScaleFactor()为缩放因子</p><ul><li>onScaleBegin：scale变化前的处理</li><li>onScale：scale变化时，也就是双指缩放图片scale处理的位置</li><li>onScaleEnd：scale变化后的处理</li></ul><p><strong>注：</strong>onScaleBegin方法中必须返回true，否则双指操作无效</p><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoScaleGestureDetector</span> <span class="keyword">implements</span> <span class="title class_">ScaleGestureDetector</span>.<span class="property">OnScaleGestureListener</span> &#123;</span><br><span class="line"></span><br><span class="line">        float initScale;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">onScale</span>(<span class="params"><span class="meta">@NonNull</span> ScaleGestureDetector scaleGestureDetector</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((currentScale&gt;smallScale &amp;&amp; !isEnlarge)||(currentScale==smallScale &amp;&amp; !isEnlarge))&#123;</span><br><span class="line">                isEnlarge = !isEnlarge;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//缩放因子</span></span><br><span class="line">            currentScale = initScale * scaleGestureDetector.<span class="title function_">getScaleFactor</span>();</span><br><span class="line">            <span class="comment">//注意：一定要刷新，否则放大缩小效果就很生硬</span></span><br><span class="line">            <span class="title function_">invalidate</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">boolean</span> <span class="title function_">onScaleBegin</span>(<span class="params"><span class="meta">@NonNull</span> ScaleGestureDetector scaleGestureDetector</span>) &#123;</span><br><span class="line">            initScale = currentScale;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">onScaleEnd</span>(<span class="params"><span class="meta">@NonNull</span> ScaleGestureDetector scaleGestureDetector</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="图片缩放效果的实现"><a href="#图片缩放效果的实现" class="headerlink" title="图片缩放效果的实现"></a>图片缩放效果的实现</h2><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PhotoGestureDetector extends GestureDetector.SimpleOnGestureListener &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">Down(@NonNull MotionEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">            return <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">DoubleTap(@NonNull MotionEvent <span class="params">e</span>)</span> &#123;</span><br><span class="line">            isEnlarge = !isEnlarge;</span><br><span class="line">            <span class="keyword">if</span> (isEnlarge)&#123;</span><br><span class="line">                <span class="comment">//经过一次放大后缩小后点击新的位置，从该位置为中心放大，所以需要重置offset</span></span><br><span class="line">                offsetX = (e.get<span class="constructor">X()</span>-get<span class="constructor">Width()</span>/<span class="number">2</span>f)-(e.get<span class="constructor">X()</span>-get<span class="constructor">Width()</span>/<span class="number">2</span>f)<span class="operator"> * </span>(bigScale/smallScale);</span><br><span class="line">                offsetY = (e.get<span class="constructor">Y()</span>-get<span class="constructor">Height()</span>/<span class="number">2</span>f)-(e.get<span class="constructor">Y()</span>-get<span class="constructor">Height()</span>/<span class="number">2</span>f)* (bigScale/smallScale);</span><br><span class="line">                fix<span class="constructor">Offsets()</span>;</span><br><span class="line">                currentScale = bigScale;</span><br><span class="line">                get<span class="constructor">ScaleAnim(<span class="params">smallScale</span>,<span class="params">bigScale</span>)</span>.start<span class="literal">()</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                currentScale = smallScale;</span><br><span class="line">                get<span class="constructor">ScaleAnim(<span class="params">smallScale</span>,<span class="params">bigScale</span>)</span>.reverse<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.on<span class="constructor">DoubleTap(<span class="params">e</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * @param e1 手指按下</span></span><br><span class="line"><span class="comment">         * @param e2 当前的事件</span></span><br><span class="line"><span class="comment">         * @param distanceX oldX - newX</span></span><br><span class="line"><span class="comment">         * @param distanceY oldY - newY -&gt;向右滑得到的是负数，所以需要取与distance相反的值</span></span><br><span class="line"><span class="comment">         * @return</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">Scroll(@NonNull MotionEvent <span class="params">e1</span>, @NonNull MotionEvent <span class="params">e2</span>, <span class="params">float</span> <span class="params">distanceX</span>, <span class="params">float</span> <span class="params">distanceY</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEnlarge)&#123;</span><br><span class="line">                offsetX -= distanceX;</span><br><span class="line">                offsetY -= distanceY;</span><br><span class="line">                fix<span class="constructor">Offsets()</span>;</span><br><span class="line">                invalidate<span class="literal">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            return super.on<span class="constructor">Scroll(<span class="params">e1</span>, <span class="params">e2</span>, <span class="params">distanceX</span>, <span class="params">distanceY</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean on<span class="constructor">Fling(@NonNull MotionEvent <span class="params">e1</span>, @NonNull MotionEvent <span class="params">e2</span>, <span class="params">float</span> <span class="params">velocityX</span>, <span class="params">float</span> <span class="params">velocityY</span>)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isEnlarge)&#123;</span><br><span class="line">                overScroller.fling(</span><br><span class="line">                        (<span class="built_in">int</span>)offsetX,</span><br><span class="line">                        (<span class="built_in">int</span>)offsetY,</span><br><span class="line">                        (<span class="built_in">int</span>) velocityX,</span><br><span class="line">                        (<span class="built_in">int</span>) velocityY,</span><br><span class="line">                        -(<span class="built_in">int</span>) (bitmap.get<span class="constructor">Width()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Width()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        (<span class="built_in">int</span>) (bitmap.get<span class="constructor">Width()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Width()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        -(<span class="built_in">int</span>) (bitmap.get<span class="constructor">Height()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Height()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        (<span class="built_in">int</span>) (bitmap.get<span class="constructor">Height()</span><span class="operator"> * </span>bigScale - get<span class="constructor">Height()</span>)<span class="operator"> / </span><span class="number">2</span>,</span><br><span class="line">                        <span class="number">300</span>,</span><br><span class="line">                        <span class="number">300</span></span><br><span class="line">                );</span><br><span class="line">                post<span class="constructor">OnAnimation(<span class="params">new</span> FlingRunner()</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return super.on<span class="constructor">Fling(<span class="params">e1</span>, <span class="params">e2</span>, <span class="params">velocityX</span>, <span class="params">velocityY</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个算法用于限制图片偏移的范围</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164000778.png" alt="image-20220813164000778"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813170526346.png" alt="image-20220813170526346"></p><blockquote><p>惯性事件处理</p><p>其他重要参数截图中都有介绍，下面主要介绍一下postAnimation，一次只能移动一小段距离（一帧），需要多次调度动画直到完成滑动偏移，这里采用递归的方式，实例化一个Runnable放入postOnAnimation()中</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164706784.png"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164828771.png" alt="image-20220813164828771"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220813164423762.png" alt="image-20220813164423762"></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void on<span class="constructor">SizeChanged(<span class="params">int</span> <span class="params">w</span>, <span class="params">int</span> <span class="params">h</span>, <span class="params">int</span> <span class="params">oldw</span>, <span class="params">int</span> <span class="params">oldh</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">SizeChanged(<span class="params">w</span>, <span class="params">h</span>, <span class="params">oldw</span>, <span class="params">oldh</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了避免图片展示的边上有空隙，最好使用float</span></span><br><span class="line">        originalOffsetX = (get<span class="constructor">Width()</span> - bitmap.get<span class="constructor">Width()</span>)<span class="operator"> / </span><span class="number">2</span>f;</span><br><span class="line">        originalOffsetY = (get<span class="constructor">Height()</span> - bitmap.get<span class="constructor">Height()</span>)<span class="operator"> / </span><span class="number">2</span>f;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是高度全屏还是宽度全屏</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">float</span>)bitmap.get<span class="constructor">Width()</span>/bitmap.get<span class="constructor">Height()</span>&gt;(<span class="built_in">float</span>) get<span class="constructor">Width()</span>/get<span class="constructor">Height()</span>)&#123;</span><br><span class="line">            smallScale = (<span class="built_in">float</span>) get<span class="constructor">Width()</span>/ bitmap.get<span class="constructor">Width()</span>;</span><br><span class="line">            bigScale = (<span class="built_in">float</span>) get<span class="constructor">Height()</span>/bitmap.get<span class="constructor">Height()</span>*OVER_SCALE_FACTOR;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            smallScale = (<span class="built_in">float</span>) get<span class="constructor">Height()</span>/bitmap.get<span class="constructor">Height()</span>;</span><br><span class="line">            bigScale = (<span class="built_in">float</span>) get<span class="constructor">Width()</span>/bitmap.get<span class="constructor">Width()</span>*OVER_SCALE_FACTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        currentScale = smallScale;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void on<span class="constructor">Draw(Canvas <span class="params">canvas</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Draw(<span class="params">canvas</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据放大比例，设置一次滑动时偏移的尺寸，视觉上来看就是滑动速度</span></span><br><span class="line">        <span class="built_in">float</span> scaleFaction = (currentScale-smallScale)/(bigScale-smallScale);</span><br><span class="line">        canvas.translate(offsetX<span class="operator"> * </span>scaleFaction,offsetY<span class="operator"> * </span>scaleFaction);</span><br><span class="line"></span><br><span class="line">        canvas.scale(currentScale,currentScale,get<span class="constructor">Width()</span>/<span class="number">2</span>f,get<span class="constructor">Height()</span>/<span class="number">2</span>f);</span><br><span class="line">        canvas.draw<span class="constructor">Bitmap(<span class="params">bitmap</span>,<span class="params">originalOffsetX</span>,<span class="params">originalOffsetY</span>,<span class="params">paint</span>)</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>判断是单指处理还是双指处理</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">       boolean result = scaleGestureDetector.on<span class="constructor">TouchEvent(<span class="params">event</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span>(!scaleGestureDetector.is<span class="constructor">InProgress()</span>)&#123;</span><br><span class="line">           result = gestureDetector.on<span class="constructor">TouchEvent(<span class="params">event</span>)</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="关于多指触摸事件"><a href="#关于多指触摸事件" class="headerlink" title="关于多指触摸事件"></a>关于多指触摸事件</h2><ul><li><p><strong>注意：</strong>多指处理需要<code>event.getActionMasked()</code></p></li><li><p>一次触摸事件中Down和Up都只触发一次</p></li><li><p>多指触摸事件是存储在一个键值（&lt;id，index&gt;）对数组中，从0开始，可以理解为一个SpareArray，需要一个currentPointId记录当前正在处理事件的手指。</p><p>该数组的规则：</p><ul><li>当手指Up，对应的id和index会从数组中移除，移除后数组会偏移补全，比如0-4移除3，4会补全3的位置，并且index变为3，而id不变</li><li>再有新的手指点击，如果前面的id不连续，会补全，比如接着上方的例子原来的index3会变为index4，而新的点击事件为id3、index3，也就是说id不会变，index会变</li></ul></li><li><p>lastOffsetX、lastOffsetY记录上一次的偏移值，否则有新的手指点击的话会出现图片“闪现”效果</p></li><li><p><code>event.findPointerIndex(Id)</code>通过Id获取Index</p></li><li><p><code>event.getActionIndex()</code>获取当前触摸手指的index，<code>event.getPointerId(actionIndex)</code>通过index获取id</p></li><li><p>抬起的手指是活跃手指并且是最后一个按下的手指，那么活跃手指更新为抬起手指的前一个-&gt;upIndex &#x3D; event.getPointerCount() -2</p></li><li><p>如果抬起手指是中间的并且是活跃手指，那么活跃手指更新为下一个-&gt;upIndex++</p></li><li><p>以上两点都是根据多指触摸事件数组规则做出的判断</p></li></ul><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">        switch (event.get<span class="constructor">ActionMasked()</span>)&#123;</span><br><span class="line">            <span class="comment">//Down和Up都只触发一次</span></span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                downX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                downY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                lastOffsetX = offsetX;</span><br><span class="line">                lastOffsetY = offsetY;</span><br><span class="line"></span><br><span class="line">                currentPointId = <span class="number">0</span>;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="comment">// 通过id 拿index</span></span><br><span class="line">                <span class="keyword">if</span> (event.get<span class="constructor">PointerCount()</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="built_in">int</span> index = event.find<span class="constructor">PointerIndex(<span class="params">currentPointId</span>)</span>;</span><br><span class="line">                    <span class="comment">// event.getX()默认 index = 0的坐标 --- move操作的是后按下的手指</span></span><br><span class="line">                    offsetX = lastOffsetX + event.get<span class="constructor">X(<span class="params">index</span>)</span> - downX;</span><br><span class="line">                    offsetY = lastOffsetY + event.get<span class="constructor">Y(<span class="params">index</span>)</span> - downY;</span><br><span class="line">                    invalidate<span class="literal">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">                <span class="comment">//获取当前（最后一次）按下的index</span></span><br><span class="line">                <span class="keyword">if</span> (event.get<span class="constructor">PointerCount()</span>&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="built_in">int</span> actionIndex = event.get<span class="constructor">ActionIndex()</span>;</span><br><span class="line">                    currentPointId = event.get<span class="constructor">PointerId(<span class="params">actionIndex</span>)</span>;</span><br><span class="line"></span><br><span class="line">                    downX = event.get<span class="constructor">X(<span class="params">actionIndex</span>)</span>;</span><br><span class="line">                    downY = event.get<span class="constructor">Y(<span class="params">actionIndex</span>)</span>;</span><br><span class="line">                    lastOffsetX = offsetX;</span><br><span class="line">                    lastOffsetY = offsetY;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                    <span class="built_in">int</span> upIndex = event.get<span class="constructor">ActionIndex()</span>;</span><br><span class="line">                    <span class="built_in">int</span> pointId = event.get<span class="constructor">PointerId(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                    <span class="comment">//非活跃的手指不用处理</span></span><br><span class="line">                    <span class="keyword">if</span> (pointId==currentPointId)&#123;</span><br><span class="line">                        <span class="comment">//更新活跃手指</span></span><br><span class="line">                        <span class="keyword">if</span> (upIndex<span class="operator"> == </span>event.get<span class="constructor">PointerCount()</span>-<span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="comment">//抬起的手指是活跃手指并且是最后一个按下的手指，那么活跃手指更新为抬起手指的前一个</span></span><br><span class="line">                            upIndex = event.get<span class="constructor">PointerCount()</span> -<span class="number">2</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">//如果抬起手指是中间的并且是活跃手指，那么活跃手指更新为下一个</span></span><br><span class="line">                            upIndex++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        currentPointId = event.get<span class="constructor">PointerId(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                        downX = event.get<span class="constructor">X(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                        downY = event.get<span class="constructor">Y(<span class="params">upIndex</span>)</span>;</span><br><span class="line">                        lastOffsetX = offsetX;</span><br><span class="line">                        lastOffsetY = offsetY;</span><br><span class="line">                    &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实，多指触摸事件很少使用，不过应用起来还是有很不错的效果。</p><p>实现PhotoView的效果重点就是<code>GestureDetector.SimpleOnGestureListener</code>、<code>ScaleGestureDetector.OnScaleGestureListener</code>这两个API的使用，其实自定义View这一块，只要把尺寸、偏移等这些处理好了实现想要的效果还是很容易的。</p><p>最后附上源码：</p><p><a href="https://github.com/gun-ctrl/PhotoView">源码地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 前面介绍了前面介绍了嵌套滑动、自定义Behavior等高级UI实现原理，今天介绍一种比较简单的高级UI用法——手</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
    <category term="自定义View" scheme="https://gun-ctrl.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
  </entry>
  
  <entry>
    <title>CoordinatorLayout原理解析与Behavior</title>
    <link href="https://gun-ctrl.github.io/2022/08/06/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8EBehavior/"/>
    <id>https://gun-ctrl.github.io/2022/08/06/CoordinatorLayout%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8EBehavior/</id>
    <published>2022-08-06T08:57:22.644Z</published>
    <updated>2022-08-14T04:19:35.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CoordinatorLayout的功能"><a href="#CoordinatorLayout的功能" class="headerlink" title="CoordinatorLayout的功能"></a>CoordinatorLayout的功能</h2><p><strong>事先警示：</strong>CoordinatorLayout只继承了NestedScrollParent，也就是说它只能做顶层父View，别踩坑！！！</p><ol><li><p>处理子控件之间依赖下的交互</p></li><li><p>处理子控件之间的嵌套滑动</p></li><li><p>处理子控件的测量与布局</p></li><li><p>处理子控件的事件拦截与响应</p><p>以上四个功能，都建立与CoordinatorLayout中提供的一个叫做Behavior的“插件”之上。Behavior内部也提供了相应方法来对应这四个不同的功能。<br>Behavior内部集成了上述四种功能对应的方法，实现解耦。</p></li></ol><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806114929932.png" alt="image-20220806114929932"></p><p><strong>什么是Behavior？</strong><br>可以把Behavior理解成插件，当我们的组件想实现什么样的功能的时候就使用对应的Behavior，也就是说很多种不同功能的Behavior，当然也可以自定义Behavior。</p><h2 id="CoordinatorLayout下依赖交互原理"><a href="#CoordinatorLayout下依赖交互原理" class="headerlink" title="CoordinatorLayout下依赖交互原理"></a>CoordinatorLayout下依赖交互原理</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115038051.png" alt="image-20220806115038051"></p><blockquote><p>当CoordinatorLayout中子控件dependency的位置、大小发生变化的时候，那么在CoordinatorLayout内部会通知所有依赖depandency的控件，并调用对应声明的Behavior，告知其依赖的dependency发生变化。<br>那么如何判断依赖-&gt;layoutDependsOn<br>接收到通知后如何处理-&gt;onDependentViewChanged&#x2F;onDependentViewRemoved<br>这些都是由Behavior来处理。</p></blockquote><h3 id="主要方法介绍"><a href="#主要方法介绍" class="headerlink" title="主要方法介绍"></a>主要方法介绍</h3><ul><li><p><strong>layoutDependsOn(CoordinatorLayout parent, View child, View dependency)</strong>  表示是否给应用了Behavior 的View 指定一个依赖的布局</p><ul><li>参数1：coordinatorlayout对象</li><li>参数2：child 被观察的View</li><li>参数3：依赖变化的View（被观察的View）</li></ul></li><li><p><strong>onDependentViewChanged(CoordinatorLayout parent, View child, View dependency)</strong> 当依赖的View发生变化的时候hi掉的方法</p></li><li><p><strong>onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type)</strong> 当用户手指按下的时候，你是否要处理这次操作。当你确定要处理这次操作的时候，返回true；如果返回false的时候，就不会去响应后面的回调事件了。你想怎么滑就怎么话，我都不做处理。这里的(axes)滚动方向很重要，可以通过此参数判断滚动方向！</p><ul><li>参数3：直接目标，相当于能滑动的控件</li><li>参数4：观察的View</li><li>参数5：这个可以简单理解为滚动方向<ul><li>ViewCompat#SCROLL_AXIS_HORIZONTAL 水平方向</li><li>ViewCompat#SCROLL_AXIS_VERTICAL 竖直方向</li></ul></li><li>参数6：这个参数是之后有的，如果你输入的类型不是TYPE_TOUCH那么就不会相应这个滚动</li></ul></li><li><p><strong>onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</strong> 当onStartNestedScroll准备处理这次滑动的时候(返回true的时候)，回调这个方法。可以在这个方法中做一些响应的准备工作！</p></li><li><p><strong>onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</strong> 当滚动开始执行的时候回调这个方法。</p><ul><li>参数4&#x2F;参数5：用户x&#x2F;y轴滚动的距离(注意这里是每一次都回调的啊！！！)</li><li>参数6：处理滚动的距离的参数，内部维护着输出距离，假设用户滑动了100px,child 做了90px的位移，你需要把consumed［1］的值改成90，这样coordinatorLayout就能知道只处理剩下的10px的滚动。其中consumed[0]代表x轴、consumed[1]代表y轴。可能你不理解这个问题，换个形象点的比喻，比如你开发某一个功能，但是你只会其中的90%那么怎么办呢？不能就不管了。好你找到了你的同事或者老大，让他去完成剩下的10%。这样问题就完美的解决了，是一个概念的！</li></ul></li><li><p><strong>onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type)</strong> 上面这个方法结束的时候，coordinatorLayout处理剩下的距离，比如还剩10px。但是coordinatorLayout发现滚动2px的时候就已经到头了。那么结束其滚动，调用该方法，并将coordinatorLayout处理剩下的像素数作为参<code>(dxUnconsumed、dyUnconsumed)</code>传过来，这里传过来的就是 8px。参数中还会有coordinatorLayout处理过的像素数（dxConsumed、dyConsumed）。老大开始处理剩下的距离了！这个方法主要处理一些越界后的滚动。还是不懂对吧！还拿你们老大做比喻：比如上面还剩 10%的工作，这时老大处理了2%后发现已经可以上线了，于是老大结束了工作，并将处理剩下的内容（dxUnconsumed、dyUnconsumed）纪录下来，告诉你。老大处理了的内容（dxConsumed、dyConsumed）也告诉了你。</p><ul><li>参数4&#x2F;参数5：当没有滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li><li>参数6&#x2F;参数7：当滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li></ul></li><li><p>onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, float velocityX, float velocityY) 当手指松开发生惯性动作之前调用，这里提供了响应的速度，你可以根据速度判断是否需要进行折叠等一系列的操作，你要确定响应这个方法的话，返回true。</p><ul><li>参数4&#x2F;参数5：代表相应的速度</li></ul></li><li><p>onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int type) 停止滚动的时候回调的方法。当你不去响应Fling的时候会直接回调这个方法。在这里可以做一些清理工作。或者其他的内容。。。</p></li><li><p>onLayoutChild(CoordinatorLayout parent, View child, int layoutDirection) 确定子View位置的方法，这个方法可以重新定义子View的位置(这里明确是设置behavior的那个View哦),例如下面这样</p><ul><li>ViewCompat#LAYOUT_DIRECTION_LTR 视图方向从左到右</li><li>ViewCompat#LAYOUT_DIRECTION_RTL 视图方向从优到左</li></ul></li></ul><h2 id="CoordinatorLayout下嵌套滑动原理"><a href="#CoordinatorLayout下嵌套滑动原理" class="headerlink" title="CoordinatorLayout下嵌套滑动原理"></a>CoordinatorLayout下嵌套滑动原理</h2><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115051276.png" alt="image-20220806115051276"></p><blockquote><p>CoordinatorLayout实现了NestedScrollingParent2接口。那么当事件(scroll或fling)产生后，内部实现了NestedScrollingChild接口的子控件会将事件分发给CoordinatorLayout，CoordinatorLayout又会将事件传递给所有的Behavior中实现子控件的嵌套滑动。</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806142237581.png" alt="image-20220806142237581"></p><blockquote><p>相对于NestedScrollView机制（参数角色只有子控件和父控件），CoordinatorLayout中的交互角色玩出了新高度，在CoordinatorLayout下的子控件可以与多个兄弟控件进行交互。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115109848.png" alt="image-20220806115109848"></p></blockquote><p>大家可以看一下整个事件的流程图</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806144653508.png" alt="image-20220806144653508"></p><p><strong>浅谈View的生命周期</strong></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115156782.png" alt="image-20220806115156782"></p><blockquote><p>层级关系：activity-&gt;window-&gt;view<br>LayoutInflater.inflate将view解析出来<br>在onFinishInflate阶段add到content中，content属于DecorView<br>在Activity中通过attach方法new一个PhoneWindow<br>在resume阶段通过makevisible方法PhoneWindow.addView(DecorView)<br>再回调onAttachToWindow，然后已经一系列方法（包括setView-&gt;WMS…开始绘制)才呈现出View</p></blockquote><h2 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h2><p>下面是截取的重要源码截图</p><p><strong>ViewTreeObserver介绍</strong></p><blockquote><p>ViewTreeObserver注册一个观察者来监听视图树，当是图书的布局、视图树的焦点、视图将要绘制、视图滚动等发生改变时，ViewTreeObserver都会收到通知，ViewTreeObsrver不能被实例化，可以调用，View.getViewTreeObserver()来获得</p></blockquote><blockquote><p>dispatchOnOreDraw():通知观察者绘制即将开始，如果其中的某个观察者返回true，那么绘制会取消，并且重新安排绘制，如果想在View Layout或View hierarchy还未依附到Window时，或者在View处于CONE状态时强制绘制，可以手动调用这个方法。<br>通过ViewTreeObserver添加绘制监听</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115229067.png" alt="image-20220806115229067"></p><p>注意，这里不是<code>getChildAt()</code>而是<code>mDependencySortedChildren.get()</code>，因为mDependencySortedChildren在这里是一个特殊的集合，因为CoordinatorLayout管理着多个子View，并且子View之间还存在依赖关系，所以还利用了有向无环图来记录View的依赖关系。只需理解原因即可，这里不用深究，否则会陷到坑里面去。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115313761.png" alt="image-20220806115313761"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115333029.png" alt="image-20220806115333029"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115712870.png" alt="image-20220806115712870"></p><p>Behavior在哪里被实例化？<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115344751.png" alt="image-20220806115344751"></p><p>如果自定义ViewGroup并且需要提供一些特殊的属性给子View，那么就需要重写LayoutParams</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115427736.png" alt="image-20220806115427736"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115502591.png" alt="image-20220806115444264"></p><p><code>HierarchyChangeListener</code>回调监听，当childView添加与删除时调用</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115502591.png" alt="image-20220806115502591"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115532076.png" alt="image-20220806115532076"></p><p>前面提到了mDependencySortedChildren，那么mDependencySortedChildren在哪初始化呢？</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115554255.png" alt="image-20220806115554255"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115611892.png" alt="image-20220806115611892"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806115633713.png" alt="image-20220806115633713"></p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><strong>效果展示</strong></p><p>这是利用Behavior实现的嵌套滑动效果，上滑时顶部会隐藏，往下滑时顶部又会回显出来</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_15_07_40_12.gif" alt="录制_2022_08_06_15_07_40_12"></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> SampleHeaderBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mOffsetTopAndBottom;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mLayoutTop;</span><br><span class="line">    public <span class="constructor">SampleHeaderBehavior()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="constructor">SampleHeaderBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span>&#123;</span><br><span class="line">        super(context,attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">LayoutChild(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull TextView <span class="params">child</span>, <span class="params">int</span> <span class="params">layoutDirection</span>)</span> &#123;</span><br><span class="line">        parent.on<span class="constructor">LayoutChild(<span class="params">child</span>,<span class="params">layoutDirection</span>)</span>;</span><br><span class="line">        mLayoutTop = child.get<span class="constructor">Top()</span>;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">StartNestedScroll(@NonNull CoordinatorLayout <span class="params">coordinatorLayout</span>, @NonNull TextView <span class="params">child</span>, @NonNull View <span class="params">directTargetChild</span>, @NonNull View <span class="params">target</span>, <span class="params">int</span> <span class="params">axes</span>, <span class="params">int</span> <span class="params">type</span>)</span> &#123;</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void on<span class="constructor">NestedPreScroll(@NonNull CoordinatorLayout <span class="params">coordinatorLayout</span>, @NonNull TextView <span class="params">child</span>, @NonNull View <span class="params">target</span>, <span class="params">int</span> <span class="params">dx</span>, <span class="params">int</span> <span class="params">dy</span>, @NonNull <span class="params">int</span>[] <span class="params">consumed</span>, <span class="params">int</span> <span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> consumedy = <span class="number">0</span>;<span class="comment">//记录消费的距离</span></span><br><span class="line">        <span class="built_in">int</span> offset = mOffsetTopAndBottom - dy;</span><br><span class="line">        <span class="comment">//因为offset是带方向的，这里获取到最大可滑动距离需要在前面添加负号</span></span><br><span class="line">        <span class="built_in">int</span> minOffset = -get<span class="constructor">ChildScrollRange(<span class="params">child</span>)</span>;</span><br><span class="line">        <span class="built_in">int</span> maxOffset = <span class="number">0</span>;</span><br><span class="line">        offset = offset&lt;minOffset? minOffset:(<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(offset, maxOffset));</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">child</span>,<span class="params">offset</span>-(<span class="params">child</span>.<span class="params">getTop</span>()</span>-mLayoutTop));</span><br><span class="line">        consumedy = mOffsetTopAndBottom - offset;</span><br><span class="line">        <span class="comment">//将本次滑动到的位置记录下来</span></span><br><span class="line">        mOffsetTopAndBottom = offset;</span><br><span class="line">        consumed<span class="literal">[<span class="number">1</span>]</span> = consumedy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取childView最大可滑动距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> get<span class="constructor">ChildScrollRange(View <span class="params">childView</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (childView==null)&#123;</span><br><span class="line">            return <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        return childView.get<span class="constructor">Height()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> ScrollerBehavior extends CoordinatorLayout.Behavior&lt;RecyclerView&gt; &#123;</span><br><span class="line">    public <span class="constructor">ScrollerBehavior()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">ScrollerBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull RecyclerView <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof TextView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull RecyclerView <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">child</span>,<span class="params">dependency</span>.<span class="params">getBottom</span>()</span>-child.get<span class="constructor">Top()</span>);</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面demo其实是对前面提到的嵌套滑动方法的实践。而这个例子才是对依赖与被依赖组件关系的效果展示，红色方块是被依赖方，而“跟随兄弟”和变色兄弟都是依赖方，会根据红色方块的位置变化而变化。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_15_09_45_364.gif" alt="录制_2022_08_06_15_09_45_364"></p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">public <span class="keyword">class</span> DependedView extends View &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mLastX;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> mLastY;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> mDragSlop;</span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, <span class="params">int</span> <span class="params">mDragSlop</span>)</span> &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.mDragSlop = mDragSlop;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, @Nullable AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="constructor">DependedView(Context <span class="params">context</span>, @Nullable AttributeSet <span class="params">attrs</span>, <span class="params">int</span> <span class="params">defStyleAttr</span>)</span> &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        mDragSlop = <span class="module-access"><span class="module"><span class="identifier">ViewConfiguration</span>.</span></span>get(context).get<span class="constructor">ScaledTouchSlop()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">TouchEvent(MotionEvent <span class="params">event</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> action = event.get<span class="constructor">Action()</span>;</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mLastX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                mLastY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="built_in">int</span> dx = (<span class="built_in">int</span>) (event.get<span class="constructor">X()</span> - mLastX);</span><br><span class="line">                <span class="built_in">int</span> dy = (<span class="built_in">int</span>) (event.get<span class="constructor">Y()</span> - mLastY);</span><br><span class="line">                <span class="keyword">if</span> (<span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs(dx) &gt; mDragSlop<span class="operator"> || </span><span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>abs(dy) &gt; mDragSlop) &#123;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">TopAndBottom(<span class="params">this</span>, <span class="params">dy</span>)</span>;</span><br><span class="line">                    <span class="module-access"><span class="module"><span class="identifier">ViewCompat</span>.</span></span>offset<span class="constructor">LeftAndRight(<span class="params">this</span>, <span class="params">dx</span>)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mLastX = event.get<span class="constructor">X()</span>;</span><br><span class="line">                mLastY = event.get<span class="constructor">Y()</span>;</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> BrotherChameleonBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> ArgbEvaluator mArgbEvaluator = <span class="keyword">new</span> <span class="constructor">ArgbEvaluator()</span>;</span><br><span class="line">    public <span class="constructor">BrotherChameleonBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull View <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof DependedView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(@NonNull CoordinatorLayout <span class="params">parent</span>, @NonNull View <span class="params">child</span>, @NonNull View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> color = (<span class="built_in">int</span>)mArgbEvaluator.evaluate(dependency.get<span class="constructor">Y()</span>/parent.get<span class="constructor">Height()</span>, Color.WHITE,Color.BLACK);</span><br><span class="line">        child.set<span class="constructor">BackgroundColor(<span class="params">color</span>)</span>;</span><br><span class="line">        return <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">------------------------------------------------------------------------------------------------------------</span><br><span class="line">public <span class="keyword">class</span> BrotherFollowBehavior extends CoordinatorLayout.Behavior&lt;View&gt; &#123;</span><br><span class="line">    public <span class="constructor">BrotherFollowBehavior(Context <span class="params">context</span>, AttributeSet <span class="params">attrs</span>)</span> &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean layout<span class="constructor">DependsOn(CoordinatorLayout <span class="params">parent</span>, View <span class="params">child</span>, View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        return dependency instanceof DependedView;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean on<span class="constructor">DependentViewChanged(CoordinatorLayout <span class="params">parent</span>, View <span class="params">child</span>, View <span class="params">dependency</span>)</span> &#123;</span><br><span class="line">        child.set<span class="constructor">Y(<span class="params">dependency</span>.<span class="params">getBottom</span>()</span> + <span class="number">50</span>);</span><br><span class="line">        child.set<span class="constructor">X(<span class="params">dependency</span>.<span class="params">getX</span>()</span>);</span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用好Behavior对我们做好看的UI效果有很大的帮助，毕竟NestedScrollParent和NestedScrollChild也只能实现两个组件之间的嵌套关系，而Behavior能够实现一对多的嵌套关系。这节内容主要是对CoordinatorLayout的介绍以及只是对自定义Behavior的浅尝试，后面小编将写一篇真正意义的自定义Behavior的Demo介绍与实现。</p><p><a href="https://github.com/gun-ctrl/CoordanatorLayout">代码链接</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CoordinatorLayout的功能&quot;&gt;&lt;a href=&quot;#CoordinatorLayout的功能&quot; class=&quot;headerlink&quot; title=&quot;CoordinatorLayout的功能&quot;&gt;&lt;/a&gt;CoordinatorLayout的功能&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
  </entry>
  
  <entry>
    <title>NestedScrollView嵌套滑动原理</title>
    <link href="https://gun-ctrl.github.io/2022/08/06/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>https://gun-ctrl.github.io/2022/08/06/NestedScrollView%E5%B5%8C%E5%A5%97%E6%BB%91%E5%8A%A8%E5%8E%9F%E7%90%86/</id>
    <published>2022-08-06T06:51:46.243Z</published>
    <updated>2022-08-14T04:19:44.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="事件分发机制简介"><a href="#事件分发机制简介" class="headerlink" title="事件分发机制简介"></a>事件分发机制简介</h2><p>其实小编应该在前面准备一章关于Android的事件分发和处理机制的专题，因为时间原因和内容源码比较多吧(小编有强迫症，不想不贴源码)，不过还是因为小编懒，哈哈。这里就对事件分发机制做一个简单的回忆，大家感兴趣的可以去看看相关资料和源码，小编后面有空也会出一期。</p><p>这里介绍一位优秀博主的博客，大家可以看这篇文章对事件分发机制与滑动冲突、以及解决方案有个全面的了解：</p><p><a href="https://wiwiyiyi.com/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E7%9A%84%E5%A4%84%E7%90%86.html">事件分发机制以及滑动冲突的处理</a></p><p>下面对事件分发与处理做一个简单总结</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806150250279.png" alt="image-20220806150250279"></p><p>关键的一点大家需要记住：事件的分发是由上层到底层，而事件的处理是由底层到上层。</p><ul><li>也就是说父View可以拦截触摸事件直接消费，而不传递给子View。</li><li>子View可以处理事件，也可以选择给父类消费。</li><li>ViewGroup既可以消费事件，也可以分发事件</li><li>View只能处理事件，也就是消费。</li></ul><h4 id="View滑动冲突"><a href="#View滑动冲突" class="headerlink" title="View滑动冲突"></a>View滑动冲突</h4><ol><li>外部滑动方向与内部滑动方向不一致</li></ol><blockquote><p>解决方案：外部拦截法，当事件传递到父View时，父View需要处理此事件，就拦截，不处理此事件就不拦截</p></blockquote><ol start="2"><li>外部滑动方向与内部滑动方向一致；</li></ol><blockquote><p>内部拦截法，当事件传递到父View时，父View都传递给子View，如果子View需要处理此事件就消耗掉，否则就交给父View处理。但是这种方法和Android事件分发不一致，需要配合 requestDisallowInterceptTouchEvent 方法才能正常工作</p></blockquote><ol start="3"><li>上面两种情况的嵌套。</li></ol><blockquote><p>某个View一旦决定拦截，那么这一个事件序列都只能由它来处理，并且它的onInterceptTouchEvent不会再被调用<br>解决方案： 解决这种滑动冲突，可以用NestedScrollingParent 和 NestedScrollingChild 来解决</p></blockquote><h2 id="分析NestedScrollView机制"><a href="#分析NestedScrollView机制" class="headerlink" title="分析NestedScrollView机制"></a>分析NestedScrollView机制</h2><blockquote><p>NestedScrollView和ScrollView类似，是一个支持滚动的控件。此外，它还同时支持作NestedScrollingParent或者NestedScrollingChild进行嵌套滚动操作。默认是启用嵌套滚动的</p></blockquote><p>首先介绍两个重要接口</p><p>1.NestedScrollingParent</p><p>当可滑动的ViewGroup充当父View时实现该接口</p><p>2.NestedScrollingChild</p><p>当可滑动的ViewGroup充当子View时实现该接口</p><blockquote><p>我们所熟知的RecyclerView就对上面两个接口都进行了实现，所以它才能完美的处理滑动与点击item之间的关系，同时RecyclerView还支持惯性滑动（快速滑-&gt;手指松开-&gt;滑动一段距离停下），这都是上面两个接口中封装的方法的功劳。小编后面展示的demo就比较拉了，没有实现惯性滑动效果，别问！问就是因为懒。</p></blockquote><h4 id="整个事件流程"><a href="#整个事件流程" class="headerlink" title="整个事件流程"></a>整个事件流程</h4><p>这张图还是很清晰的展示了从点击-&gt;滑动-&gt;松开的方法调用过程</p><p>NestedScrollingChildHelper、NestedScrollingParentHelper是Google提供的帮助类，其内部是去调用ViewCompat中的方法调用（xxxCompat都是兼容处理），也就是说很多操作都可以由helper帮我们完成，对于小编这种懒人还是很友好的。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806160049703.png" alt="image-20220806160049703"></p><p>下面对方法进行介绍：</p><ul><li><p><strong>onStartNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View directTargetChild, @NonNull View target, int axes, int type)</strong> 当用户手指按下的时候，你是否要处理这次操作。当你确定要处理这次操作的时候，返回true；如果返回false的时候，就不会去响应后面的回调事件了。你想怎么滑就怎么话，我都不做处理。这里的(axes)滚动方向很重要，可以通过此参数判断滚动方向！</p><ul><li><p>参数3：直接目标，相当于能滑动的控件</p></li><li><p>参数4：观察的View</p></li><li><p>参数5：这个可以简单理解为滚动方向</p><ul><li>ViewCompat#SCROLL_AXIS_HORIZONTAL 水平方向</li><li>ViewCompat#SCROLL_AXIS_VERTICAL 竖直方向</li></ul></li><li><p>参数6：这个参数是之后有的，如果你输入的类型不是TYPE_TOUCH那么就不会相应这个滚动</p></li></ul></li><li><p><strong>onNestedScrollAccepted(@NonNull CoordinatorLayout coordinatorLayout, @NonNull V child, @NonNull View directTargetChild, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type)</strong> 当onStartNestedScroll准备处理这次滑动的时候(返回true的时候)，回调这个方法。可以在这个方法中做一些响应的准备工作！</p></li><li><p><strong>onNestedPreScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type)</strong> 当滚动开始执行的时候回调这个方法。</p><ul><li>参数4&#x2F;参数5：用户x&#x2F;y轴滚动的距离(注意这里是每一次都回调的啊！！！)</li><li>参数6：处理滚动的距离的参数，内部维护着输出距离，假设用户滑动了100px,child 做了90px的位移，你需要把consumed［1］的值改成90，这样coordinatorLayout就能知道只处理剩下的10px的滚动。其中consumed[0]代表x轴、consumed[1]代表y轴。可能你不理解这个问题，换个形象点的比喻，比如你开发某一个功能，但是你只会其中的90%那么怎么办呢？不能就不管了。好你找到了你的同事或者老大，让他去完成剩下的10%。这样问题就完美的解决了，是一个概念的！</li></ul></li><li><p><strong>onNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, int type)</strong> 上面这个方法结束的时候，coordinatorLayout处理剩下的距离，比如还剩10px。但是coordinatorLayout发现滚动2px的时候就已经到头了。那么结束其滚动，调用该方法，并将coordinatorLayout处理剩下的像素数作为参<code>(dxUnconsumed、dyUnconsumed)</code>传过来，这里传过来的就是 8px。参数中还会有coordinatorLayout处理过的像素数（dxConsumed、dyConsumed）。老大开始处理剩下的距离了！这个方法主要处理一些越界后的滚动。还是不懂对吧！还拿你们老大做比喻：比如上面还剩 10%的工作，这时老大处理了2%后发现已经可以上线了，于是老大结束了工作，并将处理剩下的内容（dxUnconsumed、dyUnconsumed）纪录下来，告诉你。老大处理了的内容（dxConsumed、dyConsumed）也告诉了你。</p><ul><li>参数4&#x2F;参数5：当没有滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li><li>参数6&#x2F;参数7：当滚动到顶部或者底部的时候，x&#x2F;y轴的滚动距离</li></ul></li><li><p>onNestedPreFling(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, float velocityX, float velocityY) 当手指松开发生惯性动作之前调用，这里提供了响应的速度，你可以根据速度判断是否需要进行折叠等一系列的操作，你要确定响应这个方法的话，返回true。</p><ul><li>参数4&#x2F;参数5：代表相应的速度</li></ul></li><li><p>onStopNestedScroll(@NonNull CoordinatorLayout coordinatorLayout, @NonNull View child, @NonNull View target, int type) 停止滚动的时候回调的方法。当你不去响应Fling的时候会直接回调这个方法。在这里可以做一些清理工作。或者其他的内容。</p></li></ul><p><strong>再来看看两个接口的源码</strong></p><p>1.NestedScrollingChild</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启用或禁用嵌套滚动的方法，设置为true，并且当前界面的View的层次结构是支持嵌套滚动的</span></span><br><span class="line"><span class="comment">    * (也就是需要NestedScrollingParent嵌套NestedScrollingChild)，才会触发嵌套滚动。</span></span><br><span class="line"><span class="comment">    * 一般这个方法内部都是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setNestedScrollingEnabled</span><span class="params">(<span class="type">boolean</span> enabled)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前View是否支持嵌套滑动。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNestedScrollingEnabled</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 表示view开始滚动了,一般是在ACTION_DOWN中调用，如果返回true则表示父布局支持嵌套滚动。</span></span><br><span class="line"><span class="comment">    * 一般也是直接代理给NestedScrollingChildHelper的同名方法即可。这个时候正常情况会触发Parent的onStartNestedScroll()方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="type">int</span> axes)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 一般是在事件结束比如ACTION_UP或者ACTION_CANCLE中调用,告诉父布局滚动结束。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 判断当前View是否有嵌套滑动的Parent。一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View消费滚动距离之后。通过调用该方法，把剩下的滚动距离传给父布局。如果当前没有发生嵌套滚动，或者不支持嵌套滚动，调用该方法也没啥用。</span></span><br><span class="line"><span class="comment">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">    * dxConsumed：被当前View消费了的水平方向滑动距离</span></span><br><span class="line"><span class="comment">    * dyConsumed：被当前View消费了的垂直方向滑动距离</span></span><br><span class="line"><span class="comment">    * dxUnconsumed：未被消费的水平滑动距离</span></span><br><span class="line"><span class="comment">    * dyUnconsumed：未被消费的垂直滑动距离</span></span><br><span class="line"><span class="comment">    * offsetInWindow：输出可选参数。如果不是null，该方法完成返回时，</span></span><br><span class="line"><span class="comment">    * 会将该视图从该操作之前到该操作完成之后的本地视图坐标中的偏移量封装进该参数中，offsetInWindow[0]水平方向，offsetInWindow[1]垂直方向</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true：表示滚动事件分发成功,fasle: 分发失败</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View消费滚动距离之前把滑动距离传给父布局。相当于把优先处理权交给Parent</span></span><br><span class="line"><span class="comment">    * 内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可。</span></span><br><span class="line"><span class="comment">* dx：当前水平方向滑动的距离</span></span><br><span class="line"><span class="comment">* dy：当前垂直方向滑动的距离</span></span><br><span class="line"><span class="comment">* consumed：输出参数，会将Parent消费掉的距离封装进该参数consumed[0]代表水平方向，consumed[1]代表垂直方向</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true：代表Parent消费了滚动距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@Nullable</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *将惯性滑动的速度分发给Parent。内部一般也是直接代理给NestedScrollingChildHelper的同名方法即可</span></span><br><span class="line"><span class="comment">* velocityX：表示水平滑动速度</span></span><br><span class="line"><span class="comment">* velocityY：垂直滑动速度</span></span><br><span class="line"><span class="comment">* consumed：true：表示当前View消费了滑动事件，否则传入false</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> true：表示Parent处理了滑动事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY, <span class="type">boolean</span> consumed)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在当前View自己处理惯性滑动前，先将滑动事件分发给Parent,一般来说如果想自己处理惯性的滑动事件，</span></span><br><span class="line"><span class="comment">    * 就不应该调用该方法给Parent处理。如果给了Parent并且返回true，那表示Parent已经处理了，自己就不应该再做处理。</span></span><br><span class="line"><span class="comment">    * 返回false，代表Parent没有处理，但是不代表Parent后面就不用处理了</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true：表示Parent处理了滑动事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreFling</span><span class="params">(<span class="type">float</span> velocityX, <span class="type">float</span> velocityY)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild2</span> <span class="keyword">extends</span> <span class="title class_">NestedScrollingChild</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">startNestedScroll</span><span class="params">(<span class="meta">@ScrollAxis</span> <span class="type">int</span> axes, <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stopNestedScroll</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNestedScrollingParent</span><span class="params">(<span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed, <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow,</span></span><br><span class="line"><span class="params">            <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dispatchNestedPreScroll</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy, <span class="meta">@Nullable</span> <span class="type">int</span>[] consumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow, <span class="meta">@NestedScrollType</span> <span class="type">int</span> type)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">NestedScrollingChild3</span> <span class="keyword">extends</span> <span class="title class_">NestedScrollingChild2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dispatchNestedScroll</span><span class="params">(<span class="type">int</span> dxConsumed, <span class="type">int</span> dyConsumed, <span class="type">int</span> dxUnconsumed, <span class="type">int</span> dyUnconsumed,</span></span><br><span class="line"><span class="params">            <span class="meta">@Nullable</span> <span class="type">int</span>[] offsetInWindow, <span class="meta">@ViewCompat</span>.NestedScrollType <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">            <span class="meta">@NonNull</span> <span class="type">int</span>[] consumed)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.NestedScrollingParent</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当NestedScrollingChild调用方法startNestedScroll()时,会调用该方法。主要就是通过返回值告诉系统是否需要对后续的滚动进行处理</span></span><br><span class="line"><span class="comment">    * child：该ViewParen的包含NestedScrollingChild的直接子View，如果只有一层嵌套，和target是同一个View</span></span><br><span class="line"><span class="comment">    * target：本次嵌套滚动的NestedScrollingChild</span></span><br><span class="line"><span class="comment">    * nestedScrollAxes：滚动方向</span></span><br><span class="line"><span class="comment">    * @return </span></span><br><span class="line"><span class="comment">    * true:表示我需要进行处理，后续的滚动会触发相应的回到</span></span><br><span class="line"><span class="comment">    * false: 我不需要处理，后面也就不会进行相应的回调了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//child和target的区别，如果是嵌套两层如:Parent包含一个LinearLayout，LinearLayout里面才是NestedScrollingChild类型的View。这个时候，</span></span><br><span class="line">    <span class="comment">//child指向LinearLayout，target指向NestedScrollingChild；如果Parent直接就包含了NestedScrollingChild，</span></span><br><span class="line">    <span class="comment">//这个时候target和child都指向NestedScrollingChild</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onStartNestedScroll</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果onStartNestedScroll()方法返回的是true的话,那么紧接着就会调用该方法.它是让嵌套滚动在开始滚动之前,</span></span><br><span class="line"><span class="comment">    * 让布局容器(viewGroup)或者它的父类执行一些配置的初始化的</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScrollAccepted</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 停止滚动了,当子view调用stopNestedScroll()时会调用该方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onStopNestedScroll</span>(<span class="variable">@NonNull</span> View target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当子view调用dispatchNestedScroll()方法时,会调用该方法。也就是开始分发处理嵌套滑动了</span></span><br><span class="line"><span class="comment">    * dxConsumed：已经被target消费掉的水平方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dyConsumed：已经被target消费掉的垂直方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dxUnconsumed：未被tagert消费掉的水平方向的滑动距离</span></span><br><span class="line"><span class="comment">    * dyUnconsumed：未被tagert消费掉的垂直方向的滑动距离</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当子view调用dispatchNestedPreScroll()方法是,会调用该方法。也就是在NestedScrollingChild在处理滑动之前，</span></span><br><span class="line"><span class="comment">    * 会先将机会给Parent处理。如果Parent想先消费部分滚动距离，将消费的距离放入consumed</span></span><br><span class="line"><span class="comment">    * dx：水平滑动距离</span></span><br><span class="line"><span class="comment">    * dy：处置滑动距离</span></span><br><span class="line"><span class="comment">    * consumed：表示Parent要消费的滚动距离,consumed[0]和consumed[1]分别表示父布局在x和y方向上消费的距离.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedPreScroll</span>(<span class="variable">@NonNull</span> View target, int dx, int dy, <span class="variable">@NonNull</span> int[] consumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 你可以捕获对内部NestedScrollingChild的fling事件</span></span><br><span class="line"><span class="comment">    * velocityX：水平方向的滑动速度</span></span><br><span class="line"><span class="comment">    * velocityY：垂直方向的滑动速度</span></span><br><span class="line"><span class="comment">    * consumed：是否被child消费了</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * true:则表示消费了滑动事件</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onNestedFling</span>(<span class="variable">@NonNull</span> View target, float velocityX, float velocityY, boolean consumed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在惯性滑动距离处理之前，会调用该方法，同onNestedPreScroll()一样，也是给Parent优先处理的权利</span></span><br><span class="line"><span class="comment">    * target：本次嵌套滚动的NestedScrollingChild</span></span><br><span class="line"><span class="comment">    * velocityX：水平方向的滑动速度</span></span><br><span class="line"><span class="comment">    * velocityY：垂直方向的滑动速度</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    * true：表示Parent要处理本次滑动事件，Child就不要处理了</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onNestedPreFling</span>(<span class="variable">@NonNull</span> View target, float velocityX, float velocityY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 返回当前滑动的方向，一般直接通过NestedScrollingParentHelper.getNestedScrollAxes()返回即可</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    @<span class="selector-tag">ScrollAxis</span></span><br><span class="line">    <span class="selector-tag">int</span> <span class="selector-tag">getNestedScrollAxes</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent2</span> <span class="selector-tag">extends</span> <span class="selector-tag">NestedScrollingParent</span> &#123;</span><br><span class="line">    <span class="selector-tag">boolean</span> <span class="selector-tag">onStartNestedScroll</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScrollAccepted</span>(<span class="variable">@NonNull</span> View child, <span class="variable">@NonNull</span> View target, <span class="variable">@ScrollAxis</span> int axes,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onStopNestedScroll</span>(<span class="variable">@NonNull</span> View target, <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed,</span><br><span class="line">            int dxUnconsumed, int dyUnconsumed, <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedPreScroll</span>(<span class="variable">@NonNull</span> View target, int dx, int dy, <span class="variable">@NonNull</span> int[] consumed,</span><br><span class="line">            <span class="variable">@NestedScrollType</span> int type);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">NestedScrollingParent3</span> <span class="selector-tag">extends</span> <span class="selector-tag">NestedScrollingParent2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">onNestedScroll</span>(<span class="variable">@NonNull</span> View target, int dxConsumed, int dyConsumed, int dxUnconsumed,</span><br><span class="line">            int dyUnconsumed, <span class="variable">@ViewCompat</span>.NestedScrollType int type, <span class="variable">@NonNull</span> int[] consumed);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>在那之前再补一张较全的事件流程图，还包括传值的过程欧，结合demo代码看也不错。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806164857678.png" alt="image-20220806164857678"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806164945258.png" alt="image-20220806164945258"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806165039684.png" alt="image-20220806165039684"></p><p>效果演示</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%BD%95%E5%88%B6_2022_08_06_16_21_53_330.gif" alt="录制_2022_08_06_16_21_53_330"></p><p>这里就不贴大量代码了，展示一些主要代码，详情可见文章下方的全部代码</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806163510871.png" alt="image-20220806163510871"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220806163541253.png" alt="image-20220806163541253"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只要对NestedScrollView的嵌套滑动机制过程掌握，利用NestedScrollingParent、NestedScrollingChild这两个接口可以很轻松的实现自定义嵌套滑动机制，当然也可以直接通过继承自定义NestedScrollView实现一些炫酷的滑动、吸顶效果，这种效果在现在的电商平台还是很常见的。当然仅仅利用NestedScrollingParent、NestedScrollingChild实现嵌套还是有局限，只能一对一，要想实现一对多的嵌套滑动那就需要Behavior，下一章将会初步接触。</p><p><a href="https://github.com/gun-ctrl/NestedScrollViewTry">全部代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;事件分发机制简介&quot;&gt;&lt;a href=&quot;#事件分发机制简介&quot; class=&quot;headerlink&quot; title=&quot;事件分发机制简介&quot;&gt;&lt;/a&gt;事件分发机制简介&lt;/h2&gt;&lt;p&gt;其实小编应该在前面准备一章关于Android的事件分发和处理机制的专题，因为时间原因和内容源</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解并发编程和归纳总结</title>
    <link href="https://gun-ctrl.github.io/2022/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
    <id>https://gun-ctrl.github.io/2022/08/02/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/</id>
    <published>2022-08-02T13:27:56.968Z</published>
    <updated>2022-08-31T12:23:22.163Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>AbstractQueueSynchronizer（抽象队列同步器）</p><blockquote><p>是用来构建锁和其他同步组件的基础架构，比如ReentrantLock、ReetrantReadWriteLock和CountDownLatch就是基于<strong>AQS</strong>实现的。它使用一个<strong>int成员变量state</strong>标识同步状态，通过<strong>内置的FIFO（队列）</strong>来完成获取资源线程的排队工作。它是<strong>CLH队列锁</strong>的一种变体实现。它可以实现两种同步方式：<strong>独占式、共享式</strong>。<br>AQS的主要使用方式是<strong>继承</strong>，子类通过继承AQS并实现它的抽象方式来管理同步状态，同步器的设计基于<strong>模板方法模式</strong>，所以如果要实现我们自己的同步工具类就需要其中几个可重写的方法，如tryAcquire、tryRelease、tryReleaseShared等等。<br>这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者和同步组件交互的接口（比如可以允许两个线程并访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者锁需关注的领域。<br>在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node节点组成，每个Node节点维护一个pre引用和next引用，分别指向自己的前序和后继，构成一个双端双向链表。同时与Condition相关的等待队列，节点类型也是Node，构成了一个单向链表。</p></blockquote><h3 id="AQS两种资源共享方式"><a href="#AQS两种资源共享方式" class="headerlink" title="AQS两种资源共享方式"></a>AQS两种资源共享方式</h3><blockquote><p>1.Exclusive-&gt;独占，只有一个线程能执行，如ReentrantLock<br>2.Share-&gt;共享，多个线程可同时执行，如Semaphore&#x2F;CountDownLatch</p></blockquote><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取和释放方式即可。<br>同步器实现时主要实现以下几种方法：</p><ul><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回true。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回true。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源；负数表示失败；0表示成功，但没有剩余可用价值；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待节点返回true，否则返回false。</li><li>isHeldExclusively：该线程是否正在独占资源。只有用到condition才需要去实现它。</li></ul><h3 id="AQS重要源码预览"><a href="#AQS重要源码预览" class="headerlink" title="AQS重要源码预览"></a>AQS重要源码预览</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-da79f4c3871c7ae2.png" alt="image.png"><br>重要的参数state<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-7190ae966401c75e.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-03623aff31014070.png"></p><h3 id="Lock源码"><a href="#Lock源码" class="headerlink" title="Lock源码"></a>Lock源码</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-3e3ff9955721d761.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-1be98e4491920a17.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-e9d62d55bb74cbb1.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f7e7517cfb30bedd.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-11784af71e5884ab.png" alt="image.png"><br>独占式的<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-640b8294babb722a.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-1b58a042fb32d5f4.png" alt="image.png"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-770b3ddbb30dadc6.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-18298cccb10b1a98.png" alt="image.png"></p><h3 id="AQS的基本思想CLH队列锁"><a href="#AQS的基本思想CLH队列锁" class="headerlink" title="AQS的基本思想CLH队列锁"></a>AQS的基本思想CLH队列锁</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f140f50743caa711.png" alt="image.png"><br>CLH队列锁<br>1.基于链表的自旋锁<br>2.想要获得锁，通过CAS操作将QNode挂在链表的尾部<br>3.每个QNode都在自选检查（有自旋次数限制，超过后当前线程将进入阻塞状态）myPred是否释放锁<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-7e4d05b64b6da0fc.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-8bd85142d512b8e4.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-132f27aec922be32.png" alt="image.png"></p><h3 id="公平锁和非公平锁的介绍"><a href="#公平锁和非公平锁的介绍" class="headerlink" title="公平锁和非公平锁的介绍"></a>公平锁和非公平锁的介绍</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-e2c897782e4989c2.png" alt="image.png"><br><strong>唯一的区别</strong><br>公平锁中会判断队列中是都有线程在等待<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c3a61725c039fbaf.png" alt="image.png"></p><h3 id="锁的可重入"><a href="#锁的可重入" class="headerlink" title="锁的可重入"></a>锁的可重入</h3><p>我们再回头看看Lock的实现<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-951a38ede7375e8c.png" alt="image.png"><br>什么时候需要锁的可重入？</p><blockquote><p>当我们需要再次进入该方法时</p></blockquote><p>实现锁的可重入，否则会自己锁住自己<br>获取锁的时候state+1，释放锁的时候state-1<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-4275dadf72404056.png" alt="image.png"></p><h2 id="浅谈JMM"><a href="#浅谈JMM" class="headerlink" title="浅谈JMM"></a>浅谈JMM</h2><p>计算机在执行程序时，每条指令都是在CPU中执行的。而执行指令的过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程，跟CPU执行指令的速度比起来要慢的多（硬盘 &lt; 内存 &lt;缓存cache &lt; CPU）。因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。也就是当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时，就可以直接从它的高速缓存中读取数据或向其写入数据了。当运算结束之后，再将高速缓存中的数据刷新到主存当中。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-b6a863238dfba07d.png" alt="image.png"><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-8540ad83e80cd995.png" alt="image.png"><br>线程不允许直接访问主内存，工作内存之间相互独立（类似于ThreadLocal），工作内存中存主内存变量的副本。<br>但是如此构建会带来数据同步方面的问题。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c039220a121a78ba.png" alt="image.png"></p><p>其实，JMM具可见性、原子性、有序性，那么这是怎么实现的呢？</p><ul><li>volatile关键字 使变量保持可见性</li><li>synchronized关键字 为操作加锁（只是用synchronized同样能保证安全）</li><li>一个线程写，多个线程读，使用volatile是OK的。</li></ul><h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><ul><li>可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li><li>原子性：对任意单个volatile变量的读&#x2F;写具有原子性，但类似count++这种复合操作不具有原子性。</li><li>volatile还能防止指令重排序 关于流水线和重排序 intel十级流水线 比如下例可以先算t&#x3D;b再执行if，提高性能。 但是在多线程中可能会引发多线程安全问题，所以volatile的抑制重排序就有了作用，<strong>如在DCL （双重检测锁定）中的作用？-&gt;防止指令重排序</strong><br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-47b7059195083d75.png" alt="image.png"></li></ul><h4 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h4><p><strong>有volatile变量修饰的共享变量进行写操作的时候会使用CPU提供的Lock前缀指令</strong></p><ul><li>将当前处理器缓存行的数据写回系统内存</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。</li></ul><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><blockquote><p>相信大家都用过synchronized，特别是单例设计模式中很常见</p></blockquote><p>原理：使用monitorenter和monitorexit指令实现的</p><ul><li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处</li><li>每个monitorenter必须有对应的monitorexit与之匹配</li><li>任何对象都有一个monitor与之关联<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-d1cb75d005ce1c3c.png" alt="image.png"></li></ul><h3 id="synchronized做了哪些优化"><a href="#synchronized做了哪些优化" class="headerlink" title="synchronized做了哪些优化"></a>synchronized做了哪些优化</h3><p><strong>锁消除：</strong>和逃逸分析比较紧密，如果在编译过程中发现某个代码块不会发生共享数据竞争，那么就会取消锁。<br><strong>锁粗化：</strong>如下图所示，未被加锁的代码块会被包裹进synchronized，减少线程上下文切换带来的开销。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-a7e0b1c2cdb2ed9a.png" alt="image.png"><br><strong>逃逸分析：</strong>发现加锁的对象只在某个方法内部，对变量做一些相关优化</p><p><strong>主要部分：</strong><br>我们来了解锁的四种状态</p><ul><li>无锁状态</li><li>偏向锁状态</li><li>轻量级锁状态</li><li>重量级锁状态</li></ul><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>大多数情况下，锁不存在多线程竞争，而且总是由同一线程多次获得，为了让锁的代价更低而引入了偏向锁。无锁竞争时不需要进行CAS操作来加锁和释放锁。<br>第一次还是需要CAS完成Mark Word的替换 替换如下信息<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-beb559b4194aa99a.png" alt="image.png"></p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-fea657efece4ab97.png" alt="image.png"><br>如果发生锁的竞争，线程2会先stop the world，然后更改线程1的信息（由偏向锁升级为轻量级锁），这就导致性能降低。这就需要禁止偏向锁。<br>轻量级锁会自旋，当自旋到一定次数后就会发生膨胀，膨胀为重量级锁。</p><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><table><thead><tr><th>锁</th><th align="left">优点</th><th align="left">缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td align="left">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td align="left">如果线程间存在竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td align="left">竞争的线程不会阻塞，提高了程序的响应速度。</td><td align="left">如果始终得不到锁竞争的线程使用自旋会消耗CPU 追求响应时间。</td><td>同步块执行速度非常快。</td></tr><tr><td>重量级</td><td align="left">线程竞争不使用自旋，不会消耗CPU。</td><td align="left">线程阻塞，响应时间满。</td><td>追求吞吐量。同步块执行速度较快。</td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="synchronized修饰普通方法和静态方法的区别？什么是可见性？"><a href="#synchronized修饰普通方法和静态方法的区别？什么是可见性？" class="headerlink" title="synchronized修饰普通方法和静态方法的区别？什么是可见性？"></a>synchronized修饰普通方法和静态方法的区别？什么是可见性？</h3><ul><li>锁的对象实例<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-dcaa4928eb8e2b28.png" alt="image.png"></li><li>锁的当前类唯一的.class对象 -&gt;类锁<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654312536892.png" alt="1654312536892"></li><li>假如有两个线程分别执行上面各个方法，可以同时执行，拿的不是同一个对象锁。</li><li>注意：加锁加的是对象锁，只要不是同一个对象锁，并行执行就不会有问题。</li></ul><h3 id="单例模式中的懒汉式-延迟初始化占位类模式"><a href="#单例模式中的懒汉式-延迟初始化占位类模式" class="headerlink" title="单例模式中的懒汉式-延迟初始化占位类模式"></a>单例模式中的懒汉式-延迟初始化占位类模式</h3><p>为什么饿汉式与延迟占位类模式是线程安全的？</p><blockquote><p>这是由类加载机制所保证的，一个类加载只会在虚拟机中执行一次，所以虚拟机为了保证执行性一次在类加载过程中已经实现了线程安全。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-03623aff31014070.png" alt="image.png"></p></blockquote><h3 id="什么是守护线程？你是如何退出一个线程的？"><a href="#什么是守护线程？你是如何退出一个线程的？" class="headerlink" title="什么是守护线程？你是如何退出一个线程的？"></a>什么是守护线程？你是如何退出一个线程的？</h3><p>守护（Daemon）线程是一种支持性线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-c9bb6c9482992aac.png" alt="image.png"><br>线程的停止：</p><ul><li>run方法执行完成</li><li>执行过程中出现异常，终止</li><li>不建议使用stop方法，不安全（不考虑线程当前的执行状态直接结束）</li><li>interrupt，协议机制 ，被中断的线程内部方法isInterrupted()或Thread.interrupted()判断线程是否进行中断。</li></ul><h3 id="sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）"><a href="#sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）" class="headerlink" title="sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）"></a>sleep、wait、yield的区别，wait的线程如何唤醒它？（notify，notifyAll）</h3><ul><li>yield方法让出CPU的执行权，什么时候拿回来由操作系统决定。（让出CPU的执行权）</li><li>sleep让当前线程 进行休眠，（通常用于暂停线程的执行）</li><li>wait让当前线程等待，这三者只有wait方法会释放锁，唤醒后重新竞争锁。（主要用于线程之间的交互）</li></ul><h3 id="sleep是可中断的吗？"><a href="#sleep是可中断的吗？" class="headerlink" title="sleep是可中断的吗？"></a>sleep是可中断的吗？</h3><p>是，调用Thread.sleep()会抛出一个中断异常，说明是可以中断的。</p><h3 id="有三个线程T1、T2、T3，怎么确保它们按顺序执行？"><a href="#有三个线程T1、T2、T3，怎么确保它们按顺序执行？" class="headerlink" title="有三个线程T1、T2、T3，怎么确保它们按顺序执行？"></a>有三个线程T1、T2、T3，怎么确保它们按顺序执行？</h3><p>加入执行顺序：T1-&gt;T2-&gt;T3<br>T3方法中T2.join()<br>T2方法中T1.join()</p><h3 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h3><ul><li>sleep和wait都可设置时间</li><li>只有synchronized才会使线程进入阻塞态</li><li>Lock进入等待或超时等待态</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-77d154ac11d5e97c.png" alt="image.png"></p><h3 id="手写死锁"><a href="#手写死锁" class="headerlink" title="手写死锁"></a>手写死锁</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-836114f93d4bea42.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;AQS&quot;&gt;&lt;a href=&quot;#AQS&quot; class=&quot;headerlink&quot; title=&quot;AQS&quot;&gt;&lt;/a&gt;AQS&lt;/h2&gt;&lt;h3 id=&quot;什么是AQS&quot;&gt;&lt;a href=&quot;#什么是AQS&quot; class=&quot;headerlink&quot; title=&quot;什么是AQS&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java筑基" scheme="https://gun-ctrl.github.io/categories/Java%E7%AD%91%E5%9F%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>阻塞队列与线程池机制</title>
    <link href="https://gun-ctrl.github.io/2022/07/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6/"/>
    <id>https://gun-ctrl.github.io/2022/07/30/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%BA%E5%88%B6/</id>
    <published>2022-07-30T12:58:23.730Z</published>
    <updated>2022-07-31T03:58:50.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建线程的方式"><a href="#创建线程的方式" class="headerlink" title="创建线程的方式"></a>创建线程的方式</h2><ul><li>1.Thread</li><li>2.Runnable（实例化接口，重新run方法，放入Thread中执行）</li></ul><p>为什么Callable方式不算?</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148325145.png" alt="1654148325145"></p><blockquote><p>首先，我们都知道创建线程都需要通过Thread，那么我们来看一下Thread的构造函数</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148402777.png" alt="1654148402777"></p><p>可以看到，Thread构造函数中压根就没有Callable类型的参数</p><p>接着，我们再来看看Callable，Callable是继承自FutureTask</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148426071.png" alt="1654148426071"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654148455965.png" alt="1654148455965"></p><p>通过上面的源码截图，我们可以看出来Callable本质上还是Runnable的一种实现</p></blockquote><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p><strong>Compare And Swap</strong></p><blockquote><p>提及CAS之前，我们先来提一下原子操作，原子操作就是一气呵成，中间不能被打断，学过操作系统的朋友应该和熟悉，没错，就类似于操作系统中的中断原语。</p></blockquote><h3 id="CAS原理"><a href="#CAS原理" class="headerlink" title="CAS原理"></a>CAS原理</h3><p>利用了现代处理器都支持的CAS的指令，循环这个指令，直到成功为止。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220730211300257.png" alt="image-20220730211300257"></p><blockquote><p>会有两个重要的属性变量，旧值与新值（需要更改的值），每次进入前都会用旧值与内存中的变量值进行比较，如果相同，就会用新值替换内存中的变量值，否则将再次循环上述过程。</p></blockquote><h3 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><strong>什么是ABA问题呢？</strong></p><blockquote><p>就是旧值为A，被替换为新值B，后面的线程又替换为新值A。再后面的线程对比其存储的旧值与内存中的值相等，但是它并不知道中间有个A-&gt;B-&gt;A的过程。</p></blockquote><p><strong>解决方案</strong></p><p>通过打标识的方式标记：</p><p>1.AtomicMarkableReference-&gt;仅仅标识发生了ABA现象</p><p>2.AtomicStampedReference-&gt;可以知道发生了几次ABA现象</p><h4 id="开销问题"><a href="#开销问题" class="headerlink" title="开销问题"></a>开销问题</h4><blockquote><p>CAS是一个不断循环检测的过程，毫无疑问，这将带来一定的开销。</p></blockquote><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><ul><li>jdk中相关原子操作类的使用<ul><li>更新基本类型：AtomicBoolean，AtomicInteger，AtomicLong</li><li>更新数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</li><li>更新引用类型：AtomicReference，AtomicMarkableReference（只关心该没改过），AtomicStampedReference（还关心改过几次）</li></ul></li></ul><p>有些时候对于某些简单的操作采用加锁的话未免有些过重了，可以采用原子类型如果你需要改变多个变量，可以进行封装，通过AtomicReference来管理。</p><h2 id="线程池机制"><a href="#线程池机制" class="headerlink" title="线程池机制"></a>线程池机制</h2><h3 id="ThreadLocal简介"><a href="#ThreadLocal简介" class="headerlink" title="ThreadLocal简介"></a>ThreadLocal简介</h3><blockquote><p>线程本地变量，也有些地方叫做线程本地存储，其实意思差不多。ThreadLocal可以让每个线程拥有属于自己的变量的副本，不会和其他线程的变量副本冲突，实现了线程的数据隔离</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-867510bb5ec6c143.png" alt="threadLocal"></p></blockquote><h3 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h3><p><strong>什么是线程池？为什么要用线程池？</strong></p><blockquote><ul><li>Thread线程属于操作系统的资源，消耗CPU、内存 -&gt;降低资源消耗</li><li>线程有创建、执行、销毁的时间，所以为什么不事先准备好呢？-&gt;提高响应度</li><li>所以需要一个策略机制来管理线程-&gt;提高线程的可管理性</li></ul></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220731114721901.png" alt="image-20220731114721901"></p><h3 id="线程池的参数"><a href="#线程池的参数" class="headerlink" title="线程池的参数"></a><strong>线程池的参数</strong></h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579455105.png" alt="1654140925994"></p><ul><li><p>keepAliveSize和TimeUnit这俩参数控制空闲线程存活的时间</p></li><li><p>ThreadFactory对创建线程时做这些微调工作</p></li><li><p>RejectedExecutionHandler 拒绝策略（阻塞队列满，任务数超过了最大线程数，那么就会拒绝）</p><ul><li>DiscardOldestPolicy 抛弃最老的，也就是队列队首的任务</li><li>AbortPolicy 直接抛出异常</li><li>CallerRunsPolicy  谁调用谁执行</li><li>DiscardPolicy 丢弃最新提交的任务</li></ul><p>当然也可以自己实现接口自定义拒绝策略</p></li><li><p>阻塞队列BlockingQueue</p></li></ul><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列</li><li>SynchronousQueue：一个不存储元素的阻塞队列</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列</li></ul><p>这里以okhttp中的实用场景对其中几种做简介：</p><p>在OkHttp的分发器中的线程池定义如上，其实就和 Executors.newCachedThreadPool()创建的线程一样。首先核心线程为0，表示线程池不会一直为我们缓存线程，线程池中所有线程都是在60s内没有工作就会被回收。而最大线程Integer .MAX_VALUE与等待队列synchronousQueue的组合能够得到最大的吞吐量。即当需要线程池执行任务时，如果不存在空闲线程不需要等待，马上新建线程执行任务!等待队列的不同指定了线程池的不同排队机制。一般来说，等待队列BlockingQueue有: (ArrayBlockingQueue 、LinkedBlockingQueue 与synchronousQueue 。</p><p>假设向线程池提交任务时，核心线程都被占用的情况下:</p><p>ArrayBlockingQueue :基于数组的阻塞队列，初始化需要指定固定大小</p><p>当使用此队列时，向线程池提交任务，会首先加入到等待队列中，当等待队列满了之后，再次提交任务，尝试加入队列就会失败，这时就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。所以最终可能出现后提交的任务先执行，而先提交的任务一直在等待。</p><p>LinkedBlockingQueue :基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。</p><p>当指定大小后，行为就和ArrayBlockingQueue一致。而如果未指定大小，则会使用默认的Integer.MAX_VALUE作为队列大小。这时候就会出现线程池的最大线程数参数无用，因为无论如何，向线程池提交任务加入等待队列都会成功。最终意味着所有任务都是在核心线程执行。如果核心线程一直被占，那就一直等待。</p><p>SynchronousQueue :无容量的队列。</p><p>使用此队列意味着希望获得最大并发量。因为无论如何，向线程池提交任务，往队列提交任务都会失败。而失败后如果没有空闲的非核心线程，就会检查如果当前线程池中的线程数未达到最大线程，则会新建线程执行新提交的任务。完全没有任何等待，唯一制约它的就是最大线程数的个数。因此一般配合Integer.MAX_VALUE就实现了真正的无等待。</p><p>但是需要注意的时，我们都知道，进程的内存是存在限制的，而每一个线程都需要分配一定的内存。所以线程并不能无限个数。那么当设置最大线程数为Integer.MAX_VALUE时，OkHttp同时还有最大请求任务执行个数: 64的限制。这样即解决了这个问题同时也能获得最大吞吐。</p><h3 id="两种线程池的提交任务的方法"><a href="#两种线程池的提交任务的方法" class="headerlink" title="两种线程池的提交任务的方法"></a>两种线程池的提交任务的方法</h3><ul><li><p>execute(不关心有无返回结果)</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579682668.png" alt="1654142332347"></p></li><li><p>submit</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/1654579624953.png" alt="1654142400705"></p></li></ul><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><ul><li><p>shutdown 尝试关闭一个线程，把当前没有执行任务的线程中断</p></li><li><p>shutdownNow 不管有没有执行任务的线程，都尝试中断</p><p>但是不一定成功  所谓线程的中断是一个协作机制  看任务执行方</p></li></ul><h3 id="合理配置线程池资源"><a href="#合理配置线程池资源" class="headerlink" title="合理配置线程池资源"></a>合理配置线程池资源</h3><p><strong>任务特性</strong></p><ul><li><p>CPU密集型  纯计算</p><p>配置最大线程数不要超过机器的CPU核心数（Runtime.getRuntime()）顶多+1（保证核心线程有事做），否则切换线程带来时间浪费</p></li><li><p>IO密集型 与网络、读取磁盘等IO操作相关的</p><p>最大线程数：机器的CPU核心线程数*2（推荐的经验值）</p></li><li><p>混合型 兼并上面两者 </p><p>如果两者的执行时间相差不大，拆分成两个线程池专门处理各自类型</p><p>如果两者相差很大，不用拆分（谁大配置谁）。</p></li></ul><p>核心线程数，看业务（详情参考Okhttp）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建线程的方式&quot;&gt;&lt;a href=&quot;#创建线程的方式&quot; class=&quot;headerlink&quot; title=&quot;创建线程的方式&quot;&gt;&lt;/a&gt;创建线程的方式&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1.Thread&lt;/li&gt;
&lt;li&gt;2.Runnable（实例化接口，重新run方法，放</summary>
      
    
    
    
    <category term="Java筑基" scheme="https://gun-ctrl.github.io/categories/Java%E7%AD%91%E5%9F%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>adb小结</title>
    <link href="https://gun-ctrl.github.io/2022/07/26/adb%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/"/>
    <id>https://gun-ctrl.github.io/2022/07/26/adb%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93/</id>
    <published>2022-07-26T10:58:48.938Z</published>
    <updated>2022-07-26T11:03:33.494Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://banmaman.com/2022/07/19/adb%E5%91%BD%E4%BB%A4/">adb常用命令</a></p><h2 id="与应用交互"><a href="#与应用交互" class="headerlink" title="与应用交互"></a>与应用交互</h2><p>主要是使用am<command>命令，常用的<command>如下</p><table><thead><tr><th>command</th><th align="left">用途</th></tr></thead><tbody><tr><td>start [options] <INTENT></td><td align="left">启动 <INTENT> 指定的 Activity</td></tr><tr><td>startservice [options] <INTENT></td><td align="left">启动 <INTENT> 指定的 Service</td></tr><tr><td>broadcast [options] <INTENT></td><td align="left">发送 <INTENT> 指定的广播</td></tr><tr><td>force-stop <packagename></td><td align="left">停止 <packagename> 相关的进程</td></tr><tr><td><INTENT> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</td><td align="left"></td></tr><tr><td>用于决定intent对象的选项如下：</td><td align="left"></td></tr><tr><td>参数</td><td align="left">含义</td></tr><tr><td>—-</td><td align="left">:—-</td></tr><tr><td>-a <ACTION></td><td align="left">指定 action，比如 android.intent.action.VIEW</td></tr><tr><td>-c <CATEGORY></td><td align="left">指定 category，比如 android.intent.category.APP_CONTACTS</td></tr><tr><td>-n <COMPONENT></td><td align="left">指定完整 component 名，用于明确指定启动哪个 Activity，如 com.example.app&#x2F;.ExampleActivity</td></tr></tbody></table><p><INTENT> 里还能带数据，就像写代码时的 Bundle 一样：</p><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>–esn <EXTRA_KEY></td><td align="left">null 值（只有 key 名）</td></tr><tr><td>–es <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE></td><td align="left">string 值</td></tr><tr><td>–ez <EXTRA_KEY> <EXTRA_BOOLEAN_VALUE></td><td align="left">boolean 值</td></tr><tr><td>–ei <EXTRA_KEY> <EXTRA_INT_VALUE></td><td align="left">integer 值</td></tr><tr><td>–el <EXTRA_KEY> <EXTRA_LONG_VALUE></td><td align="left">long 值</td></tr><tr><td>–ef <EXTRA_KEY> <EXTRA_FLOAT_VALUE></td><td align="left">float 值</td></tr><tr><td>–eu <EXTRA_KEY> <EXTRA_URI_VALUE></td><td align="left">URI</td></tr><tr><td>–ecn <EXTRA_KEY> <EXTRA_COMPONENT_NAME_VALUE></td><td align="left">component name</td></tr><tr><td>–eia <EXTRA_KEY> <EXTRA_INT_VALUE>[,&lt;EXTRA_INT_VALUE…]</td><td align="left">integer 数组</td></tr><tr><td>–ela <EXTRA_KEY> <EXTRA_LONG_VALUE>[,&lt;EXTRA_LONG_VALUE…]</td><td align="left">long 数组</td></tr></tbody></table><h3 id="启动应用-x2F-调起Activity"><a href="#启动应用-x2F-调起Activity" class="headerlink" title="启动应用&#x2F;调起Activity"></a>启动应用&#x2F;调起Activity</h3><h4 id="指定Activity名称启动"><a href="#指定Activity名称启动" class="headerlink" title="指定Activity名称启动"></a>指定Activity名称启动</h4><p>命令格式：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> start [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure><p>调起微信并传给它 string 数据键值对 <code>toast - hello, world</code>。<br><img src="https://upload-images.jianshu.io/upload_images/20123021-e42736fb5ede5c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="不指定Activity名称启动-启动主Activity"><a href="#不指定Activity名称启动-启动主Activity" class="headerlink" title="不指定Activity名称启动(启动主Activity)"></a>不指定Activity名称启动(启动主Activity)</h4><p>命令格式：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell monkey -<span class="selector-tag">p</span> &lt;packagename&gt; -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>启动QQ<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-a315569b2b8ab380.png" alt="image.png"></p><h3 id="调起Service"><a href="#调起Service" class="headerlink" title="调起Service"></a>调起Service</h3><p>命令格式：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> startservice [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure><p>例如：<br>调起微信的某Service</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am startservice -n com<span class="selector-class">.tencent</span>.mm/<span class="selector-class">.plugin</span><span class="selector-class">.accountsync</span><span class="selector-class">.model</span>.AccountAuthenticatorService</span><br></pre></td></tr></table></figure><p>另外一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> startservice -n <span class="keyword">com</span>.android.systemui/.SystemUIService</span><br></pre></td></tr></table></figure><h3 id="停止Service"><a href="#停止Service" class="headerlink" title="停止Service"></a>停止Service</h3><p>命令格式：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> stopservice [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure><h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>命令格式：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> broadcast [<span class="keyword">options</span>] <span class="symbol">&lt;INTENT&gt;</span></span><br></pre></td></tr></table></figure><p>可以向所有组件广播，也可以向指定组件广播<br>例如，向所有组件广播：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -<span class="selector-tag">a</span> android<span class="selector-class">.intent</span><span class="selector-class">.action</span>.BOOT_COMPLETED</span><br></pre></td></tr></table></figure><p>又例如，只向<code>org.mazhuang.boottimemeasure/.BootCompletedReceiver</code>广播</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell am broadcast -<span class="selector-tag">a</span> android<span class="selector-class">.intent</span><span class="selector-class">.action</span><span class="selector-class">.BOOT_COMPLETED</span> -n org<span class="selector-class">.mazhuang</span>.boottimemeasure/.BootCompletedReceiver</span><br></pre></td></tr></table></figure><p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。<br>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：<br>（均可使用adb触发）</p><table><thead><tr><th>action</th><th align="left">触发时机</th></tr></thead><tbody><tr><td>android.net.conn.CONNECTIVITY_CHANGE</td><td align="left">网络连接发生变化</td></tr><tr><td>android.intent.action.SCREEN_ON</td><td align="left">屏幕点亮</td></tr><tr><td>android.intent.action.SCREEN_OFF</td><td align="left">屏幕熄灭</td></tr><tr><td>android.intent.action.BATTERY_LOW</td><td align="left">电量低，会弹出电量低提示框</td></tr><tr><td>android.intent.action.BATTERY_OKAY</td><td align="left">电量恢复了</td></tr><tr><td>android.intent.action.BOOT_COMPLETED</td><td align="left">设备启动完毕</td></tr><tr><td>android.intent.action.DEVICE_STORAGE_LOW</td><td align="left">存储空间过低</td></tr><tr><td>android.intent.action.DEVICE_STORAGE_OK</td><td align="left">存储空间恢复</td></tr><tr><td>android.intent.action.PACKAGE_ADDED</td><td align="left">安装了新的应用</td></tr><tr><td>android.net.wifi.STATE_CHANGE</td><td align="left">WiFi 连接状态发生变化</td></tr><tr><td>android.net.wifi.WIFI_STATE_CHANGED</td><td align="left">WiFi 状态变为启用&#x2F;关闭&#x2F;正在启动&#x2F;正在关闭&#x2F;未知</td></tr><tr><td>android.intent.action.BATTERY_CHANGED</td><td align="left">电池电量发生变化</td></tr><tr><td>android.intent.action.INPUT_METHOD_CHANGED</td><td align="left">系统输入法发生变化</td></tr><tr><td>android.intent.action.ACTION_POWER_CONNECTED</td><td align="left">外部电源连接</td></tr><tr><td>android.intent.action.ACTION_POWER_DISCONNECTED</td><td align="left">外部电源断开连接</td></tr><tr><td>android.intent.action.DREAMING_STARTED</td><td align="left">系统开始休眠</td></tr><tr><td>android.intent.action.DREAMING_STOPPED</td><td align="left">系统停止休眠</td></tr><tr><td>android.intent.action.HEADSET_PLUG</td><td align="left">插入耳机</td></tr><tr><td>android.intent.action.MEDIA_UNMOUNTED</td><td align="left">卸载外部介质</td></tr><tr><td>android.intent.action.MEDIA_MOUNTED</td><td align="left">挂载外部介质</td></tr><tr><td>android.os.action.POWER_SAVE_MODE_CHANGED</td><td align="left">省电模式开启</td></tr></tbody></table><h3 id="强制停止应用"><a href="#强制停止应用" class="headerlink" title="强制停止应用"></a>强制停止应用</h3><p>命令：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> <span class="keyword">am</span> force-<span class="keyword">stop</span> <span class="symbol">&lt;packagename&gt;</span></span><br></pre></td></tr></table></figure><p>命令示例：<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-f509618cec978dc1.png" alt="image.png"></p><h3 id="收紧内存"><a href="#收紧内存" class="headerlink" title="收紧内存"></a>收紧内存</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span>  <span class="keyword">am</span> send-trim-memory <span class="symbol">&lt;pid&gt;</span> <span class="symbol">&lt;level&gt;</span></span><br></pre></td></tr></table></figure><p>pid: 进程 ID level: HIDDEN、RUNNING_MODERATE、BACKGROUND、 RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE<br>命令示例：</p><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> am send-<span class="keyword">trim</span>-<span class="keyword">memory</span> 12345 RUNNING_LOW</span><br></pre></td></tr></table></figure><p>表示向 pid&#x3D;12345 的进程，发出 level&#x3D;RUNNING_LOW 的收紧内存命令。 </p><h2 id="修改设置"><a href="#修改设置" class="headerlink" title="修改设置"></a>修改设置</h2><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 adb reboot 重启设备，或手动重启。<br>修改设置的原理主要是通过 settings 命令修改 &#x2F;data&#x2F;data&#x2F;com.android.providers.settings&#x2F;databases&#x2F;settings.db 里存放的设置值。</p><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm size <span class="number">480</span>x1024</span><br></pre></td></tr></table></figure><p>表示将分辨率修改为 480px * 1024px。<br>恢复：</p><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">adb shell wm size reset</span><br></pre></td></tr></table></figure><h3 id="屏幕密度"><a href="#屏幕密度" class="headerlink" title="屏幕密度"></a>屏幕密度</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm density <span class="number">160</span></span><br></pre></td></tr></table></figure><p>表示将屏幕密度修改为 160dpi。<br>恢复：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> wm density reset</span></span><br></pre></td></tr></table></figure><h3 id="显示区域"><a href="#显示区域" class="headerlink" title="显示区域"></a>显示区域</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">adb</span> shell wm overscan <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span></span><br></pre></td></tr></table></figure><p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。<br>恢复：</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> wm overscan reset</span></span><br></pre></td></tr></table></figure><h3 id="关闭USB调试"><a href="#关闭USB调试" class="headerlink" title="关闭USB调试"></a>关闭USB调试</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> adb_enabled <span class="number">0</span></span><br></pre></td></tr></table></figure><p>恢复：<br>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。<br>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p><h3 id="允许-x2F-禁止访问非-SDK-API："><a href="#允许-x2F-禁止访问非-SDK-API：" class="headerlink" title="允许&#x2F;禁止访问非 SDK API："></a>允许&#x2F;禁止访问非 SDK API：</h3><p>不需要设备获得Root权限。<br>允许访问非 SDK API：</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> hidden_api_policy_pre_p_apps <span class="number">1</span></span><br><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">put</span> <span class="built_in">global</span> hidden_api_policy_p_apps <span class="number">1</span></span><br></pre></td></tr></table></figure><p>禁止访问非 SDK API</p><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">delete</span> <span class="built_in">global</span> hidden_api_policy_pre_p_apps</span><br><span class="line">adb <span class="built_in">shell</span> settings <span class="built_in">delete</span> <span class="built_in">global</span> hidden_api_policy_p_apps</span><br></pre></td></tr></table></figure><p>命令最后的数字的含义：</p><table><thead><tr><th>值</th><th align="left">含义</th></tr></thead><tbody><tr><td>0</td><td align="left">禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td></tr><tr><td>1</td><td align="left">仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td></tr><tr><td>2</td><td align="left">禁止调用深灰名单和黑名单中的接口。</td></tr><tr><td>3</td><td align="left">禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td></tr></tbody></table><h2 id="实用功能"><a href="#实用功能" class="headerlink" title="实用功能"></a>实用功能</h2><h3 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h3><p><strong>注：</strong>未指定路径则，默认为adb所在的文件夹<br>截图保存到电脑：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">exec</span><span class="operator">-</span><span class="keyword">out</span> screencap <span class="operator">-</span>p <span class="operator">&gt;</span> sc.png</span><br></pre></td></tr></table></figure><p>如果 adb 版本较老，无法使用 exec-out 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：<br>先截图保存到设备里：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb shell screencap -p <span class="regexp">/sdcard/</span>sc.png</span><br></pre></td></tr></table></figure><p>然后将 png 文件导出到电脑：<br>adb pull &#x2F;sdcard&#x2F;sc.png<br>可以使用<code>adb shell screencap -h</code> 查看 screencap 命令的帮助信息，下面是两个有意义的参数及含义：</p><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>-p</td><td align="left">指定保存文件为 png 格式（如果指定文件后缀png，则可省略）</td></tr><tr><td>-d display-id</td><td align="left">指定截图的显示屏编号（有多显示屏的情况下）</td></tr></tbody></table><h3 id="录制屏幕"><a href="#录制屏幕" class="headerlink" title="录制屏幕"></a>录制屏幕</h3><p>录制屏幕以mp4格式保存到 &#x2F;sdcard：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb shell screenrecord <span class="regexp">/sdcard/</span>filename.mp4</span><br></pre></td></tr></table></figure><p>需要停止时按 <code>Ctrl-C</code>，默认录制时间和最长录制时间都是 180 秒。<br>如果需要导出到电脑：</p><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">adb pull <span class="regexp">/sdcard/</span>filename.mp4</span><br></pre></td></tr></table></figure><p>可以使用 <code>adb shell screenrecord --help</code> 查看 screenrecord 命令的帮助信息，下面是常见参数及含义：</p><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>–size WIDTHxHEIGHT</td><td align="left">视频的尺寸，比如 1280x720，默认是屏幕分辨率。</td></tr><tr><td>–bit-rate RATE</td><td align="left">视频的比特率，默认是 4Mbps。</td></tr><tr><td>–time-limit TIME</td><td align="left">录制时长，单位秒。</td></tr><tr><td>–verbose</td><td align="left">输出更多信息。</td></tr></tbody></table><h3 id="开启-x2F-关闭wifi"><a href="#开启-x2F-关闭wifi" class="headerlink" title="开启&#x2F;关闭wifi"></a>开启&#x2F;关闭wifi</h3><p>开启</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> svc wifi <span class="built_in">enable</span></span></span><br></pre></td></tr></table></figure><p>关闭</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span><span class="language-bash"> svc wifi <span class="built_in">disable</span></span></span><br></pre></td></tr></table></figure><h3 id="使用Monkey进行压力测试"><a href="#使用Monkey进行压力测试" class="headerlink" title="使用Monkey进行压力测试"></a>使用Monkey进行压力测试</h3><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。<br>简单用法：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> monkey -<span class="keyword">p</span> <span class="symbol">&lt;packagename&gt;</span> -v <span class="number">500</span></span><br></pre></td></tr></table></figure><p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。<br>更多内容可见<a href="https://developer.android.google.cn/studio/test/monkey.html">monkey官网</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;http://banmaman.com/2022/07/19/adb%E5%91%BD%E4%BB%A4/&quot;&gt;adb常用命令&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;与应用交互&quot;&gt;&lt;a href=&quot;#与应用交互&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Android随笔" scheme="https://gun-ctrl.github.io/categories/Android%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="adb" scheme="https://gun-ctrl.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>adb获取应用包入口的方案</title>
    <link href="https://gun-ctrl.github.io/2022/07/24/adb%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E5%8C%85%E5%85%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%A1%88/"/>
    <id>https://gun-ctrl.github.io/2022/07/24/adb%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E5%8C%85%E5%85%A5%E5%8F%A3%E7%9A%84%E6%96%B9%E6%A1%88/</id>
    <published>2022-07-24T10:10:39.837Z</published>
    <updated>2022-07-24T10:12:35.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>小编最近在入手adb调试，刚开始还是挺顺利的，不过后面就遇到了一些小插曲，其中一个就是获取应用包的入口，开启一个应用。<br>这个问题在网上可以找到很多解决方案，但不都是有用，并且有些方法有一点麻烦。<br>这里，小编介绍一下意外摸索到的解决方案。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1、点开需要打开的应用，使用获取前台Activity命令</p><figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">adb shell dumpsys activity activities <span class="string">| findstr mResumedActivity</span></span><br></pre></td></tr></table></figure><p>这样便能获得应用包的启动入口<br>比如，获取有道词典的启动入口<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-2420606065b22c18.png" alt="image.png"></p><p>2、使用adb启动应用包</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">adb shell am start -n <span class="selector-attr">[应用包名]</span> /<span class="selector-attr">[入口]</span></span><br></pre></td></tr></table></figure><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-444cb9956734d120.png" alt="image.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;小编最近在入手adb调试，刚开始还是挺顺利的，不过后面就遇到了一些小插曲，其中一个就是获取应用包的入口，开启一个应用。&lt;br&gt;这个问题在网上</summary>
      
    
    
    
    <category term="Android随笔" scheme="https://gun-ctrl.github.io/categories/Android%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="adb" scheme="https://gun-ctrl.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>adb shell input text不能输入中文的解决方案</title>
    <link href="https://gun-ctrl.github.io/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://gun-ctrl.github.io/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2022-07-24T10:08:37.857Z</published>
    <updated>2022-07-24T10:11:48.592Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>adb默认是不支持Unicode编码的，无法通过adb shell input text 命令输入中文到手机或者模拟器。</p><h3 id="解决步骤"><a href="#解决步骤" class="headerlink" title="解决步骤"></a>解决步骤</h3><ul><li>1、安装ADBKeyBoard.apk文件(直接搜索就能找到)<br>打开手机或模拟器，adb install ADBKeyBoard.apk安装该输入法<br>在手机上直接安装也可</li><li>2、设置默认输入法<br>打开手机设置 -&gt; 点击语法与输入法 -&gt; 点击输入法管理 -&gt; 启用ADBKeyboard<br>重启手机后即可使用该输入法</li><li>3、输入adb命令测试中文输入<br>adb shell am broadcast -a ADB_INPUT_TEXT –es msg ‘这是一段adb中文测试’</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h3&gt;&lt;p&gt;adb默认是不支持Unicode编码的，无法通过adb shell input text 命令输入中文到手机或者模拟器。&lt;/p&gt;
&lt;h3 i</summary>
      
    
    
    
    <category term="Android随笔" scheme="https://gun-ctrl.github.io/categories/Android%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="adb" scheme="https://gun-ctrl.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView的回收复用机制</title>
    <link href="https://gun-ctrl.github.io/2022/07/24/RecyclerView%E7%9A%84%E5%9B%9E%E6%94%B6%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
    <id>https://gun-ctrl.github.io/2022/07/24/RecyclerView%E7%9A%84%E5%9B%9E%E6%94%B6%E5%A4%8D%E7%94%A8%E6%9C%BA%E5%88%B6/</id>
    <published>2022-07-24T09:13:11.844Z</published>
    <updated>2022-07-24T10:07:10.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一章，小编介绍了RecyclerView的高级用法——自定义LayoutManager。今天，我们来从源码的角度深度剖析RecyclerView，主要是对RecyclerView的回收复用机制熟悉掌握。</p><h2 id="RecyclerView介绍"><a href="#RecyclerView介绍" class="headerlink" title="RecyclerView介绍"></a>RecyclerView介绍</h2><blockquote><p>RecyclerView可以说是项目必备的系统高级控件，相比于传统的ListVIew，RecyclerView最大的优势就是四级缓存机制，ListView是两级缓存机制（屏幕内可见、屏幕外）。</p></blockquote><h3 id="四级缓存机制"><a href="#四级缓存机制" class="headerlink" title="四级缓存机制"></a>四级缓存机制</h3><ul><li><p>mChangeScrap（主要与动画相关）与mAttachedScrap（一般这两算一级）</p><p>用来缓存还在屏幕内的ViewHolder</p></li><li><p>mCachedViews</p><p>用来缓存移除屏幕之外的ViewHolder</p></li><li><p>mViewCacheExtension</p><p>用户的自定义扩展缓存，需要用户自己管理View的创建和缓存</p></li><li><p>RecyclerViewPool</p><p>ViewHolder缓存池</p></li></ul><h3 id="回收复用的入口"><a href="#回收复用的入口" class="headerlink" title="回收复用的入口"></a>回收复用的入口</h3><p>上一章中自定义LayoutManager中有<code> detachAndScrapAttachedViews(recycler!!)</code>这样一个方法，用于回收ViewHolder。下面就来介绍一下RecyclerView的回收。</p><p>回收有两个入口，一是布局onLayout时，二是在fill填充itemVIew时</p><ul><li>onLayout</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220724172908391.png" alt="image-20220724172908391"></p><p>1.因为RecyclerView的具体onLayout是交给具体的LayoutManager来实现的，所以回收复用的具体操作是由LayoutManager来完成，在自定义LayoutManager时需考虑这一点，参考系统提供的LinearLayoutManager</p><p>2.上图的两个重心是LinearLayoutManager中回收入口的分叉和Recycler中的实际回收情况，而我们在自定义LayoutManager时，回收Holder只需要通过detachAndScrapAttachedViews这一个方法即可，具体是如何进行回收的我们不关心，但需要知道有哪几种，因为这对应了几种缓存，上面已经介绍了四级缓存。</p><p>3.缓存池与mCacheViews的关系：</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144808720.png" alt="image-20220717144808720"></p><blockquote><p> <strong>注意：</strong>缓存池中保存的只是ViewHolder，没有数据，所以缓存池中的ViewHolder复用还需要绑定</p></blockquote><ul><li><p>fill</p><p>在fill中只考虑了recycleViewHolderInternal这种情况，滑动过程中会触发</p></li></ul><p><strong>回收重要源码截图</strong></p><blockquote><p>如果觉得上述回收流程图理解起来抽象的，可见结合部分源码截图理解。</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717115957690.png" alt="image-20220717115957690"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717121349370.png" alt="image-20220717121349370"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717141954608.png" alt="image-20220717141954608"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717142707778.png"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717142831116.png" alt="image-20220717142831116"></p><blockquote><p>如果超过mCacheView最大值（2），就加入到缓存池</p><p>缓存到缓存池之后，就从mCacheView中移除</p><p>从“0”拿出，说明是先进先出的</p></blockquote><ul><li>否则，直接进缓存池  和上面一样都是调用<code>addViewHolderToRecycledViewPool</code></li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717143953794.png" alt="image-20220717143953794"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144255403.png" alt="image-20220717144255403"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144354585.png" alt="image-20220717144354585"></p><blockquote><p>ScrapData -&gt; ArrayList<ViewHolder></p><p>mScrap-&gt;SpareArray<ScrapData></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717144443187.png" alt="image-20220717144443187"></p></blockquote><p><strong>recycler.scrapView()</strong></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717153414420.png" alt="image-20220717153414420"></p><p><strong>ViewHolder的包装源码</strong></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120045307.png" alt="image-20220717120045307"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120201306.png" alt="image-20220717120201306"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717120910841.png" alt="image-20220717120910841"></p><h3 id="复用入口"><a href="#复用入口" class="headerlink" title="复用入口"></a>复用入口</h3><blockquote><p>复用的入口点同样也是两个，分别是布局时与滑动时。</p></blockquote><ul><li><p>onLayout</p><p>上一章中我们在自定义LayoutManager中就是重写的下面的<code>4.onLayoutChildren</code></p></li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717165422042.png" alt="image-20220717165422042"></p><ul><li>onTouch</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220724174858215.png" alt="image-20220724174858215"></p><p>其实二者雷同，从fill入口开始，onLayout与onTouch几乎一样，只是第一张图用的时序图，绘制的比较详细。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实我们阅读源码了解原理机制，不用记住每个方法的入口、流程细节等，只需要记住大致过程，并理解重要部分。比如RecyclerView的四级缓存，以及回收复用的大致过程。</p><p>这章的几个重点：</p><p>1.从mAttachedScrap、mChangedScrap、mCachedViews中取出的holder不需要再绑定数据</p><p>2.从RecyclerPool取出的holder需要重新绑定数据</p><p>3.mAttachedScrap、mChangedScrap缓存的是屏幕看到的holder</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://wiwiyiyi.com/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#%E5%9B%9B-%E6%80%BB%E7%BB%93">https://wiwiyiyi.com/RecyclerView%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%A4%8D%E7%94%A8%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html#%E5%9B%9B-%E6%80%BB%E7%BB%93</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一章，小编介绍了RecyclerView的高级用法——自定义LayoutManager。今天，我们来从源码的角度深度剖析RecyclerV</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
    <category term="RecyclerView" scheme="https://gun-ctrl.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>自定义LayoutManager实现卡片滑动</title>
    <link href="https://gun-ctrl.github.io/2022/07/23/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%E5%AE%9E%E7%8E%B0%E5%8D%A1%E7%89%87%E6%BB%91%E5%8A%A8/"/>
    <id>https://gun-ctrl.github.io/2022/07/23/%E8%87%AA%E5%AE%9A%E4%B9%89LayoutManager%E5%AE%9E%E7%8E%B0%E5%8D%A1%E7%89%87%E6%BB%91%E5%8A%A8/</id>
    <published>2022-07-23T14:34:04.234Z</published>
    <updated>2022-07-24T10:07:37.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>前面介绍了利用自定义ItemDecoration实现RecyclerView吸顶效果，重点就在onDraw -&gt; ItemView -&gt; onDrawOver的绘制流程，同时注意预留空间的利用。</p><p>今天介绍一个新的知识点与demo，利用自定义LayoutManager的方式实现卡片滑动。有时候系统提供的LayoutManager已经不能够满足我们的需求，这个时候我们就需要自定义LayoutManager。</p></blockquote><h2 id="卡片滑动效果介绍"><a href="#卡片滑动效果介绍" class="headerlink" title="卡片滑动效果介绍"></a>卡片滑动效果介绍</h2><p>卡片滑动的效果如下图所示。</p><p>分析一下卡片效果，顶部的卡片是正常摆放，接着的后面两张会随着位置变化缩小、下移，产生视觉上的叠层效果，再然后的卡片就与第三张重叠摆放。可以滑动移除图片，下面的卡片会自动补全。</p><ul><li>实现这样的效果突破点在于两点：</li></ul><ol><li>要实现这样重叠式布局的效果，我们就需要自定义LayoutManager，就像系统自带的<code>LinearLayoutManager</code>、<code>GridLayoutManager</code>一样。</li><li>滑动移除效果的实现，没有重写<code>scrollVerticallyBy</code>以及<code>scrollHorizontallyBy</code>，这就需要一个重要的帮助类<code>ItemTouchHelper</code></li></ol><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/SlideCard.gif" alt="SlideCard"></p><h2 id="卡片滑动实现"><a href="#卡片滑动实现" class="headerlink" title="卡片滑动实现"></a>卡片滑动实现</h2><ul><li><p>实现思路</p><blockquote><ol><li>摆放策略交给LayoutManager-&gt;具体怎么摆，每一个卡片布局策略和数据绑定由Adapter负责</li><li>LayoutManager必须重写<code>onLayoutChildren</code>方法，当数据发生改变时，会重新布局，detachAndScrapAttachedViews处理回收，recycler.getViewForPosition(i)获取对应位置的View。</li><li>测量view，摆放时需要考虑通过ItemDecoration预留的间距<code>layoutDecoratedWithMargins</code></li><li>卡片采用的是倒序摆放，即从第8张到第一张的顺序摆放</li><li>利用<code>ItemTouchHelper</code>实现滑动移除，并且需要重写onChildDraw，实现滑动动画开始时，下方图片缩放效果。TouchHelper是ItemDecoration的子类，在onDraw时根据滑动距离来影响后面view的大小</li></ol></blockquote></li><li><p>关键代码块：</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlideCardLayoutManager</span>:RecyclerView.LayoutManager() &#123;</span><br><span class="line">    override fun <span class="title function_">generateDefaultLayoutParams</span><span class="params">()</span>: RecyclerView.LayoutParams &#123;</span><br><span class="line">        <span class="keyword">return</span> RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">        ViewGroup.LayoutParams.WRAP_CONTENT)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onLayoutChildren</span><span class="params">(recycler: RecyclerView.Recycler?, state: RecyclerView.State?)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onLayoutChildren(recycler, state)</span><br><span class="line">        detachAndScrapAttachedViews(recycler!!)</span><br><span class="line">        <span class="type">val</span> <span class="variable">itemCount</span> <span class="operator">=</span> itemCount</span><br><span class="line">        <span class="type">var</span> <span class="variable">bottomPosition</span> <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (itemCount&lt;CardConfig.MAX_SHOW_COUNT)&#123;</span><br><span class="line">            bottomPosition = <span class="number">0</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            bottomPosition = itemCount - CardConfig.MAX_SHOW_COUNT</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i in bottomPosition until  itemCount)&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recycler.getViewForPosition(i)</span><br><span class="line">            addView(view)</span><br><span class="line">            <span class="comment">//测量</span></span><br><span class="line">            measureChildWithMargins(view,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">            <span class="type">val</span> <span class="variable">widthSpace</span> <span class="operator">=</span> width - getDecoratedMeasuredHeight(view)</span><br><span class="line">            <span class="type">val</span> <span class="variable">heightSpace</span> <span class="operator">=</span> height - getDecoratedMeasuredHeight(view)</span><br><span class="line">            <span class="comment">//布局</span></span><br><span class="line">            layoutDecoratedWithMargins(view,</span><br><span class="line">            widthSpace/<span class="number">2</span>,</span><br><span class="line">            heightSpace/<span class="number">2</span>,</span><br><span class="line">            widthSpace/<span class="number">2</span>+getDecoratedMeasuredWidth(view),</span><br><span class="line">            heightSpace/<span class="number">2</span>+getDecoratedMeasuredHeight(view))</span><br><span class="line">            <span class="type">var</span> <span class="variable">level</span> <span class="operator">=</span> itemCount -i -<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (level&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (level&lt;CardConfig.MAX_SHOW_COUNT-<span class="number">1</span>)&#123;<span class="comment">//提示，这里CardConfig.MAX_SHOW_COUNT=4，可见小编所有代码</span></span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * level</span><br><span class="line">                    view.scaleX = <span class="number">1</span>-CardConfig.SCALE_GAP*level</span><br><span class="line">                    view.scaleY = <span class="number">1</span>-CardConfig.SCALE_GAP*level</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    view.translationY = CardConfig.TRANS_Y_GAP * (level-<span class="number">1</span>)</span><br><span class="line">                    view.scaleX = <span class="number">1</span>-CardConfig.SCALE_GAP*(level-<span class="number">1</span>)</span><br><span class="line">                    view.scaleY = <span class="number">1</span>-CardConfig.SCALE_GAP*(level-<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：这里继承的是<code>ItemTouchHelper.SimpleCallback</code>，<code>ItemTouchHelper.Callback</code>需要重写的方法太多。</li><li>重写onChildDraw，因为notifyDataSetChanged()会走onDraw流程，而onDraw又会调用onChildDraw。</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SlideCallBack</span>(</span><br><span class="line">    <span class="keyword">private</span> val adapter:SlideCardAdapter,</span><br><span class="line">    <span class="keyword">private</span> val mData:MutableList&lt;SlideCardBean&gt;</span><br><span class="line">):ItemTouchHelper.SimpleCallback(<span class="number">0</span>,<span class="number">15</span>) &#123;</span><br><span class="line">    override fun <span class="title function_">onMove</span><span class="params">(</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        viewHolder: RecyclerView.ViewHolder,</span></span><br><span class="line"><span class="params">        target: RecyclerView.ViewHolder</span></span><br><span class="line"><span class="params">    )</span>: Boolean &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressLint(&quot;NotifyDataSetChanged&quot;)</span></span><br><span class="line">    override fun <span class="title function_">onSwiped</span><span class="params">(viewHolder: RecyclerView.ViewHolder, direction: Int)</span> &#123;</span><br><span class="line">        <span class="type">val</span> <span class="variable">remove</span> <span class="operator">=</span> mData.removeAt(viewHolder.layoutPosition)</span><br><span class="line">        mData.add(<span class="number">0</span>,remove)</span><br><span class="line">        adapter.notifyDataSetChanged()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun <span class="title function_">onChildDraw</span><span class="params">(</span></span><br><span class="line"><span class="params">        c: Canvas,</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        viewHolder: RecyclerView.ViewHolder,</span></span><br><span class="line"><span class="params">        dX: Float,</span></span><br><span class="line"><span class="params">        dY: Float,</span></span><br><span class="line"><span class="params">        actionState: Int,</span></span><br><span class="line"><span class="params">        isCurrentlyActive: Boolean</span></span><br><span class="line"><span class="params">    )</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive)</span><br><span class="line">        <span class="type">val</span> <span class="variable">maxDistance</span> <span class="operator">=</span> recyclerView.width * <span class="number">0.5f</span></span><br><span class="line">        <span class="type">val</span> <span class="variable">distance</span> <span class="operator">=</span> sqrt((dX*dX+dY*dY).toDouble())</span><br><span class="line">        <span class="type">var</span> <span class="variable">fraction</span> <span class="operator">=</span> distance/maxDistance</span><br><span class="line">        <span class="title function_">if</span> <span class="params">(fraction&gt;<span class="number">1</span>)</span>&#123;</span><br><span class="line">            fraction= <span class="number">1.0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">val</span> <span class="variable">itemCount</span> <span class="operator">=</span> recyclerView.childCount</span><br><span class="line">        Log.v(<span class="string">&quot;ppp&quot;</span>,<span class="string">&quot;itemCount: $itemCount&quot;</span>)</span><br><span class="line">        <span class="keyword">for</span>(i in <span class="number">0</span> until itemCount)&#123;</span><br><span class="line">            <span class="type">val</span> <span class="variable">view</span> <span class="operator">=</span> recyclerView.getChildAt(i)</span><br><span class="line">            <span class="type">val</span> <span class="variable">level</span> <span class="operator">=</span> itemCount - i - <span class="number">1</span></span><br><span class="line">            Log.v(<span class="string">&quot;pc&quot;</span>,<span class="string">&quot;level: $level&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> (level&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//重绘level=1，2 -&gt;也就是i=5,6</span></span><br><span class="line">                <span class="keyword">if</span> (level&lt;CardConfig.MAX_SHOW_COUNT-<span class="number">1</span>)&#123;</span><br><span class="line">                    view.translationY = (CardConfig.TRANS_Y_GAP * (level-fraction)).toFloat()</span><br><span class="line">                    view.scaleX = (<span class="number">1</span>-CardConfig.SCALE_GAP*level+fraction*CardConfig.SCALE_GAP).toFloat()</span><br><span class="line">                    view.scaleY = (<span class="number">1</span>-CardConfig.SCALE_GAP*level+fraction*CardConfig.SCALE_GAP).toFloat()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//s时间</span></span><br><span class="line">    override fun <span class="title function_">getAnimationDuration</span><span class="params">(</span></span><br><span class="line"><span class="params">        recyclerView: RecyclerView,</span></span><br><span class="line"><span class="params">        animationType: Int,</span></span><br><span class="line"><span class="params">        animateDx: Float,</span></span><br><span class="line"><span class="params">        animateDy: Float</span></span><br><span class="line"><span class="params">    )</span>: Long &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">500</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>目前为止，小编已经介绍了RecyclerView自定义用法的两种，自定义ItemDecoration和自定义LayoutManager。这里有一个逻辑上的坑点：顶部的卡片是正常摆放，我们自定义LayoutManager中不用管它，所以在上方两个代码块中都有<code>level&gt;0</code>和<code>level&lt;CardConfig.MAX_SHOW_COUNT-1</code>，也就是重绘索引值<code>i=5,6</code>即第6和7个，在<code>SlideCardLayoutManager</code>中，第5张卡片即一下的重叠在第6张的下面。这个点烦恼了小编好久，刚开始一直不明白顶部的摆放去哪了，从这点可以看出了解原理看源码的重要性。下一章，我们将对RecyclerView源码机制进行解读，再结合这一章的内容，将会对RecyclerView的原理有个更深层次的理解。</p><p><a href="https://github.com/gun-ctrl/SlideCard">全部代码地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;前面介绍了利用自定义ItemDecoration实现RecyclerView吸顶效果，重点就在onDraw -&amp;g</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/tags/%E9%AB%98%E7%BA%A7UI/"/>
    
  </entry>
  
  <entry>
    <title>adb命令</title>
    <link href="https://gun-ctrl.github.io/2022/07/19/adb%E5%91%BD%E4%BB%A4/"/>
    <id>https://gun-ctrl.github.io/2022/07/19/adb%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-19T13:53:09.637Z</published>
    <updated>2022-08-19T06:47:13.236Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文为小编学习总结的一些adb的常用命令，可能一些命令有待验证，更多内容可以参考<a href="https://github.com/mzlogin/awesome-adb#%E6%8C%87%E5%AE%9A-adb-server-%E7%9A%84%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3">adb用法大全</a></p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="语法命令"><a href="#语法命令" class="headerlink" title="语法命令"></a>语法命令</h4><p>adb 命令的基本语法如下：<br>adb [ -d| -e| -s <sericalNumber>] <command><br>如果只有一个设备&#x2F;模拟器连接时，可以省略掉[ -d| -e| -s] <sericalNumber>] 这一部分，直接使用adb <command>。</p><h4 id="为命令指定目标设备"><a href="#为命令指定目标设备" class="headerlink" title="为命令指定目标设备"></a>为命令指定目标设备</h4><p>如果有多个设备&#x2F;模拟器,则需要为命令指定目标设备</p><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>-d</td><td align="left">指定当前唯一通过 USB 连接的 Android 设备为命令目标</td></tr><tr><td>-e</td><td align="left">指定当前唯一运行的模拟器为目标命令</td></tr><tr><td>-s<serialNumber></td><td align="left">指定相应 serialNumber 号的设备&#x2F;模拟器为命令目标</td></tr></tbody></table><h2 id="常用adb命令"><a href="#常用adb命令" class="headerlink" title="常用adb命令"></a>常用adb命令</h2><h3 id="查看adb版本号"><a href="#查看adb版本号" class="headerlink" title="查看adb版本号"></a>查看adb版本号</h3><p>adb version</p><h3 id="查看已连接设备"><a href="#查看已连接设备" class="headerlink" title="查看已连接设备"></a>查看已连接设备</h3><p>adb devices</p><h3 id="查看手机序列号"><a href="#查看手机序列号" class="headerlink" title="查看手机序列号"></a>查看手机序列号</h3><p>adb get-serialno<br>如返回127.0.0.1:7555</p><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>adb logcat</p><blockquote><p>adb logcat -c 清除日志<br>adb logcat | grep “tag” 过滤日志 这里的tag就是你打印日志的时候需要设置的第一个参数TAG，通过TAG我们可以很轻松的过滤出我们想要的日志，轻松高效。</p></blockquote><h3 id="安装apk"><a href="#安装apk" class="headerlink" title="安装apk"></a>安装apk</h3><p>adb install [apk文件的路径]</p><blockquote><p>adb install douyin.apk</p></blockquote><ul><li>多个设备安装apk<br>adb -s [设备号] install [apk文件的路径]<blockquote><p>adb -s 127.0.0.1:7555 install douyin.apk</p></blockquote></li><li>如果apk已经存在，需要覆盖安装</li><li>adb install -r [apk文件的路径]<blockquote><p>adb install -r douyin.apk</p></blockquote></li></ul><p>adb install后面可以跟一些可选参数来控制安装APK的行为，可选参数及含义如下</p><table><thead><tr><th>参数</th><th align="left">含义</th></tr></thead><tbody><tr><td>-l</td><td align="left">将应用安装到保护目录 &#x2F;mnt&#x2F;asec</td></tr><tr><td>-r</td><td align="left">允许覆盖安装</td></tr><tr><td>-t</td><td align="left">允许安装AndroidMainfest.xml里application指定<code>android:testOnly=&quot;true&quot;</code>的应用</td></tr><tr><td>-s</td><td align="left">应用安装到sdcard</td></tr><tr><td>-d</td><td align="left">允许降级覆盖安装</td></tr><tr><td>-g</td><td align="left">授予所有运行时权限</td></tr><tr><td>–abi abi-identifier</td><td align="left">为特定ABI强制安装apk，abi-identifier可以是armeabi-v7a、arm64-v8a、v86、x86_64 等</td></tr></tbody></table><h3 id="卸载apk"><a href="#卸载apk" class="headerlink" title="卸载apk"></a>卸载apk</h3><ul><li>普通卸载</li><li>adb uninstall [apk文件的路径]<blockquote><p>adb uninstall douyin.apk</p></blockquote></li><li>卸载但是保留数据</li><li>adb uninstall -k [apk文件的路径]<blockquote><p>adb uninstall -k douyin.apk</p></blockquote></li></ul><h3 id="获取手机root权限"><a href="#获取手机root权限" class="headerlink" title="获取手机root权限"></a>获取手机root权限</h3><p>adb root</p><h3 id="连接不稳定时需要挂载"><a href="#连接不稳定时需要挂载" class="headerlink" title="连接不稳定时需要挂载"></a>连接不稳定时需要挂载</h3><p>adb remount</p><h3 id="重启手机"><a href="#重启手机" class="headerlink" title="重启手机"></a>重启手机</h3><ul><li>正常重启<br>adb reboot</li><li>重启手机到recovery<br>adb reboot recovery</li><li>重启到bootloader界面<br>adb reboot bootloader</li></ul><h3 id="关闭adb服务"><a href="#关闭adb服务" class="headerlink" title="关闭adb服务"></a>关闭adb服务</h3><p>adb kill -server</p><h3 id="启动adb服务"><a href="#启动adb服务" class="headerlink" title="启动adb服务"></a>启动adb服务</h3><p>adb start -server</p><h3 id="查看手机设备型号"><a href="#查看手机设备型号" class="headerlink" title="查看手机设备型号"></a>查看手机设备型号</h3><p>adb shell getprop ro.product.model<br>如返回MI 8</p><h3 id="查看设备的Android版本"><a href="#查看设备的Android版本" class="headerlink" title="查看设备的Android版本"></a>查看设备的Android版本</h3><p>adb shell getprop ro.build.version.release</p><h3 id="获取手机厂商名称"><a href="#获取手机厂商名称" class="headerlink" title="获取手机厂商名称"></a>获取手机厂商名称</h3><p>adb shell getprop ro.product.brand<br>如返回Xiaomi</p><h3 id="获取手机SDK版本"><a href="#获取手机SDK版本" class="headerlink" title="获取手机SDK版本"></a>获取手机SDK版本</h3><p>adb shell getprop ro.build.version.sdk</p><h3 id="查看手机分辨率"><a href="#查看手机分辨率" class="headerlink" title="查看手机分辨率"></a>查看手机分辨率</h3><p>adb shell wm size</p><h3 id="查看屏幕密度"><a href="#查看屏幕密度" class="headerlink" title="查看屏幕密度"></a>查看屏幕密度</h3><p>adb shell wm density<br><strong>修改屏幕密度</strong><br>adb shell wm density 160<br><strong>恢复原屏幕密度</strong><br>adb shell wm density reset</p><h3 id="查看手机的mac地址"><a href="#查看手机的mac地址" class="headerlink" title="查看手机的mac地址"></a>查看手机的mac地址</h3><p>adb shell cat &#x2F;sys&#x2F;class&#x2F;net&#x2F;wlan0&#x2F;address</p><h3 id="查看电池信息"><a href="#查看电池信息" class="headerlink" title="查看电池信息"></a>查看电池信息</h3><p>adb shell dumpsys battery</p><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><p>adb shell ps</p><h3 id="查看CPU使用情况"><a href="#查看CPU使用情况" class="headerlink" title="查看CPU使用情况"></a>查看CPU使用情况</h3><p>adb shell top</p><h3 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h3><p>adb shell cat &#x2F;proc&#x2F;cpuinfo</p><h3 id="内存信息"><a href="#内存信息" class="headerlink" title="内存信息"></a>内存信息</h3><p>adb shell cat &#x2F;proc&#x2F;meminfo</p><h3 id="查看手机上所有安装的app包名"><a href="#查看手机上所有安装的app包名" class="headerlink" title="查看手机上所有安装的app包名"></a>查看手机上所有安装的app包名</h3><p>adb shell pm list packages</p><blockquote><p>adb shell pm list packages -s 查看所有系统app的包名<br>adb shell pm list packages -3 查看所有第三方app的包名<br>adb shell pm list packages | grep [包名] 使用grep筛选所有满足要求的app包名</p></blockquote><h3 id="清除应用数据"><a href="#清除应用数据" class="headerlink" title="清除应用数据"></a>清除应用数据</h3><p>adb shell pm clear [<packagename>]</p><blockquote><p>当你只是想要清除一个apk的某些数据来复现某些操作的时候，这个命令就显得额外重要。它可以避免我们重装apk来完成这个操作。</p></blockquote><h3 id="获取某个应用包名的启动入口"><a href="#获取某个应用包名的启动入口" class="headerlink" title="获取某个应用包名的启动入口"></a>获取某个应用包名的启动入口</h3><ul><li>adb shell dumpsys package com.ss.android.ugc.aweme|findstr activity</li><li>com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity 这个就是抖音的入口<blockquote><p>adb shell dumpsys package com.ss.android29111 com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity</p></blockquote></li></ul><h3 id="屏幕截屏"><a href="#屏幕截屏" class="headerlink" title="屏幕截屏"></a>屏幕截屏</h3><p>adb shell screencap [保存路径]</p><blockquote><p>adb shell screencap &#x2F;sdcard&#x2F;screen.png</p></blockquote><h3 id="录制视频"><a href="#录制视频" class="headerlink" title="录制视频"></a>录制视频</h3><p>adb shell screenrecord [保存路径]</p><p>也可以使用（adb版本太老的话，需要更新adb）</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">adb <span class="keyword">exec</span><span class="operator">-</span><span class="keyword">out</span> screencap  <span class="operator">&gt;</span> sc.png</span><br></pre></td></tr></table></figure><h3 id="上传文件到手机"><a href="#上传文件到手机" class="headerlink" title="上传文件到手机"></a>上传文件到手机</h3><p>adb push [电脑文件路径] [手机文件保存路径]</p><blockquote><p>adb push douyin.apk sdcard&#x2F;douyin.apk</p></blockquote><h3 id="从手机端下载文件"><a href="#从手机端下载文件" class="headerlink" title="从手机端下载文件"></a>从手机端下载文件</h3><p>adb pull [手机上文件路径]<br><strong>注意：</strong>此时没有指定上传到电脑的路径，会默认上传到adb程序所在的路径</p><blockquote><p>adb pull sdcard&#x2F;douyin.apk</p></blockquote><p>指定上传路径：adb pull [手机上文件的路径] [电脑文件的路径]</p><blockquote><p>adb pull &#x2F;storage&#x2F;emulated&#x2F;0&#x2F;app&#x2F;txt.mp4 D:&#x2F;ADB&#x2F;tet.mp4</p></blockquote><h3 id="模拟屏幕点击事件"><a href="#模拟屏幕点击事件" class="headerlink" title="模拟屏幕点击事件"></a>模拟屏幕点击事件</h3><p>adb shell input tap x坐标轴 y坐标轴</p><blockquote><p>adb shell input tap 500 1450</p></blockquote><h3 id="模拟手势滑动事件"><a href="#模拟手势滑动事件" class="headerlink" title="模拟手势滑动事件"></a>模拟手势滑动事件</h3><p>adb shell input swipe 开始x轴 开始y轴 结束x轴 结束y轴 过程持续时间</p><blockquote><p>adb shell input swipe 100 500 100 1450 100</p></blockquote><h3 id="模拟点击键盘按钮"><a href="#模拟点击键盘按钮" class="headerlink" title="模拟点击键盘按钮"></a>模拟点击键盘按钮</h3><p>adb shell input keyevent [key值]</p><blockquote><p>adb shell input keyevent 25</p></blockquote><p>一些常用的keyevent键值信息</p><table><thead><tr><th>keyevent</th><th align="left">效果</th></tr></thead><tbody><tr><td>3</td><td align="left">Home键</td></tr><tr><td>5</td><td align="left">拨号键</td></tr><tr><td>6</td><td align="left">挂机键</td></tr><tr><td>19</td><td align="left">向上</td></tr><tr><td>20</td><td align="left">向下</td></tr><tr><td>21</td><td align="left">向左</td></tr><tr><td>22</td><td align="left">向右</td></tr><tr><td>24</td><td align="left">音量加</td></tr><tr><td>25</td><td align="left">音量减</td></tr><tr><td>26</td><td align="left">电源</td></tr><tr><td>27</td><td align="left">拍照键</td></tr><tr><td>66</td><td align="left">回车键</td></tr><tr><td>67</td><td align="left">退格键</td></tr><tr><td>82</td><td align="left">菜单键</td></tr><tr><td>83</td><td align="left">通知键</td></tr><tr><td>84</td><td align="left">搜索键</td></tr><tr><td>92</td><td align="left">向上翻页</td></tr><tr><td>93</td><td align="left">向下翻页</td></tr><tr><td>111</td><td align="left">esc键</td></tr><tr><td>112</td><td align="left">删除键</td></tr><tr><td>115</td><td align="left">大写锁定键</td></tr><tr><td>122</td><td align="left">光标移动到开始键</td></tr><tr><td>123</td><td align="left">光标移动到末尾键</td></tr><tr><td>143</td><td align="left">小键盘锁</td></tr><tr><td>168</td><td align="left">放大键</td></tr><tr><td>169</td><td align="left">缩小键</td></tr></tbody></table><h3 id="向屏幕输入一些信息"><a href="#向屏幕输入一些信息" class="headerlink" title="向屏幕输入一些信息"></a>向屏幕输入一些信息</h3><ul><li>db shell input text [字符串信息]</li><li>%s是空格<blockquote><p>db shell input text “insert%stext%shere”</p></blockquote></li></ul><h3 id="查看前台Activity"><a href="#查看前台Activity" class="headerlink" title="查看前台Activity"></a>查看前台Activity</h3><p>同时小编也是通过这种方式获取到应用包的入口<br>adb shell dumpsys activity activities | findstr mResumedActivity<br>获取到了QQ的启动入口<br><img src="https://upload-images.jianshu.io/upload_images/20123021-1584e1eac4dde441.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="启动某个app"><a href="#启动某个app" class="headerlink" title="启动某个app"></a>启动某个app</h3><p>adb shell am start -n [包名]&#x2F;[启动入口]</p><blockquote><p>adb shel am start -n com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity<br>Strating:Intent{cmp&#x3D;com.ss.android.ugc.aweme&#x2F;com.ss.android.sdk.activity.BootstrapActivity}</p></blockquote><p>启动qq</p><blockquote><p>adb shell am start -n com.tencent.mobileqq&#x2F;.activity.SplashActivity</p></blockquote><p>启动有道词典<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-307c3a0c81650606.png" alt="image.png"></p><h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>adb shell am broadcast -a “broadcastactionfilter”</p><blockquote><p>adb shell am broadcast -a “broadcastactionfilter”</p></blockquote><h3 id="使用自带浏览器打开网页"><a href="#使用自带浏览器打开网页" class="headerlink" title="使用自带浏览器打开网页"></a>使用自带浏览器打开网页</h3><p>adb shell am start -a [浏览器包名] -d [网址]</p><blockquote><p>adb shell am start -a “android.intent.action.VIEW” -d <a href="https://www.google.com/">https://www.google.com</a></p></blockquote><h3 id="获取手机内部存储信息"><a href="#获取手机内部存储信息" class="headerlink" title="获取手机内部存储信息"></a>获取手机内部存储信息</h3><p>adb shell df &#x2F;data</p><h2 id="关于ADB-IDEA"><a href="#关于ADB-IDEA" class="headerlink" title="关于ADB IDEA"></a>关于ADB IDEA</h2><p>AS插件ADB IDEA，装了这款插件可以直接在AS中快速操作一些ADB命令</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>1、双击shift -&gt; 点击action -&gt;搜索adb<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-5f962d67d5267c67.png" alt="image.png"></p><p>2、Ctrl + Shift + A，快捷键直接调用<br><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/20123021-0cb20333cd5ab9ca.png" alt="image.png"></p><h2 id="一些琐碎小问题"><a href="#一些琐碎小问题" class="headerlink" title="一些琐碎小问题"></a>一些琐碎小问题</h2><h4 id="不知应用包的入口Activity如何启动应用包"><a href="#不知应用包的入口Activity如何启动应用包" class="headerlink" title="不知应用包的入口Activity如何启动应用包"></a>不知应用包的入口Activity如何启动应用包</h4><p>1.通过category</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">adb shell monkey -<span class="selector-tag">p</span> &lt;packagename&gt; -c android<span class="selector-class">.intent</span><span class="selector-class">.category</span><span class="selector-class">.LAUNCHER</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><ol start="2"><li><a href="https://www.jianshu.com/p/150139c8295a">adb获取应用包入口的方案</a></li></ol><h4 id="adb-shell-input-text无法响应中文输入的问题"><a href="#adb-shell-input-text无法响应中文输入的问题" class="headerlink" title="adb shell input text无法响应中文输入的问题"></a>adb shell input text无法响应中文输入的问题</h4><p><a href="http://banmaman.com/2022/07/24/adb%20shell%20input%20text%E4%B8%8D%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%AD%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">adb shell input text不能输入中文的解决方案</a></p><h2 id="adb部分总结"><a href="#adb部分总结" class="headerlink" title="adb部分总结"></a>adb部分总结</h2><p><a href="https://www.jianshu.com/p/f6fa6759e747">adb小结</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;本文为小编学习总结的一些adb的常用命令，可能一些命令有待验证，更多内容可以参考&lt;a href=&quot;https://github.com/mz</summary>
      
    
    
    
    <category term="Android随笔" scheme="https://gun-ctrl.github.io/categories/Android%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="adb" scheme="https://gun-ctrl.github.io/tags/adb/"/>
    
  </entry>
  
  <entry>
    <title>RecyclerView高级用法——吸顶效果</title>
    <link href="https://gun-ctrl.github.io/2022/07/19/RecycleView%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/"/>
    <id>https://gun-ctrl.github.io/2022/07/19/RecycleView%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E2%80%94%E2%80%94%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C/</id>
    <published>2022-07-19T11:32:45.781Z</published>
    <updated>2022-08-19T06:49:06.068Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们对RecyclerView的使用不能仅仅停留在表面，可以探索一些高级的用法——自定义，不过要实现这些的前提是必须对RecycleView的源码流程有所了解。今天小编就略讲一下，主要是和今天的主体有关的内容。我们今天就来实现如下的吸顶效果。</p><h3 id="通过绘制实现RecyclerView的吸顶效果"><a href="#通过绘制实现RecyclerView的吸顶效果" class="headerlink" title="通过绘制实现RecyclerView的吸顶效果"></a>通过绘制实现RecyclerView的吸顶效果</h3><p>ItemDecoration</p><p>ItemDecoration允许应用给具体的View添加具体的图画或者layout的偏移，对于绘制View之间的分割线，视觉分组边界等等是非常有用的。</p><p>当我们调用addItemDecoration()方法添加decoration的时候，RecyclerView就会调用该类的onDraw方法区绘制分割线，也就是说：分割线是绘制出来的。</p><blockquote><p>RecyclerView.ItemDecoration，该类为抽象类，官方目前只提供了一个实现类DividerItemDecoration。</p><p>并且只有LinearLayoutManager能够使用</p></blockquote><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220719205304144.png" alt="image-20220719205304144"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/%E5%90%B8%E9%A1%B6%E6%95%88%E6%9E%9C.gif" alt="吸顶效果"></p><p>要实现这样的吸顶效果，首先，就需要了解一下RecyclerView.ItemDecoration的绘制流程。</p><p>1.onDraw</p><p>在绘制每个itemView之前绘制，上图中的每个跟着滑动的头部就是在此处绘制</p><p>2.onDrawOver</p><p>在绘制了每个ItemView之后绘制，上图中固定的顶部在此处绘制</p><p>3.getItemOffsets</p><p>设置偏移值，可以在绘制itemView时设置偏移值，其实上demo中的每个头部（红色区域）就是在绘制itemView预留了部分空间用于绘制头部。</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220719210625576.png" alt="image-20220719210625576"></p><blockquote><p>也就是说绘制流程是：onDraw()-&gt;ItemView-&gt;onDrawOver</p></blockquote><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li>在Adapter中创建两个方法<ul><li>1.获取组名</li><li>2.判断是否是组的头部<ul><li>首先，position&#x3D;0一定是组的头部</li><li>其次，可以通过前后两次组名判断当前item是不是组的头部</li></ul></li></ul></li></ul><figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">//是否是 组的第一个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isGroupHeader</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">String</span> currentName = <span class="built_in">getGroupName</span>(position);</span><br><span class="line">            <span class="type">String</span> preGroupName = <span class="built_in">getGroupName</span>(position<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">if</span> (preGroupName.<span class="built_in">equals</span>(currentName))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">String</span> <span class="title">getGroupName</span><span class="params">(<span class="type">int</span> position)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> modelList.<span class="built_in">get</span>(position).<span class="built_in">getGroupName</span>();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>自定义分割线</p><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void on<span class="constructor">Draw(@NonNull Canvas <span class="params">c</span>, @NonNull RecyclerView <span class="params">parent</span>, @NonNull RecyclerView.State <span class="params">state</span>)</span> &#123;</span><br><span class="line">        super.on<span class="constructor">Draw(<span class="params">c</span>, <span class="params">parent</span>, <span class="params">state</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (parent.get<span class="constructor">Adapter()</span> instanceof ModelAdapter)&#123;</span><br><span class="line">            ModelAdapter adapter = (ModelAdapter) parent.get<span class="constructor">Adapter()</span>;</span><br><span class="line">            <span class="built_in">int</span> count  = parent.get<span class="constructor">ChildCount()</span>;</span><br><span class="line">            <span class="built_in">int</span> left = parent.get<span class="constructor">PaddingLeft()</span>;</span><br><span class="line">            <span class="built_in">int</span> right  = parent.get<span class="constructor">Width()</span> - parent.get<span class="constructor">PaddingRight()</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">//获取对应的View</span></span><br><span class="line">                View view = parent.get<span class="constructor">ChildAt(<span class="params">i</span>)</span>;</span><br><span class="line">                <span class="comment">//获取View的布局位置</span></span><br><span class="line">                <span class="built_in">int</span> position = parent.get<span class="constructor">ChildLayoutPosition(<span class="params">view</span>)</span>;</span><br><span class="line">                <span class="comment">//判断是不是头部</span></span><br><span class="line">                boolean isGroupHeader = adapter.is<span class="constructor">GroupHeader(<span class="params">position</span>)</span>;</span><br><span class="line">                <span class="keyword">if</span> (isGroupHeader<span class="operator"> &amp;&amp; </span>view.get<span class="constructor">Top()</span> - groupHeaderHeight - parent.get<span class="constructor">PaddingTop()</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">view</span>.<span class="params">getTop</span>()</span>-groupHeaderHeight,right,view.get<span class="constructor">Top()</span>,headPaint);</span><br><span class="line">                    String groupName = adapter.get<span class="constructor">GroupName(<span class="params">position</span>)</span>;</span><br><span class="line">                    textPaint.get<span class="constructor">TextBounds(<span class="params">groupName</span>, 0, <span class="params">groupName</span>.<span class="params">length</span>()</span>, textRect);</span><br><span class="line">                    c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">view</span>.<span class="params">getTop</span>()</span>-groupHeaderHeight/<span class="number">2</span>+textRect.height<span class="literal">()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line"></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (view.get<span class="constructor">Top()</span> - groupHeaderHeight - parent.get<span class="constructor">PaddingTop()</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//分割线</span></span><br><span class="line">                    c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">view</span>.<span class="params">getTop</span>()</span>-<span class="number">4</span>,right,view.get<span class="constructor">Top()</span>,headPaint);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void on<span class="constructor">DrawOver(@NonNull Canvas <span class="params">c</span>, @NonNull RecyclerView <span class="params">parent</span>, @NonNull RecyclerView.State <span class="params">state</span>)</span> &#123;</span><br><span class="line">       super.on<span class="constructor">DrawOver(<span class="params">c</span>, <span class="params">parent</span>, <span class="params">state</span>)</span>;</span><br><span class="line">       <span class="keyword">if</span> (parent.get<span class="constructor">Adapter()</span> instanceof ModelAdapter)&#123;</span><br><span class="line">           ModelAdapter adapter = (ModelAdapter) parent.get<span class="constructor">Adapter()</span>;</span><br><span class="line">           <span class="comment">//返回可见区域的第一个item的position</span></span><br><span class="line">           <span class="built_in">int</span> position = ((LinearLayoutManager)parent.get<span class="constructor">LayoutManager()</span>).find<span class="constructor">FirstVisibleItemPosition()</span>;</span><br><span class="line">           <span class="comment">//获取对应的position的View</span></span><br><span class="line">           View itemView = parent.find<span class="constructor">ViewHolderForAdapterPosition(<span class="params">position</span>)</span>.itemView;</span><br><span class="line">           <span class="built_in">int</span> left = parent.get<span class="constructor">PaddingLeft()</span>;</span><br><span class="line">           <span class="built_in">int</span> right = parent.get<span class="constructor">Width()</span> - parent.get<span class="constructor">PaddingRight()</span>;</span><br><span class="line">           <span class="built_in">int</span> top = parent.get<span class="constructor">PaddingTop()</span>;</span><br><span class="line">           <span class="comment">//当下一个是组的头部时</span></span><br><span class="line">           boolean isGroupHeader = adapter.is<span class="constructor">GroupHeader(<span class="params">position</span>+1)</span>;</span><br><span class="line">           String groupName = adapter.get<span class="constructor">GroupName(<span class="params">position</span>)</span>;</span><br><span class="line">           textPaint.get<span class="constructor">TextBounds(<span class="params">groupName</span>,0,<span class="params">groupName</span>.<span class="params">length</span>()</span>,textRect);</span><br><span class="line">           <span class="keyword">if</span> (isGroupHeader)&#123;</span><br><span class="line">               <span class="comment">//对顶部进行缩小效果，在视觉上是被下一个组的顶部推进去的</span></span><br><span class="line">               <span class="built_in">int</span> bottom = <span class="module-access"><span class="module"><span class="identifier">Math</span>.</span></span>min(groupHeaderHeight,itemView.get<span class="constructor">Bottom()</span>-parent.get<span class="constructor">PaddingTop()</span>);</span><br><span class="line">               c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">bottom</span>,<span class="params">headPaint</span>)</span>;</span><br><span class="line">               c.clip<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">bottom</span>)</span>;</span><br><span class="line">               c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">top</span>+<span class="params">bottom</span>-<span class="params">groupHeaderHeight</span><span class="operator">/</span>2+<span class="params">textRect</span>.<span class="params">height</span>()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line">           &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">               c.draw<span class="constructor">Rect(<span class="params">left</span>,<span class="params">top</span>,<span class="params">right</span>,<span class="params">top</span>+<span class="params">groupHeaderHeight</span>,<span class="params">headPaint</span>)</span>;</span><br><span class="line">               c.draw<span class="constructor">Text(<span class="params">groupName</span>,<span class="params">left</span>+20,<span class="params">top</span>+<span class="params">groupHeaderHeight</span><span class="operator">/</span>2+<span class="params">textRect</span>.<span class="params">height</span>()</span>/<span class="number">2</span>,textPaint);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void getItemOffsets(@N<span class="keyword">on</span>Null Rect <span class="keyword">out</span>Rect, @N<span class="keyword">on</span>Null View view, @N<span class="keyword">on</span>Null RecyclerView <span class="keyword">parent</span>, @N<span class="keyword">on</span>Null RecyclerView.State <span class="keyword">state</span>) &#123;</span><br><span class="line">        super.getItemOffsets(<span class="keyword">out</span>Rect, view, <span class="keyword">parent</span>, <span class="keyword">state</span>);</span><br><span class="line">        if (<span class="keyword">parent</span>.getAdapter() instanceof ModelAdapter)&#123;</span><br><span class="line">            ModelAdapter adapter = (ModelAdapter) <span class="keyword">parent</span>.getAdapter();</span><br><span class="line">            int position = <span class="keyword">parent</span>.getChildAdapterPosition(view);</span><br><span class="line">            boolean isGroupHeader = adapter.isGroupHeader(position);</span><br><span class="line">            //判断itemView是不是头部</span><br><span class="line">            if (isGroupHeader)&#123;</span><br><span class="line">                //如果是头部，预留更大的地方</span><br><span class="line">                <span class="keyword">out</span>Rect.<span class="built_in">set</span>(<span class="number">0</span>,<span class="keyword">group</span>HeaderHeight,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                <span class="keyword">out</span>Rect.<span class="built_in">set</span>(<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实这部分的重点就是自定义分割线（ItemDecoration），弄清绘制顺序以及设置偏移值的作用就简单多了。当然，难点（也不是难点）就是弄清除尺寸参数,特别是尺寸变化引起的换组顶部推动效果。</p><p>其次就是特别注意有padding的情况，相信大家看出小编在这设置了顶部padding，有padding的时候需要注意尺寸。（不过有设置padding的情况很少）</p><p><a href="https://github.com/gun-ctrl/RecyclerViewPro">全部代码</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;我们对RecyclerView的使用不能仅仅停留在表面，可以探索一些高级的用法——自定义，不过要实现这些的前提是必须对RecycleView</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
    <category term="RecyclerView" scheme="https://gun-ctrl.github.io/tags/RecyclerView/"/>
    
  </entry>
  
  <entry>
    <title>京东淘宝首页二级联动</title>
    <link href="https://gun-ctrl.github.io/2022/07/18/%E4%BA%AC%E4%B8%9C%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/"/>
    <id>https://gun-ctrl.github.io/2022/07/18/%E4%BA%AC%E4%B8%9C%E6%B7%98%E5%AE%9D%E9%A6%96%E9%A1%B5%E4%BA%8C%E7%BA%A7%E8%81%94%E5%8A%A8/</id>
    <published>2022-07-18T13:38:25.672Z</published>
    <updated>2022-07-19T13:51:55.810Z</updated>
    
    <content type="html"><![CDATA[<p><strong>说明：</strong>这篇文章主要用于作者临时观看，因为涉及版权问题，所以短时间内会删除</p><h2 id="京东淘宝首页二级联动"><a href="#京东淘宝首页二级联动" class="headerlink" title="京东淘宝首页二级联动"></a>京东淘宝首页二级联动</h2><h3 id="单点触摸与多点触摸"><a href="#单点触摸与多点触摸" class="headerlink" title="单点触摸与多点触摸"></a>单点触摸与多点触摸</h3><p>####单点触摸</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212127652.png" alt="image-20220718212127652"></p><p>####多点触摸</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212142549.png" alt="image-20220718212142549"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212203113.png" alt="image-20220718212203113"></p><blockquote><p>面试题</p><p>一个move事件 中间有多少个手指的信息-&gt;有多少个手指就有多少个手指信息-&gt;最多32个</p></blockquote><h3 id="Touch事件源码"><a href="#Touch事件源码" class="headerlink" title="Touch事件源码"></a>Touch事件源码</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212217242.png" alt="image-20220718212217242"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212232559.png" alt="image-20220718212232559"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212254074.png" alt="image-20220718212254074"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212316235.png" alt="image-20220718212316235"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212335895.png" alt="image-20220718212335895"></p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212349700.png" alt="image-20220718212349700"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212414454.png" alt="image-20220718212414454"></p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212432841.png" alt="image-20220718212432841"></p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212452115.png" alt="image-20220718212452115"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212515213.png" alt="image-20220718212515213"></p><p>上述的disallowIntercept及相关内容就是所谓的“尚方宝剑”</p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212536424.png" alt="image-20220718212536424"></p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212555410.png" alt="image-20220718212555410"></p><p> <img src="C:\Users\15786\AppData\Roaming\Typora\typora-user-images\image-20220718212609465.png" alt="image-20220718212609465"></p><h3 id="嵌套滑动"><a href="#嵌套滑动" class="headerlink" title="嵌套滑动"></a>嵌套滑动</h3><blockquote><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212649556.png" alt="image-20220718212649556"></p></blockquote><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212704210.png" alt="image-20220718212704210"></p><p>并且从上面可以看出NestedScrollView既可以做“父亲”，也可以做“孩子”</p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212718655.png" alt="image-20220718212718655"></p><p>“孩子”有三个版本</p><p>三个版本之间是的关系  同样“父亲”也是一样</p><blockquote><p>版本2与版本1相比  增加了type 如惯性滑动效果</p></blockquote><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212737829.png" alt="image-20220718212737829"></p><h4 id="吸顶效果"><a href="#吸顶效果" class="headerlink" title="吸顶效果"></a>吸顶效果</h4><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212758009.png" alt="image-20220718212758009"></p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212818443.png" alt="image-20220718212818443"></p><p>onFinishInflate()中获取第一个孩子的第二个孩子，从下图可以看出也就是是第二个LinearLayout</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212839006.png" alt="image-20220718212839006"></p><h4 id="继续嵌套滑动"><a href="#继续嵌套滑动" class="headerlink" title="继续嵌套滑动"></a>继续嵌套滑动</h4><p>嵌套滑动-&gt;是由孩子主动的   触发的</p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212906775.png" alt="image-20220718212906775"></p><p>google为了方便我们处理嵌套滑动，所以提供了这个帮助类 -&gt; getScrollingChildHelper()</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212928635.png" alt="image-20220718212928635"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718212942972.png" alt="image-20220718212942972"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213001121.png" alt="image-20220718213001121"></p><p>while(p!&#x3D;null)一直找，直到找到支持嵌套滑动</p><p> <img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213017801.png" alt="image-20220718213017801"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213043191.png" alt="image-20220718213043191"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213058717.png" alt="image-20220718213058717"></p><p>所以它没有滑，“父亲”划不动的时候，它(NestedScrollView)才动</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213122243.png" alt="image-20220718213122243"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213138627.png" alt="image-20220718213138627"></p><p>问题描述：需求是整个页面滑动，当父View滑不动的时候，子View才动。问题出现的原因就是上面的文字描述，要想解决</p><p>问题的解决：重写onNestedPreScroll()方法，做一些设置，如果自己还能滑，那么就自己滑，并且需要记录一下（consumed[1]，0记录的x，1记录的y）</p><ul><li><p>注意：NetestScrollLayout是自定义继承NetestScrollView的</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213208543.png" alt="image-20220718213208543"></p></li></ul><h3 id="惯性滑动"><a href="#惯性滑动" class="headerlink" title="惯性滑动"></a>惯性滑动</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213227462.png" alt="image-20220718213227462"></p><p>记录下速度 velocityY</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213246067.png" alt="image-20220718213246067"></p><blockquote><ul><li>1、记下来速度 velocity</li><li>2、转化成 距离</li><li>3、自己滑了多少距离 根据速度转换后的距离 -&gt; 我自己的滑动距离 &#x3D; 孩子应该滑的距离</li><li>4、孩子应该滑的距离又要转化成速度</li></ul></blockquote><ul><li>google提供的速度转距离的工具</li></ul><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213300370.png" alt="image-20220718213300370"></p><p>孩子 -&gt;如recyclerView又会将距离转换成速度(因为RecyclerView只支持fling，所以需要转化成速度再转成距离)</p><p>下面两个方法分别对应上述步骤中的第3步和第4步</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213317734.png" alt="image-20220718213317734"></p><p><strong>关于totalDy</strong></p><p>下面注解一处错误：第一个，其实是Viewpager2，不是RecyclerView，通过前面有一张布局截图可以看出最后下面那个是ViewPager2</p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213340340.png" alt="image-20220718213340340"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213358954.png" alt="image-20220718213358954"></p><h3 id="关于内部拦截"><a href="#关于内部拦截" class="headerlink" title="关于内部拦截"></a>关于内部拦截</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213415057.png" alt="image-20220718213415057"></p><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220718213428785.png" alt="image-20220718213428785"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;这篇文章主要用于作者临时观看，因为涉及版权问题，所以短时间内会删除&lt;/p&gt;
&lt;h2 id=&quot;京东淘宝首页二级联动&quot;&gt;&lt;a href=&quot;#京东淘宝首页二级联动&quot; class=&quot;headerlink&quot; title=&quot;京东淘宝首页二级联动&quot;</summary>
      
    
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/categories/%E9%AB%98%E7%BA%A7UI/"/>
    
    
    <category term="高级UI" scheme="https://gun-ctrl.github.io/tags/%E9%AB%98%E7%BA%A7UI/"/>
    
  </entry>
  
  <entry>
    <title>按Z字形顺序打印二叉树</title>
    <link href="https://gun-ctrl.github.io/2022/07/17/%E6%8C%89Z%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://gun-ctrl.github.io/2022/07/17/%E6%8C%89Z%E5%AD%97%E5%BD%A2%E9%A1%BA%E5%BA%8F%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</id>
    <published>2022-07-17T02:37:21.023Z</published>
    <updated>2022-07-18T13:45:53.673Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）<br>数据范围：0≤n≤1500,树上每个节点的val满足∣val∣≤1500<br>要求：空间复杂度：O(n)，时间复杂度：O(n)</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><img src="https://banmaman-1312858980.cos.ap-chengdu.myqcloud.com/image-20220717104011278.png" alt="image-20220717104011278"></p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote><p>输入：{1,2,3,#,#,4,5}<br>输出： [[1],[3,2],[4,5]]<br>说明：如题面解释，第一层是根节点，从左到右打印结果，第二层从右到左，第三层从左到右。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这其实就是一个升级版的层序遍历.<br>观察其特点,无非就是奇数层和偶数层的输出顺序不一样. 这样就有了初步的解题思路,设置标识符flag(可以为整数型,也可以为boolean类型,整数类型无非就是对奇偶数的判断).<br>其余的思路就是层序遍历的思路,在每遍历新的一层之前,改变flag的值!flag(这里以boolean类型为例),然后就是利用Collections.reverse(list)对链表进行翻转.<br>详情可看代码</p><blockquote><p>这里,小编再提一下我初次遇到这道题的思路,前面的几乎一样,就是在实现链表反转这里,小编不熟悉Java库,没想到还有Colection.reverse这个方法可以用.<br>所以,小编在想反转的时候首先就想到了咱们的栈,也就是根据flag的值判断,从队列出来的值是否需要进一次栈实现反转</p></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">head</span> <span class="operator">=</span> pRoot;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; temp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">        temp.offer(head);</span><br><span class="line">        TreeNode p;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!temp.isEmpty())&#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> temp.size();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;size;++i)&#123;</span><br><span class="line">                p = temp.poll();</span><br><span class="line">                <span class="keyword">if</span>(p.left!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    temp.offer(p.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p.right!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    temp.offer(p.right);</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(p.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                Collections.reverse(list);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次是小编完善Hexo搭建后的第一篇博客，前面的都是在没完全搭建好的时候测试发送的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;给定一个二叉树，返回该二叉树的之字形层序遍历，（第一层从左向右，下一层从右向左，一直这样交替）&lt;br&gt;数据范围：0≤n≤15</summary>
      
    
    
    
    <category term="算法" scheme="https://gun-ctrl.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://gun-ctrl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>括号问题</title>
    <link href="https://gun-ctrl.github.io/2022/07/13/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/"/>
    <id>https://gun-ctrl.github.io/2022/07/13/%E6%8B%AC%E5%8F%B7%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-13T09:15:42.941Z</published>
    <updated>2022-07-19T13:51:54.291Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。</p><p>例如，给出n&#x3D;3，解集为：</p><p>“((()))”, “(()())”, “(())()”, “()()()”, “()(())”</p><p>数据范围：0&lt;&#x3D;n&lt;&#x3D;10</p><p>要求：空间复杂度O(n)，时间复杂度O(2^n)</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><blockquote><p>输入：1</p><p>返回值：[“()”]</p></blockquote><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><blockquote><p>输入：2</p><p>返回值：[“(())”，”()()”]</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>相当于一共n个左括号和n个右括号，可以给我们使用，我们需要依次组装这些括号。每当我们使用一个左括号之后，就剩下n-1个左括号和n个右括号给我们使用，结果拼在使用的左括号之后就行了，因此后者就是一个子问题，可以使用递归：</p><ul><li>终止条件：左右括号都使用了n个，将结果加入数组。</li><li>返回值：每一级向上一级返回后续组装后的字符串，即子问题中搭配出来的括号序列。</li><li>本级任务：每一级就是保证左括号还有剩余的情况下，使用一次左括号进入子问题，或者右括号还有剩余且右括号使用次数少于左括号的情况下使用一次右括号进入子问题。</li><li><strong>注意：</strong>我们需要保证左括号出现的次数比右括号多时我们再使用右括号就一定能保证括号合法了，因此每次需要检查左括号和右括号的使用次数。</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * @param n int整型 </span></span><br><span class="line"><span class="comment">     * @return string字符串ArrayList</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span>(<span class="type">int</span> left,<span class="type">int</span> right,<span class="built_in">String</span> temp,<span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; res,<span class="type">int</span> n)&#123;</span><br><span class="line">        <span class="comment">//左右括号都用完了，就加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(left==n&amp;&amp;right==n)&#123;</span><br><span class="line">            res.<span class="property">add</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left&lt;n)&#123;</span><br><span class="line">            <span class="title function_">recursion</span>(left+<span class="number">1</span>,right,temp + <span class="string">&quot;（&quot;</span>,res,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用一次有括号</span></span><br><span class="line">        <span class="keyword">if</span>(right&lt;n&amp;&amp;right&lt;left)&#123;</span><br><span class="line">            <span class="title function_">recursion</span>(left,right+<span class="number">1</span>,temp + <span class="string">&quot;）&quot;</span>,res,n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; <span class="title function_">generateParenthesis</span> (<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//记录结果</span></span><br><span class="line">        <span class="built_in">ArrayList</span>&lt;<span class="built_in">String</span>&gt; res = <span class="keyword">new </span><span class="class title_">ArrayList</span>&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="title function_">recursion</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>,res,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;给出n对括号，请编写一个函数来生成所有的由n对括号组成的合法组合。&lt;/p&gt;
&lt;p&gt;例如，给出n&amp;#x3D;3，解集为：&lt;/p</summary>
      
    
    
    
    <category term="算法" scheme="https://gun-ctrl.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://gun-ctrl.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
